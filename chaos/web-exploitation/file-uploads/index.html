<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ovelny - chaos/web-exploitation/file-uploads</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="ovelny - notes on infosec, penetration testing, programming and others"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" type=text/css href="/assets/css/dead-simple.min.css">
    <link rel="stylesheet" type=text/css href="/assets/css/rouge.min.css">
    <link
      href="/atom.xml"
      rel="alternate"
      title="ovelny"
      type="application/atom+xml"
    />
    <script src="/assets/js/scramble-text.min.js" defer></script>
    <script src="/assets/js/zoom-images.min.js" defer></script>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ovelny"/>
    <meta name="twitter:title" content="ovelny - chaos/web-exploitation/file-uploads"/>
    <meta name="twitter:image" content="https://ovelny.sh/assets/images/ovelny-logo.png"/>
    <meta name="twitter:image:alt" content="ovelny logo: 6 white circles grouped together forming a triangle shape, with a black background."/>
  </head>
  <body>

    <header>
      <section>
        <a href="/">
          <img
            class="logo"
            src="/assets/images/ovelny-pfp.png"
            alt="ovelny profile picture: a glitched picture of a three-eyed girl, staring intensely at the viewer."
          />
        </a>
        <h2><a class="ovelny" href="/">ovelny</a></h2>
      </section>
      <nav>
        <a href="/now/">now</a>
        <a href="/chaos/">chaos</a>
        <a href="/phasm/">phasm</a>
        <a href="/support/">support</a>
        <a href="/atom.xml" target="_blank" rel="noopener noreferrer">rss</a>
        <a href="/about/">about</a>
      </nav>
    </header>
    <main>

    
    <h1>file uploads</h1>

<p>uploading files to store malicious data and more. so much more.</p>

<h2>no validation</h2>

<p>if our target allows us to upload any file type, we might just get a web shell or reverse shell right away. we only need to identify the programming language used for the web server, with wappalyzer or other tools, and try to upload a shell written in that language. for PHP, a simple <code>&lt;?php system(&quot;id&quot;); ?&gt;</code> can work as a quick test.</p>

<h2>only client-side validation</h2>

<p>if only client-side validation is used, it can be easily bypassed by intercepting the upload request with a web proxy, or using devtools in our browser.</p>

<p>with a web proxy, upload the desired file type on the target (could be a .png for a profile image, etc) and intercept the request. during interception, modify the file extension and change the file&#39;s content to a web shell, using the programming language used for the web server. send the request and it should go through, as long as there is no server-side validation.</p>

<p>with devtools, we can modify or delete <code>accept=</code> attributes to allow for more file types, and check if some javascript code is verifying for uploaded file types. depending on the situation, we might directly edit the code with script override (which won&#39;t survive a page refresh, stay careful), or delete the code altogether if it doesn&#39;t break anything else.</p>

<p>i personally find that using a web proxy and intercepting requests is way easier.</p>

<h2>denylist filters</h2>

<p>if the back-end uses a denylist to restrict file extensions, we might also circumvent it as this is a very weak filter. the denylist might not be comprehensive, and tricks like file names being case insensitive in windows servers (<code>pHp == php</code>) might get us through.</p>

<p>to figure out the limits of the denylist, we can use a web proxy or ffuf and fuzz file extensions with wordlists, such as <code>/usr/share/seclists/Discovery/Web-Content/web-extensions.txt</code>. the following list for PHP file extensions from <a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst" rel="nofollow">PayloadsAllTheThings</a> might be useful too:</p>

<div class="highlight"><pre class="highlight plaintext"><code>.jpeg.php
.jpg.php
.png.php
.php
.php3
.php4
.php5
.php7
.php8
.pht
.phar
.phpt
.pgif
.phtml
.phtm
.php%00.gif
.php\x00.gif
.php%00.png
.php\x00.png
.php%00.jpg
.php\x00.jpg
</code></pre></div>

<p>if we find responses indicating that some extensions might be accepted (response size difference, etc), replace the file content with a simple payload such as <code>&lt;?php echo shell_exec(&#39;pwd&#39;); ?&gt;</code> and check if the back-end server is executing the code by accessing the file&#39;s path in your browser.</p>

<h2>allowlist filters</h2>

<p>an allowlist will only permit specific file types (or other criteria) to pass through validation. this can be bypassed if the filter is poorly implemented, like requiring a specific file extension but not at the end of the file name: a payload like <code>shell.jpg.php</code> might work in that scenario.</p>

<p>if the file extension is properly checked at the end of the file name, we might still be able to circumvent the filter with misconfigurations or outdated systems. the file upload functionality might be secure, but the web server could run an outdated version of apache, reproducing the same mistake seen earlier and allowing execution if a file extension is anywhere in the file name. in that case, a payload like <code>shell.php.jpg</code> might still be allowed code execution. look for <code>FilesMatch</code> and <code>SetHandler</code> keywords in <code>/etc/apache2/mods-enabled/php&lt;version number like 7.4.&gt;.conf</code> to find out potential misconfigurations.</p>

<p>finally, we might perform character injection to confuse the webapp about our file name and gain code execution. the most common example is the null character <code>%00</code> that might cause PHP servers with version <code>5.X</code> or earlier to terminate a string early. on windows servers, injecting a colon like <code>shell.aspx:.jpg</code> can have the same effect. we can generate all possible permutations for character injection with the following script:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="k">for </span>char <span class="k">in</span> <span class="s1">'%20'</span> <span class="s1">'%0a'</span> <span class="s1">'%00'</span> <span class="s1">'%0d0a'</span> <span class="s1">'/'</span> <span class="s1">'.\\'</span> <span class="s1">'.'</span> <span class="s1">'…'</span> <span class="s1">':'</span><span class="p">;</span> <span class="k">do
    for </span>ext <span class="k">in</span> <span class="s1">'.php'</span> <span class="s1">'.phps'</span><span class="p">;</span> <span class="k">do
        </span><span class="nb">echo</span> <span class="s2">"shell</span><span class="nv">$char$ext</span><span class="s2">.jpg"</span> <span class="o">&gt;&gt;</span> charinject.txt
        <span class="nb">echo</span> <span class="s2">"shell</span><span class="nv">$ext$char</span><span class="s2">.jpg"</span> <span class="o">&gt;&gt;</span> charinject.txt
        <span class="nb">echo</span> <span class="s2">"shell.jpg</span><span class="nv">$char$ext</span><span class="s2">"</span> <span class="o">&gt;&gt;</span> charinject.txt
        <span class="nb">echo</span> <span class="s2">"shell.jpg</span><span class="nv">$ext$char</span><span class="s2">"</span> <span class="o">&gt;&gt;</span> charinject.txt
    <span class="k">done
done</span>
</code></pre></div>

<p>just like denylist filters, we can try all these options with a web proxy or ffuf to fuzz the file upload functionality.</p>

<h2>type filters</h2>

<p>filtering by file extension is flawed, and most of the time type filters will be used instead. if the type is checked via the <code>Content-Type</code> header, we can simply intercept our request and change it before uploading our file. to fuzz the header and check which types are allowed, we can use <code>/usr/share/seclists/Miscellaneous/web/content-type.txt</code> and filter a relevant category for a smaller wordlist:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="nb">cat</span> /usr/share/seclists/Miscellaneous/web/content-type.txt | <span class="nb">grep</span> <span class="nt">-i</span> <span class="s1">'image/'</span> <span class="o">&gt;</span> img-content-types.txt
</code></pre></div>

<p>if the type is checked via its <code>MIME-type</code>, meaning that the file&#39;s first bytes are inspected for file signature / magic bytes, we can try to change those so the web server believes that our file is of another type. changing those can be tricky as some types begin with non-printable bytes, but others use ASCII and are easy to add, like prepending our file&#39;s content with <code>GIF8</code> to make it look like a gif image. use <code>file &lt;filename&gt;</code> in linux to make sure this worked.</p>

<h2>working around limitations</h2>

<p>on top of all previously mentioned techniques that may be used in conjunction, the target&#39;s webapp might not be exploitable with shell payloads. but we still got options to try out.</p>

<p>we can try to go for a stored XSS vulnerability instead: if we can upload HTML files and get them displayed somewhere, we can also run javascript code. other users will view the target&#39;s URL as trustworthy, but the malicious code on it will be ours.</p>

<p>if we can upload images and the webapp displays their metadata somewhere, we can add an XSS payload in EXIF data:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># this requires editing parameters that allow raw text,</span>
<span class="c"># such as 'Comment' or 'Artist':</span>
exiftool <span class="nt">-Comment</span><span class="o">=</span><span class="s1">' "&gt;&lt;img src=1 onerror=alert(window.origin)&gt;'</span> hacky.jpg
exiftool hacky.jpg <span class="c"># check output before uploading</span>
</code></pre></div>

<p>if we can change the MIME-type of our image to <code>text/html</code>, the webapp might show it as HTML and our XSS paylad would be triggered without any metadata viewing feature.</p>

<p>SVG files can also include XSS and XXE payloads:</p>

<div class="highlight"><pre class="highlight xml"><code><span class="c">&lt;!-- XSS payload example --&gt;</span>
<span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="cp">&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;</span>
<span class="nt">&lt;svg</span> <span class="na">xmlns=</span><span class="s">"http://www.w3.org/2000/svg"</span> <span class="na">version=</span><span class="s">"1.1"</span> <span class="na">width=</span><span class="s">"1"</span> <span class="na">height=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;rect</span> <span class="na">x=</span><span class="s">"1"</span> <span class="na">y=</span><span class="s">"1"</span> <span class="na">width=</span><span class="s">"1"</span> <span class="na">height=</span><span class="s">"1"</span> <span class="na">fill=</span><span class="s">"red"</span> <span class="na">stroke=</span><span class="s">"black"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;script</span> <span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;</span>alert(window.origin);<span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/svg&gt;</span>

<span class="c">&lt;!-- XXE payload example --&gt;</span>
<span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="cp">&lt;!DOCTYPE svg [ &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;</span> ]&gt;
<span class="nt">&lt;svg&gt;</span><span class="ni">&amp;xxe;</span><span class="nt">&lt;/svg&gt;</span>

<span class="c">&lt;!-- XXE payload with PHP filter to extract source code in base64 --&gt;</span>
<span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="cp">&lt;!DOCTYPE svg [ &lt;!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt;</span> ]&gt;
<span class="nt">&lt;svg&gt;</span><span class="ni">&amp;xxe;</span><span class="nt">&lt;/svg&gt;</span>
</code></pre></div>

<p>DoS attacks can also be carried out with file uploads, but they are outside the scope of this document. check out the following concepts if interested:</p>

<ul>
<li>decompression bomb</li>
<li>pixel flood</li>
<li>directory traversal upload</li>
</ul>

<h2>other ideas</h2>

<p>a list of techniques and attacks worth trying, depending on our target:</p>

<ul>
<li>file name injections, such as <code>file$(whoami).jpg</code> (or XSS, SQL, etc)</li>
<li>disclosing upload directory with fuzzing, LFI, XXE, IDOR, error messages, etc</li>
<li>attacks specific to windows, such as reserved characters or names, 8.3 filename convention, etc</li>
<li>attacks on processing done to uploaded files: encoding, compressing, etc</li>
</ul>

<h2>useful resources</h2>

<ul>
<li><a href="https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php" rel="nofollow">pentestmonkey&#39;s php reverse shell</a></li>
<li><a href="https://github.com/Arrexel/phpbash" rel="nofollow">phpbash for a good web shell</a></li>
<li><a href="https://gist.github.com/leommoore/f9e57ba2aa4bf197ebc5" rel="nofollow">list of file magic numbers</a></li>
</ul>

<h2>references</h2>

<ul>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files" rel="nofollow">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files</a></li>
<li><a href="https://book.hacktricks.xyz/pentesting-web/file-upload" rel="nofollow">https://book.hacktricks.xyz/pentesting-web/file-upload</a></li>
</ul>

    
    </main>
    <footer id="footer">
      <div class="footer-section"><a href="/license/">CC BY-NC-SA 4.0</a><p>&nbsp;::&nbsp;2019 - 2025 ovelny</p></div>
      <div class="footer-section">「七転び八起き」</div>
    </footer>
  </body>
</html>

