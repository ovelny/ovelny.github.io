<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ovelny - chaos/web-exploitation/command-injection</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="ovelny - notes on infosec, penetration testing, programming and others"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" type=text/css href="/assets/css/dead-simple.min.css">
    <link rel="stylesheet" type=text/css href="/assets/css/rouge.min.css">
    <link
      href="/atom.xml"
      rel="alternate"
      title="ovelny"
      type="application/atom+xml"
    />
    <script src="/assets/js/scramble-text.min.js" defer></script>
    <script src="/assets/js/zoom-images.min.js" defer></script>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ovelny"/>
    <meta name="twitter:title" content="ovelny - chaos/web-exploitation/command-injection"/>
    <meta name="twitter:image" content="https://ovelny.sh/assets/images/ovelny-logo.png"/>
    <meta name="twitter:image:alt" content="ovelny logo: 6 white circles grouped together forming a triangle shape, with a black background."/>
  </head>
  <body>

    <header>
      <section>
        <a href="/">
          <img
            class="logo"
            src="/assets/images/ovelny-pfp.png"
            alt="ovelny profile picture: a glitched picture of a three-eyed girl, staring intensely at the viewer."
          />
        </a>
        <h2><a class="ovelny" href="/">ovelny</a></h2>
      </section>
      <nav>
        <a href="/">home</a>
        <a href="/chaos/">chaos</a>
        <a href="/phasm/">phasm</a>
        <a href="/support/">support</a>
        <a href="/atom.xml" target="_blank" rel="noopener noreferrer">rss</a>
        <a href="/about/">about</a>
      </nav>
    </header>
    <main>

    
    <h1>Command injection</h1>

<p>Command injections allow us to execute system commands directly on the backend server: they are therefore one of the most critical types of vulnerabilities.</p>

<table><thead>
<tr>
<th>Injection type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>OS command injection</td>
<td>User input is part of an OS command.</td>
</tr>
<tr>
<td>Code injection</td>
<td>User input is directly found within a function evaluating code.</td>
</tr>
<tr>
<td>SQL injection</td>
<td>User input is part of an SQL query.</td>
</tr>
<tr>
<td>XSS / HTML injection</td>
<td>User input is directly displayed on a web page.</td>
</tr>
</tbody></table>

<p>Other types of injections include LDAP, NoSQL, HTTP header, XPath, IMAP, ORM injection and many others. They all involve improperly sanitized user input escaping its boundaries to execute something.</p>

<h2>Detecting OS command injections</h2>

<p>We can detect OS command injection vulnerabilities by testing harmless system commands against user input fields, like <code>id</code>, <code>whoami</code> or <code>pwd</code> for a Linux server. The process is exactly the same as exploiting the vulnerability, while keeping the target safe and unharmed.</p>

<p>We can escape boundary and inject our additional command with the following:</p>

<table><thead>
<tr>
<th>Injection character</th>
<th>URL-encoded character</th>
<th>Command(s) executed</th>
</tr>
</thead><tbody>
<tr>
<td>;</td>
<td>%3b</td>
<td>Intended one and injected one.</td>
</tr>
<tr>
<td>\n</td>
<td>%0a</td>
<td>Intended one and injected one.</td>
</tr>
<tr>
<td>&amp;</td>
<td>%26</td>
<td>Intended one and injected one.</td>
</tr>
<tr>
<td>&#124;</td>
<td>%7c</td>
<td>Intended one and injected one.</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>%26%26</td>
<td>Intended one and injected one.</td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td>%7c%7c</td>
<td>Injected one only (if first one fails).</td>
</tr>
<tr>
<td>``</td>
<td>%60%60</td>
<td>Intended one and injected one (Linux).</td>
</tr>
<tr>
<td>$()</td>
<td>%24%28%29</td>
<td>Intended one and injected one (Linux).</td>
</tr>
</tbody></table>

<h2>Detecting other command injections</h2>

<p>The process is the same, with characters matching the syntax related to the underlying language or protocol: LDAP, SQL, etc.</p>

<table><thead>
<tr>
<th>Injection type</th>
<th>Common injection characters</th>
</tr>
</thead><tbody>
<tr>
<td>SQL injection</td>
<td>&#39; , ; -- /* */</td>
</tr>
<tr>
<td>LDAP injection</td>
<td>* ( ) &amp; &#124;</td>
</tr>
<tr>
<td>XPath injection</td>
<td>&#39; or and not substring concat count</td>
</tr>
<tr>
<td>code injection</td>
<td>&#39; ; -- /* */ $() ${} #{} %{} ^</td>
</tr>
<tr>
<td>directory traversal</td>
<td>../ ..\\ %00</td>
</tr>
<tr>
<td>object injection</td>
<td>; &amp; &#124;</td>
</tr>
<tr>
<td>XQuery injection</td>
<td>&#39; ; -- /* */</td>
</tr>
<tr>
<td>shellcode injection</td>
<td>\x \u %u %n</td>
</tr>
<tr>
<td>header injection</td>
<td>\n \r\n \t %0d %0a %09</td>
</tr>
</tbody></table>

<h2>Bypassing character filters</h2>

<p>As always, if user input validation is only performed on the frontend, we can simply intercept our request with a web proxy and change it before sending it to the backend server. If the backend server is performing input validation too, we could fuzz all possible injection characters and see if one or several of them get through.</p>

<p>Spaces are often denied and can be replaced by <code>%09</code> (tab), <code>${IFS}</code> (usually set to space + tab) or brace expansions that add spaces between arguments like <code>{ls,-l}</code>. More can be found <a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection#bypass-without-space" rel="nofollow">here</a>.</p>

<p>Slashes can be replaced by brace expansions too, by selecting a substring of an environment variable containing them, such as <code>${PATH:0:1}</code>. The same workaround can be applied for other characters like semicolons, by leveraging any environment variable at our disposal. Use <code>printenv</code> or <code>env</code> to print them.</p>

<p>The same principle can be applied on windows machines, but it works differently. From <code>cmd</code>, we can specify a starting position for a windows variable, such as <code>%HOMEPATH:~7%</code>. If the backslash we want to use is at position <code>7</code>, we can then remove the rest of the string with a negative end position, like <code>%HOMEPATH:~7,-13%</code>. From powershell, a Windows variable is considered an array and can be easily accessed with <code>$env:HOMEPATH[0]</code>. Use <code>Get-ChildItem Env:</code> in powershell to print all environment variables.</p>

<p>We can also shift characters: In Linux, we can use <code>$(tr &#39;!-}&#39; &#39;&quot;-~&#39;&lt;&lt;&lt;CHAR)</code>, where <code>CHAR</code> is the character before the one we&#39;re aiming for in the ASCII table. Use <code>man ascii</code> to make sure you get the offset right. In powershell, we can achieve the same thing with <code>[char]$letter = &#39;CHAR&#39;; $letter = [byte]$letter + 1; echo $letter</code>.</p>

<h2>Bypassing command filters</h2>

<p>Entire commands might also be filtered, like <code>whoami</code>, <code>pwd</code>, <code>cat</code> and so on. Depending on the filter implemented on the back-end server, we might bypass it by obfuscating our command(s):</p>

<table><thead>
<tr>
<th>Obfuscated command</th>
<th>OS</th>
</tr>
</thead><tbody>
<tr>
<td>w&#39;h&#39;o&#39;ami&#39;</td>
<td>Both linux and Windows.</td>
</tr>
<tr>
<td>w&quot;h&quot;o&quot;ami&quot;</td>
<td>Both linux and Windows.</td>
</tr>
<tr>
<td>who$@ami</td>
<td>Linux.</td>
</tr>
<tr>
<td>w\ho\am\i</td>
<td>Linux.</td>
</tr>
<tr>
<td>who^ami</td>
<td>Windows (Powershell and cmd.exe).</td>
</tr>
<tr>
<td>WHoAmI</td>
<td>Windows (Powershell and cmd.exe).</td>
</tr>
<tr>
<td>$(tr &quot;[A-Z]&quot; &quot;[a-z]&quot;&lt;&lt;&lt;&quot;WHoAmI&quot;)</td>
<td>Linux (replace spaces first).</td>
</tr>
<tr>
<td>$(a=&quot;WHoAmI&quot;;printf %s &quot;${a,,}&quot;)</td>
<td>Linux (replace spaces first).</td>
</tr>
<tr>
<td>$(rev&lt;&lt;&lt;&#39;imaohw&#39;)</td>
<td>Linux.</td>
</tr>
<tr>
<td>iex &quot;$(&#39;imaohw&#39;[-1..-20] -join &#39;&#39;)&quot;</td>
<td>Windows (Powershell).</td>
</tr>
<tr>
<td><code>bash&lt;&lt;&lt;$(base64 -d&lt;&lt;&lt;BASE64_COMMAND)</code></td>
<td>Linux.</td>
</tr>
</tbody></table>

<p>The last Linux command can also be done in Powershell with:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">iex</span><span class="w"> </span><span class="s2">"</span><span class="si">$(</span><span class="p">[</span><span class="n">System.Text.Encoding</span><span class="p">]::</span><span class="n">Unicode.GetString</span><span class="p">([</span><span class="n">System.Convert</span><span class="p">]::</span><span class="n">FromBase64String</span><span class="p">(</span><span class="s1">'BASE64_COMMAND'</span><span class="si">)</span><span class="s2">))"</span><span class="w">
</span></code></pre></div>

<p>In Linux, encode your command to base64 with: </p>

<div class="highlight"><pre class="highlight shell"><code><span class="nb">echo</span> <span class="nt">-n</span> <span class="s1">'&lt;command&gt;'</span> | iconv <span class="nt">-f</span> utf-8 <span class="nt">-t</span> utf-16le | <span class="nb">base64</span>
</code></pre></div>

<p>In Windows, use:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="p">[</span><span class="n">Convert</span><span class="p">]::</span><span class="n">ToBase64String</span><span class="p">([</span><span class="n">System.Text.Encoding</span><span class="p">]::</span><span class="n">Unicode.GetBytes</span><span class="p">(</span><span class="s1">'&lt;command&gt;'</span><span class="p">))</span><span class="w">
</span></code></pre></div>

<p>You can also use <a href="https://github.com/Bashfuscator/Bashfuscator" rel="nofollow">bashfuscator</a> for automated obfuscation:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Obfuscate a bash command with best size and speed,</span>
<span class="c"># using only one layer of obfuscation. Replace spaces</span>
<span class="c"># with URL-encoded tabs:</span>
bashfuscator <span class="nt">-c</span> <span class="s1">'&lt;command&gt;'</span> <span class="nt">-s</span> 1 <span class="nt">-t</span> 1 <span class="nt">--no-mangling</span> <span class="nt">--layers</span> 1 | <span class="nb">sed</span> <span class="s1">'s/ /%09/g'</span>
</code></pre></div>

<p>For windows, consider <a href="https://github.com/danielbohannon/Invoke-DOSfuscation" rel="nofollow">DOSfuscation</a>.</p>

<h2>References</h2>

<ul>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection" rel="nofollow">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection</a></li>
</ul>

    
    </main>
    <footer id="footer">
      <div class="footer-section"><a href="/license/">CC BY-NC-SA 4.0</a><p>&nbsp;::&nbsp;2019 - 2025 ovelny</p></div>
      <div class="footer-section">「七転び八起き」</div>
    </footer>
  </body>
</html>

