<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ovelny - chaos/beej's-guide-to-network-programming/05-system-calls-or-bust</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="ovelny - notes on infosec, penetration testing, programming and others"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" type=text/css href="/assets/css/dead-simple.min.css">
    <link rel="stylesheet" type=text/css href="/assets/css/rouge.min.css">
    <link
      href="/atom.xml"
      rel="alternate"
      title="ovelny"
      type="application/atom+xml"
    />
    <script src="/assets/js/scramble-text.min.js" defer></script>
    <script src="/assets/js/zoom-images.min.js" defer></script>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ovelny"/>
    <meta name="twitter:title" content="ovelny - chaos/beej's-guide-to-network-programming/05-system-calls-or-bust"/>
    <meta name="twitter:image" content="https://ovelny.sh/assets/images/ovelny-logo.png"/>
    <meta name="twitter:image:alt" content="ovelny logo: 6 white circles grouped together forming a triangle shape, with a black background."/>
  </head>
  <body>

    <header>
      <section>
        <a href="/">
          <img
            class="logo"
            src="/assets/images/ovelny-pfp.png"
            alt="ovelny profile picture: a glitched picture of a three-eyed girl, staring intensely at the viewer."
          />
        </a>
        <h2><a class="ovelny" href="/">ovelny</a></h2>
      </section>
      <nav>
        <a href="/">home</a>
        <a href="/chaos/">chaos</a>
        <a href="/phasm/">phasm</a>
        <a href="/support/">support</a>
        <a href="/atom.xml" target="_blank" rel="noopener noreferrer">rss</a>
        <a href="/about/">about</a>
      </nav>
    </header>
    <main>

    
    <h1>5 System Calls or Bust</h1>

<p>This is the section where we get into the system calls (and other library calls) that allow you to access the network functionality of a Unix box, or any box that supports the sockets API for that matter (BSD, Windows, Linux, Mac, what-have-you.) When you call one of these functions, the kernel takes over and does all the work for you automagically.</p>

<p>The place most people get stuck around here is what order to call these things in. In that, the <code>man</code> pages are no use, as you’ve probably discovered. Well, to help with that dreadful situation, I’ve tried to lay out the system calls in the following sections in <em>exactly</em> (approximately) the same order that you’ll need to call them in your programs.</p>

<p>That, coupled with a few pieces of sample code here and there, some milk and cookies (which I fear you will have to supply yourself), and some raw guts and courage, and you’ll be beaming data around the Internet like the Son of Jon Postel!</p>

<p><em>(Please note that for brevity, many code snippets below do not include necessary error checking. And they very commonly assume that the result from calls to <code>getaddrinfo()</code> succeed and return a valid entry in the linked list. Both of these situations are properly addressed in the stand-alone programs, though, so use those as a model.)</em></p>

<h2>5.1 <code>getaddrinfo()</code>—Prepare to launch!</h2>

<p>This is a real workhorse of a function with a lot of options, but usage is actually pretty simple. It helps set up the <code>struct</code>s you need later on.</p>

<p>A tiny bit of history: it used to be that you would use a function called <code>gethostbyname()</code> to do DNS lookups. Then you’d load that information by hand into a <code>struct sockaddr_in</code>, and use that in your calls.</p>

<p>This is no longer necessary, thankfully. (Nor is it desirable, if you want to write code that works for both IPv4 and IPv6!) In these modern times, you now have the function <code>getaddrinfo()</code> that does all kinds of good stuff for you, including DNS and service name lookups, and fills out the <code>struct</code>s you need, besides!</p>

<p>Let’s take a look!</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">getaddrinfo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>     <span class="c1">// e.g. "www.example.com" or IP</span>
                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">service</span><span class="p">,</span>  <span class="c1">// e.g. "http" or port number</span>
                <span class="k">const</span> <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">hints</span><span class="p">,</span>
                <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">**</span><span class="n">res</span><span class="p">);</span>
</code></pre></div>

<p>You give this function three input parameters, and it gives you a pointer to a linked-list, <code>res</code>, of results.</p>

<p>The <code>node</code> parameter is the host name to connect to, or an IP address.</p>

<p>Next is the parameter <code>service</code>, which can be a port number, like “80”, or the name of a particular service (found in <a href="https://www.iana.org/assignments/port-numbers" rel="nofollow">The IANA Port List</a><a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-network-programming/99-footnotes/" rel="nofollow">²⁰</a> or the <code>/etc/services</code> file on your Unix machine) like “http” or “ftp” or “telnet” or “smtp” or whatever.</p>

<p>Finally, the <code>hints</code> parameter points to a <code>struct addrinfo</code> that you’ve already filled out with relevant information.</p>

<p>Here’s a sample call if you’re a server who wants to listen on your host’s IP address, port 3490. Note that this doesn’t actually do any listening or network setup; it merely sets up structures we’ll use later:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">servinfo</span><span class="p">;</span>  <span class="c1">// will point to the results</span>

<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">hints</span><span class="p">);</span> <span class="c1">// make sure the struct is empty</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_UNSPEC</span><span class="p">;</span>     <span class="c1">// don't care IPv4 or IPv6</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span> <span class="c1">// TCP stream sockets</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="n">AI_PASSIVE</span><span class="p">;</span>     <span class="c1">// fill in my IP for me</span>

<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">getaddrinfo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">"3490"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">servinfo</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"getaddrinfo error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">gai_strerror</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// servinfo now points to a linked list of 1 or more struct addrinfos</span>

<span class="c1">// ... do everything until you don't need servinfo anymore ....</span>

<span class="n">freeaddrinfo</span><span class="p">(</span><span class="n">servinfo</span><span class="p">);</span> <span class="c1">// free the linked-list</span>
</code></pre></div>

<p>Notice that I set the <code>ai_family</code> to <code>AF_UNSPEC</code>, thereby saying that I don’t care if we use IPv4 or IPv6. You can set it to <code>AF_INET</code> or <code>AF_INET6</code> if you want one or the other specifically.</p>

<p>Also, you’ll see the <code>AI_PASSIVE</code> flag in there; this tells <code>getaddrinfo()</code> to assign the address of my local host to the socket structures. This is nice because then you don’t have to hardcode it. (Or you can put a specific address in as the first parameter to <code>getaddrinfo()</code> where I currently have <code>NULL</code>, up there.)</p>

<p>Then we make the call. If there’s an error (<code>getaddrinfo()</code> returns non-zero), we can print it out using the function <code>gai_strerror()</code>, as you see. If everything works properly, though, <code>servinfo</code> will point to a linked list of <code>struct addrinfo</code>s, each of which contains a <code>struct sockaddr</code> of some kind that we can use later! Nifty!</p>

<p>Finally, when we’re eventually all done with the linked list that <code>getaddrinfo()</code> so graciously allocated for us, we can (and should) free it all up with a call to <code>freeaddrinfo()</code>.</p>

<p>Here’s a sample call if you’re a client who wants to connect to a particular server, say “www.example.net” port 3490. Again, this doesn’t actually connect, but it sets up the structures we’ll use later:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">servinfo</span><span class="p">;</span>  <span class="c1">// will point to the results</span>

<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">hints</span><span class="p">);</span> <span class="c1">// make sure the struct is empty</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_UNSPEC</span><span class="p">;</span>     <span class="c1">// don't care IPv4 or IPv6</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span> <span class="c1">// TCP stream sockets</span>

<span class="c1">// get ready to connect</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">getaddrinfo</span><span class="p">(</span><span class="s">"www.example.net"</span><span class="p">,</span> <span class="s">"3490"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">servinfo</span><span class="p">);</span>

<span class="c1">// servinfo now points to a linked list of 1 or more struct addrinfos</span>

<span class="c1">// etc.</span>
</code></pre></div>

<p>I keep saying that <code>servinfo</code> is a linked list with all kinds of address information. Let’s write a quick demo program to show off this information. <a href="https://beej.us/guide/bgnet/examples/showip.c" rel="nofollow">This short program</a><a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-network-programming/99-footnotes/" rel="nofollow">²¹</a> will print the IP addresses for whatever host you specify on the command line:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cm">/*
** showip.c -- show IP addresses for a host given on the command line
*/</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">ipstr</span><span class="p">[</span><span class="n">INET6_ADDRSTRLEN</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"usage: showip hostname</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">hints</span><span class="p">);</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_UNSPEC</span><span class="p">;</span> <span class="c1">// AF_INET or AF_INET6 to force version</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">getaddrinfo</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"getaddrinfo: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">gai_strerror</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"IP addresses for %s:</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">ipver</span><span class="p">;</span>

        <span class="c1">// get the pointer to the address itself,</span>
        <span class="c1">// different fields in IPv4 and IPv6:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// IPv4</span>
            <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">ipv4</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">;</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ipv4</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">);</span>
            <span class="n">ipver</span> <span class="o">=</span> <span class="s">"IPv4"</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// IPv6</span>
            <span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">ipv6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">;</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ipv6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">);</span>
            <span class="n">ipver</span> <span class="o">=</span> <span class="s">"IPv6"</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// convert the IP to a string and print it:</span>
        <span class="n">inet_ntop</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ipstr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ipstr</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  %s: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ipver</span><span class="p">,</span> <span class="n">ipstr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">freeaddrinfo</span><span class="p">(</span><span class="n">res</span><span class="p">);</span> <span class="c1">// free the linked list</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>As you see, the code calls <code>getaddrinfo()</code> on whatever you pass on the command line, that fills out the linked list pointed to by <code>res</code>, and then we can iterate over the list and print stuff out or do whatever.</p>

<p>(There’s a little bit of ugliness there where we have to dig into the different types of <code>struct sockaddr</code>s depending on the IP version. Sorry about that! I’m not sure of a better way around it.)</p>

<p>Sample run! Everyone loves screenshots:</p>

<div class="highlight"><pre class="highlight plaintext"><code>$ showip www.example.net
IP addresses for www.example.net:

  IPv4: 192.0.2.88

$ showip ipv6.example.com
IP addresses for ipv6.example.com:

  IPv4: 192.0.2.101
  IPv6: 2001:db8:8c00:22::171
</code></pre></div>

<p>Now that we have that under control, we’ll use the results we get from <code>getaddrinfo()</code> to pass to other socket functions and, at long last, get our network connection established! Keep reading!</p>

<h2>5.2 <code>socket()</code>—Get the File Descriptor!</h2>

<p>I guess I can put it off no longer—I have to talk about the <code>socket()</code> system call. Here’s the breakdown:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span> 
</code></pre></div>

<p>But what are these arguments? They allow you to say what kind of socket you want (IPv4 or IPv6, stream or datagram, and TCP or UDP).</p>

<p>It used to be people would hardcode these values, and you can absolutely still do that. (<code>domain</code> is <code>PF_INET</code> or <code>PF_INET6</code>, <code>type</code> is <code>SOCK_STREAM</code> or <code>SOCK_DGRAM</code>, and <code>protocol</code> can be set to <code>0</code> to choose the proper protocol for the given <code>type</code>. Or you can call <code>getprotobyname()</code> to look up the protocol you want, “tcp” or “udp”.)</p>

<p>(This <code>PF_INET</code> thing is a close relative of the <code>AF_INET</code> that you can use when initializing the <code>sin_family</code> field in your <code>struct sockaddr_in</code>. In fact, they’re so closely related that they actually have the same value, and many programmers will call <code>socket()</code> and pass <code>AF_INET</code> as the first argument instead of <code>PF_INET</code>. Now, get some milk and cookies, because it’s time for a story. Once upon a time, a long time ago, it was thought that maybe an address family (what the “AF” in “<code>AF_INET</code>” stands for) might support several protocols that were referred to by their protocol family (what the “PF” in “<code>PF_INET</code>” stands for). That didn’t happen. And they all lived happily ever after, The End. So the most correct thing to do is to use <code>AF_INET</code> in your <code>struct sockaddr_in</code> and <code>PF_INET</code> in your call to <code>socket()</code>.)</p>

<p>Anyway, enough of that. What you really want to do is use the values from the results of the call to <code>getaddrinfo()</code>, and feed them into <code>socket()</code> directly like this:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

<span class="c1">// do the lookup</span>
<span class="c1">// [pretend we already filled out the "hints" struct]</span>
<span class="n">getaddrinfo</span><span class="p">(</span><span class="s">"www.example.com"</span><span class="p">,</span> <span class="s">"http"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>

<span class="c1">// again, you should do error-checking on getaddrinfo(), and walk</span>
<span class="c1">// the "res" linked list looking for valid entries instead of just</span>
<span class="c1">// assuming the first one is good (like many of these examples do).</span>
<span class="c1">// See the section on client/server for real examples.</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">);</span>
</code></pre></div>

<p><code>socket()</code> simply returns to you a <em>socket descriptor</em> that you can use in later system calls, or <code>-1</code> on error. The global variable <code>errno</code> is set to the error’s value (see the <a href="man-pages.html#errnoman" rel="nofollow"><code>errno</code></a> man page for more details, and a quick note on using <code>errno</code> in multithreaded programs).</p>

<p>Fine, fine, fine, but what good is this socket? The answer is that it’s really no good by itself, and you need to read on and make more system calls for it to make any sense.</p>

<h2>5.3 <code>bind()</code>—What port am I on?</h2>

<p>Once you have a socket, you might have to associate that socket with a port on your local machine. (This is commonly done if you’re going to <code>listen()</code> for incoming connections on a specific port—multiplayer network games do this when they tell you to “connect to 192.168.5.10 port 3490”.) The port number is used by the kernel to match an incoming packet to a certain process’s socket descriptor. If you’re going to only be doing a <code>connect()</code> (because you’re the client, not the server), this is probably unnecessary. Read it anyway, just for kicks.</p>

<p>Here is the synopsis for the <code>bind()</code> system call:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">my_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">);</span>
</code></pre></div>

<p><code>sockfd</code> is the socket file descriptor returned by <code>socket()</code>. <code>my_addr</code> is a pointer to a <code>struct sockaddr</code> that contains information about your address, namely, port and IP address. <code>addrlen</code> is the length in bytes of that address.</p>

<p>Whew. That’s a bit to absorb in one chunk. Let’s have an example that binds the socket to the host the program is running on, port 3490:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>

<span class="c1">// first, load up address structs with getaddrinfo():</span>

<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">hints</span><span class="p">);</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_UNSPEC</span><span class="p">;</span>  <span class="c1">// use IPv4 or IPv6, whichever</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="n">AI_PASSIVE</span><span class="p">;</span>     <span class="c1">// fill in my IP for me</span>

<span class="n">getaddrinfo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">"3490"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>

<span class="c1">// make a socket:</span>

<span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">);</span>

<span class="c1">// bind it to the port we passed in to getaddrinfo():</span>

<span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">);</span>
</code></pre></div>

<p>By using the <code>AI_PASSIVE</code> flag, I’m telling the program to bind to the IP of the host it’s running on. If you want to bind to a specific local IP address, drop the <code>AI_PASSIVE</code> and put an IP address in for the first argument to <code>getaddrinfo()</code>.</p>

<p><code>bind()</code> also returns <code>-1</code> on error and sets <code>errno</code> to the error’s value.</p>

<p>Lots of old code manually packs the <code>struct sockaddr_in</code> before calling <code>bind()</code>. Obviously this is IPv4-specific, but there’s really nothing stopping you from doing the same thing with IPv6, except that using <code>getaddrinfo()</code> is going to be easier, generally. Anyway, the old code looks something like this:</p>

<div class="highlight"><pre class="highlight c"><code><span class="c1">// !!! THIS IS THE OLD WAY !!!</span>

<span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">my_addr</span><span class="p">;</span>

<span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">my_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
<span class="n">my_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">MYPORT</span><span class="p">);</span>     <span class="c1">// short, network byte order</span>
<span class="n">my_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">"10.12.110.57"</span><span class="p">);</span>
<span class="n">memset</span><span class="p">(</span><span class="n">my_addr</span><span class="p">.</span><span class="n">sin_zero</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">my_addr</span><span class="p">.</span><span class="n">sin_zero</span><span class="p">);</span>

<span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">my_addr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">my_addr</span><span class="p">);</span>
</code></pre></div>

<p>In the above code, you could also assign <code>INADDR_ANY</code> to the <code>s_addr</code> field if you wanted to bind to your local IP address (like the <code>AI_PASSIVE</code> flag, above). The IPv6 version of <code>INADDR_ANY</code> is a global variable <code>in6addr_any</code> that is assigned into the <code>sin6_addr</code> field of your <code>struct sockaddr_in6</code>. (There is also a macro <code>IN6ADDR_ANY_INIT</code> that you can use in a variable initializer.)</p>

<p>Another thing to watch out for when calling <code>bind()</code>: don’t go underboard with your port numbers. All ports below 1024 are RESERVED (unless you’re the superuser)! You can have any port number above that, right up to 65535 (provided they aren’t already being used by another program).</p>

<p>Sometimes, you might notice, you try to rerun a server and <code>bind()</code> fails, claiming “Address already in use.” What does that mean? Well, a little bit of a socket that was connected is still hanging around in the kernel, and it’s hogging the port. You can either wait for it to clear (a minute or so), or add code to your program allowing it to reuse the port, like this:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">yes</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">//char yes='1'; // Solaris people use this</span>

<span class="c1">// lose the pesky "Address already in use" error message</span>
<span class="k">if</span> <span class="p">(</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="n">SO_REUSEADDR</span><span class="p">,</span><span class="o">&amp;</span><span class="n">yes</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">yes</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"setsockopt"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span> 
</code></pre></div>

<p>One small extra final note about <code>bind()</code>: there are times when you won’t absolutely have to call it. If you are <code>connect()</code>ing to a remote machine and you don’t care what your local port is (as is the case with <code>telnet</code> where you only care about the remote port), you can simply call <code>connect()</code>, it’ll check to see if the socket is unbound, and will <code>bind()</code> it to an unused local port if necessary.</p>

<h2>5.4 <code>connect()</code>—Hey, you!</h2>

<p>Let’s just pretend for a few minutes that you’re a telnet application. Your user commands you (just like in the movie <em>TRON</em>) to get a socket file descriptor. You comply and call <code>socket()</code>. Next, the user tells you to connect to “<code>10.12.110.57</code>” on port “<code>23</code>” (the standard telnet port). Yow! What do you do now?</p>

<p>Lucky for you, program, you’re now perusing the section on <code>connect()</code>—how to connect to a remote host. So read furiously onward! No time to lose!</p>

<p>The <code>connect()</code> call is as follows:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">serv_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">);</span> 
</code></pre></div>

<p><code>sockfd</code> is our friendly neighborhood socket file descriptor, as returned by the <code>socket()</code> call, <code>serv_addr</code> is a <code>struct sockaddr</code> containing the destination port and IP address, and <code>addrlen</code> is the length in bytes of the server address structure.</p>

<p>All of this information can be gleaned from the results of the <code>getaddrinfo()</code> call, which rocks.</p>

<p>Is this starting to make more sense? I can’t hear you from here, so I’ll just have to hope that it is. Let’s have an example where we make a socket connection to “<code>www.example.com</code>”, port <code>3490</code>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>

<span class="c1">// first, load up address structs with getaddrinfo():</span>

<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">hints</span><span class="p">);</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_UNSPEC</span><span class="p">;</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span>

<span class="n">getaddrinfo</span><span class="p">(</span><span class="s">"www.example.com"</span><span class="p">,</span> <span class="s">"3490"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>

<span class="c1">// make a socket:</span>

<span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">);</span>

<span class="c1">// connect!</span>

<span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">);</span>
</code></pre></div>

<p>Again, old-school programs filled out their own <code>struct sockaddr_in</code>s to pass to <code>connect()</code>. You can do that if you want to. See the similar note in the <a href="system-calls-or-bust.html#bind" rel="nofollow"><code>bind()</code> section</a>, above.</p>

<p>Be sure to check the return value from <code>connect()</code>—it’ll return <code>-1</code> on error and set the variable <code>errno</code>.</p>

<p>Also, notice that we didn’t call <code>bind()</code>. Basically, we don’t care about our local port number; we only care where we’re going (the remote port). The kernel will choose a local port for us, and the site we connect to will automatically get this information from us. No worries.</p>

<h2>5.5 <code>listen()</code>—Will somebody please call me?</h2>

<p>OK, time for a change of pace. What if you don’t want to connect to a remote host. Say, just for kicks, that you want to wait for incoming connections and handle them in some way. The process is two step: first you <code>listen()</code>, then you <code>accept()</code> (see below).</p>

<p>The <code>listen()</code> call is fairly simple, but requires a bit of explanation:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span> 
</code></pre></div>

<p><code>sockfd</code> is the usual socket file descriptor from the <code>socket()</code> system call. <code>backlog</code> is the number of connections allowed on the incoming queue. What does that mean? Well, incoming connections are going to wait in this queue until you <code>accept()</code> them (see below) and this is the limit on how many can queue up. Most systems silently limit this number to about 20; you can probably get away with setting it to <code>5</code> or <code>10</code>.</p>

<p>Again, as per usual, <code>listen()</code> returns <code>-1</code> and sets <code>errno</code> on error.</p>

<p>Well, as you can probably imagine, we need to call <code>bind()</code> before we call <code>listen()</code> so that the server is running on a specific port. (You have to be able to tell your buddies which port to connect to!) So if you’re going to be listening for incoming connections, the sequence of system calls you’ll make is:</p>

<div class="highlight"><pre class="highlight c"><code><span class="n">getaddrinfo</span><span class="p">();</span>
<span class="n">socket</span><span class="p">();</span>
<span class="n">bind</span><span class="p">();</span>
<span class="n">listen</span><span class="p">();</span>
<span class="cm">/* accept() goes here */</span> 
</code></pre></div>

<p>I’ll just leave that in the place of sample code, since it’s fairly self-explanatory. (The code in the <code>accept()</code> section, below, is more complete.) The really tricky part of this whole sha-bang is the call to <code>accept()</code>.</p>

<h2>5.6 <code>accept()</code>—“Thank you for calling port 3490.”</h2>

<p>Get ready—the <code>accept()</code> call is kinda weird! What’s going to happen is this: someone far far away will try to <code>connect()</code> to your machine on a port that you are <code>listen()</code>ing on. Their connection will be queued up waiting to be <code>accept()</code>ed. You call <code>accept()</code> and you tell it to get the pending connection. It’ll return to you a <em>brand new socket file descriptor</em> to use for this single connection! That’s right, suddenly you have <em>two socket file descriptors</em> for the price of one! The original one is still listening for more new connections, and the newly created one is finally ready to <code>send()</code> and <code>recv()</code>. We’re there!</p>

<p>The call is as follows:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span> 
</code></pre></div>

<p><code>sockfd</code> is the <code>listen()</code>ing socket descriptor. Easy enough. <code>addr</code> will usually be a pointer to a local <code>struct sockaddr_storage</code>. This is where the information about the incoming connection will go (and with it you can determine which host is calling you from which port). <code>addrlen</code> is a local integer variable that should be set to <code>sizeof(struct sockaddr_storage)</code> before its address is passed to <code>accept()</code>. <code>accept()</code> will not put more than that many bytes into <code>addr</code>. If it puts fewer in, it’ll change the value of <code>addrlen</code> to reflect that.</p>

<p>Guess what? <code>accept()</code> returns <code>-1</code> and sets <code>errno</code> if an error occurs. Betcha didn’t figure that.</p>

<p>Like before, this is a bunch to absorb in one chunk, so here’s a sample code fragment for your perusal:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span>
<span class="cp">#define MYPORT "3490"  // the port users will be connecting to
#define BACKLOG 10     // how many pending connections queue will hold
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">their_addr</span><span class="p">;</span>
    <span class="n">socklen_t</span> <span class="n">addr_size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">new_fd</span><span class="p">;</span>

    <span class="c1">// !! don't forget your error checking for these calls !!</span>

    <span class="c1">// first, load up address structs with getaddrinfo():</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">hints</span><span class="p">);</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_UNSPEC</span><span class="p">;</span>  <span class="c1">// use IPv4 or IPv6, whichever</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="n">AI_PASSIVE</span><span class="p">;</span>     <span class="c1">// fill in my IP for me</span>

    <span class="n">getaddrinfo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">MYPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>

    <span class="c1">// make a socket, bind it, and listen on it:</span>

    <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">);</span>
    <span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">);</span>
    <span class="n">listen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">BACKLOG</span><span class="p">);</span>

    <span class="c1">// now accept an incoming connection:</span>

    <span class="n">addr_size</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">their_addr</span><span class="p">;</span>
    <span class="n">new_fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">their_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_size</span><span class="p">);</span>

    <span class="c1">// ready to communicate on socket descriptor new_fd!</span>
    <span class="p">.</span>
    <span class="p">.</span>
    <span class="p">.</span>
</code></pre></div>

<p>Again, note that we will use the socket descriptor <code>new_fd</code> for all <code>send()</code> and <code>recv()</code> calls. If you’re only getting one single connection ever, you can <code>close()</code> the listening <code>sockfd</code> in order to prevent more incoming connections on the same port, if you so desire.</p>

<h2>5.7 <code>send()</code> and <code>recv()</code>—Talk to me, baby!</h2>

<p>These two functions are for communicating over stream sockets or connected datagram sockets. If you want to use regular unconnected datagram sockets, you’ll need to see the section on <a href="system-calls-or-bust.html#sendtorecv" rel="nofollow"><code>sendto()</code> and <code>recvfrom()</code></a>, below.</p>

<p>The <code>send()</code> call:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="nf">send</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span> 
</code></pre></div>

<p><code>sockfd</code> is the socket descriptor you want to send data to (whether it’s the one returned by <code>socket()</code> or the one you got with <code>accept()</code>). <code>msg</code> is a pointer to the data you want to send, and <code>len</code> is the length of that data in bytes. Just set <code>flags</code> to <code>0</code>. (See the <code>send()</code> man page for more information concerning flags.)</p>

<p>Some sample code might be:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">"Beej was here!"</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">bytes_sent</span><span class="p">;</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="n">bytes_sent</span> <span class="o">=</span> <span class="n">send</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span> 
</code></pre></div>

<p><code>send()</code> returns the number of bytes actually sent out—<em>this might be less than the number you told it to send!</em> See, sometimes you tell it to send a whole gob of data and it just can’t handle it. It’ll fire off as much of the data as it can, and trust you to send the rest later. Remember, if the value returned by <code>send()</code> doesn’t match the value in <code>len</code>, it’s up to you to send the rest of the string. The good news is this: if the packet is small (less than 1K or so) it will <em>probably</em> manage to send the whole thing all in one go. Again, <code>-1</code> is returned on error, and <code>errno</code> is set to the error number.</p>

<p>The <code>recv()</code> call is similar in many respects:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="nf">recv</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div>

<p><code>sockfd</code> is the socket descriptor to read from, <code>buf</code> is the buffer to read the information into, <code>len</code> is the maximum length of the buffer, and <code>flags</code> can again be set to <code>0</code>. (See the <code>recv()</code> man page for flag information.)</p>

<p><code>recv()</code> returns the number of bytes actually read into the buffer, or <code>-1</code> on error (with <code>errno</code> set, accordingly).</p>

<p>Wait! <code>recv()</code> can return <code>0</code>. This can mean only one thing: the remote side has closed the connection on you! A return value of <code>0</code> is <code>recv()</code>’s way of letting you know this has occurred.</p>

<p>There, that was easy, wasn’t it? You can now pass data back and forth on stream sockets! Whee! You’re a Unix Network Programmer!</p>

<h2>5.8 <code>sendto()</code> and <code>recvfrom()</code>—Talk to me, DGRAM-style</h2>

<p>“This is all fine and dandy,” I hear you saying, “but where does this leave me with unconnected datagram sockets?” No problemo, amigo. We have just the thing.</p>

<p>Since datagram sockets aren’t connected to a remote host, guess which piece of information we need to give before we send a packet? That’s right! The destination address! Here’s the scoop:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="nf">sendto</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
           <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">tolen</span><span class="p">);</span> 
</code></pre></div>

<p>As you can see, this call is basically the same as the call to <code>send()</code> with the addition of two other pieces of information. <code>to</code> is a pointer to a <code>struct sockaddr</code> (which will probably be another <code>struct sockaddr_in</code> or <code>struct sockaddr_in6</code> or <code>struct sockaddr_storage</code> that you cast at the last minute) which contains the destination IP address and port. <code>tolen</code>, an <code>int</code> deep-down, can simply be set to <code>sizeof *to</code> or <code>sizeof(struct sockaddr_storage)</code>.</p>

<p>To get your hands on the destination address structure, you’ll probably either get it from <code>getaddrinfo()</code>, or from <code>recvfrom()</code>, below, or you’ll fill it out by hand.</p>

<p>Just like with <code>send()</code>, <code>sendto()</code> returns the number of bytes actually sent (which, again, might be less than the number of bytes you told it to send!), or <code>-1</code> on error.</p>

<p>Equally similar are <code>recv()</code> and <code>recvfrom()</code>. The synopsis of <code>recvfrom()</code> is:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="nf">recvfrom</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
             <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fromlen</span><span class="p">);</span> 
</code></pre></div>

<p>Again, this is just like <code>recv()</code> with the addition of a couple fields. <code>from</code> is a pointer to a local <code>struct sockaddr_storage</code> that will be filled with the IP address and port of the originating machine. <code>fromlen</code> is a pointer to a local <code>int</code> that should be initialized to <code>sizeof *from</code> or <code>sizeof(struct sockaddr_storage)</code>. When the function returns, <code>fromlen</code> will contain the length of the address actually stored in <code>from</code>.</p>

<p><code>recvfrom()</code> returns the number of bytes received, or <code>-1</code> on error (with <code>errno</code> set accordingly).</p>

<p>So, here’s a question: why do we use <code>struct sockaddr_storage</code> as the socket type? Why not <code>struct sockaddr_in</code>? Because, you see, we want to not tie ourselves down to IPv4 or IPv6. So we use the generic <code>struct sockaddr_storage</code> which we know will be big enough for either.</p>

<p>(So… here’s another question: why isn’t <code>struct sockaddr</code> itself big enough for any address? We even cast the general-purpose <code>struct sockaddr_storage</code> to the general-purpose <code>struct sockaddr</code>! Seems extraneous and redundant, huh. The answer is, it just isn’t big enough, and I’d guess that changing it at this point would be Problematic. So they made a new one.)</p>

<p>Remember, if you <code>connect()</code> a datagram socket, you can then simply use <code>send()</code> and <code>recv()</code> for all your transactions. The socket itself is still a datagram socket and the packets still use UDP, but the socket interface will automatically add the destination and source information for you.</p>

<h2>5.9 <code>close()</code> and <code>shutdown()</code>—Get outta my face!</h2>

<p>Whew! You’ve been <code>send()</code>ing and <code>recv()</code>ing data all day long, and you’ve had it. You’re ready to close the connection on your socket descriptor. This is easy. You can just use the regular Unix file descriptor <code>close()</code> function:</p>

<div class="highlight"><pre class="highlight c"><code><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span> 
</code></pre></div>

<p>This will prevent any more reads and writes to the socket. Anyone attempting to read or write the socket on the remote end will receive an error.</p>

<p>Just in case you want a little more control over how the socket closes, you can use the <code>shutdown()</code> function. It allows you to cut off communication in a certain direction, or both ways (just like <code>close()</code> does). Synopsis:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="nf">shutdown</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">);</span> 
</code></pre></div>

<p><code>sockfd</code> is the socket file descriptor you want to shutdown, and <code>how</code> is one of the following:</p>

<table><thead>
<tr>
<th style="text-align: center"><code>how</code></th>
<th>Effect</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center"><code>0</code></td>
<td>Further receives are disallowed</td>
</tr>
<tr>
<td style="text-align: center"><code>1</code></td>
<td>Further sends are disallowed</td>
</tr>
<tr>
<td style="text-align: center"><code>2</code></td>
<td>Further sends and receives are disallowed (like <code>close()</code>)</td>
</tr>
</tbody></table>

<p><code>shutdown()</code> returns <code>0</code> on success, and <code>-1</code> on error (with <code>errno</code> set accordingly).</p>

<p>If you deign to use <code>shutdown()</code> on unconnected datagram sockets, it will simply make the socket unavailable for further <code>send()</code> and <code>recv()</code> calls (remember that you can use these if you <code>connect()</code> your datagram socket).</p>

<p>It’s important to note that <code>shutdown()</code> doesn’t actually close the file descriptor—it just changes its usability. To free a socket descriptor, you need to use <code>close()</code>.</p>

<p>Nothing to it.</p>

<p>(Except to remember that if you’re using Windows and Winsock that you should call <code>closesocket()</code> instead of <code>close()</code>.)</p>

<h2>5.10 <code>getpeername()</code>—Who are you?</h2>

<p>This function is so easy.</p>

<p>It’s so easy, I almost didn’t give it its own section. But here it is anyway.</p>

<p>The function <code>getpeername()</code> will tell you who is at the other end of a connected stream socket. The synopsis:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">getpeername</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span> 
</code></pre></div>

<p><code>sockfd</code> is the descriptor of the connected stream socket, <code>addr</code> is a pointer to a <code>struct sockaddr</code> (or a <code>struct sockaddr_in</code>) that will hold the information about the other side of the connection, and <code>addrlen</code> is a pointer to an <code>int</code>, that should be initialized to <code>sizeof *addr</code> or <code>sizeof(struct sockaddr)</code>.</p>

<p>The function returns <code>-1</code> on error and sets <code>errno</code> accordingly.</p>

<p>Once you have their address, you can use <code>inet_ntop()</code>, <code>getnameinfo()</code>, or <code>gethostbyaddr()</code> to print or get more information. No, you can’t get their login name. (Ok, ok. If the other computer is running an ident daemon, this is possible. This, however, is beyond the scope of this document. Check out <a href="https://tools.ietf.org/html/rfc1413" rel="nofollow">RFC 1413</a><a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-network-programming/99-footnotes/" rel="nofollow">²²</a> for more info.)</p>

<h2>5.11 <code>gethostname()</code>—Who am I?</h2>

<p>Even easier than <code>getpeername()</code> is the function <code>gethostname()</code>. It returns the name of the computer that your program is running on. The name can then be used by <code>getaddrinfo()</code>, above, to determine the IP address of your local machine.</p>

<p>What could be more fun? I could think of a few things, but they don’t pertain to socket programming. Anyway, here’s the breakdown:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">gethostname</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span> 
</code></pre></div>

<p>The arguments are simple: <code>hostname</code> is a pointer to an array of chars that will contain the hostname upon the function’s return, and <code>size</code> is the length in bytes of the <code>hostname</code> array.</p>

<p>The function returns <code>0</code> on successful completion, and <code>-1</code> on error, setting <code>errno</code> as usual.</p>

    
    </main>
    <footer id="footer">
      <div class="footer-section"><a href="/license/">CC BY-NC-SA 4.0</a><p>&nbsp;::&nbsp;2019 - 2025 ovelny</p></div>
      <div class="footer-section">「七転び八起き」</div>
    </footer>
  </body>
</html>

