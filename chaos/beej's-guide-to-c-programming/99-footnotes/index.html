<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ovelny - chaos/beej's-guide-to-c-programming/99-footnotes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="ovelny - notes on infosec, penetration testing, programming and others"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" type=text/css href="/assets/css/dead-simple.min.css">
    <link rel="stylesheet" type=text/css href="/assets/css/rouge.min.css">
    <link
      href="/atom.xml"
      rel="alternate"
      title="ovelny"
      type="application/atom+xml"
    />
    <script src="/assets/js/scramble-text.min.js" defer></script>
    <script src="/assets/js/zoom-images.min.js" defer></script>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ovelny"/>
    <meta name="twitter:title" content="ovelny - chaos/beej's-guide-to-c-programming/99-footnotes"/>
    <meta name="twitter:image" content="https://ovelny.sh/assets/images/ovelny-logo.png"/>
    <meta name="twitter:image:alt" content="ovelny logo: 6 white circles grouped together forming a triangle shape, with a black background."/>
  </head>
  <body>

    <header>
      <section>
        <a href="/">
          <img
            class="logo"
            src="/assets/images/ovelny-pfp.png"
            alt="ovelny profile picture: a glitched picture of a three-eyed girl, staring intensely at the viewer."
          />
        </a>
        <h2><a class="ovelny" href="/">ovelny</a></h2>
      </section>
      <nav>
        <a href="/now/">now</a>
        <a href="/chaos/">chaos</a>
        <a href="/phasm/">phasm</a>
        <a href="/support/">support</a>
        <a href="/atom.xml" target="_blank" rel="noopener noreferrer">rss</a>
        <a href="/about/">about</a>
      </nav>
    </header>
    <main>

    
    <ol>
<li><a href="https://www.ioccc.org/" rel="nofollow">https://www.ioccc.org/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Python%5C_(programming_language)" rel="nofollow">https://en.wikipedia.org/wiki/Python\_(programming_language)</a></li>
<li><a href="https://en.wikipedia.org/wiki/JavaScript" rel="nofollow">https://en.wikipedia.org/wiki/JavaScript</a></li>
<li><a href="https://en.wikipedia.org/wiki/Java%5C_(programming_language)" rel="nofollow">https://en.wikipedia.org/wiki/Java\_(programming_language)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rust%5C_(programming_language)" rel="nofollow">https://en.wikipedia.org/wiki/Rust\_(programming_language)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Go%5C_(programming_language)" rel="nofollow">https://en.wikipedia.org/wiki/Go\_(programming_language)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Swift%5C_(programming_language)" rel="nofollow">https://en.wikipedia.org/wiki/Swift\_(programming_language)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Objective-C" rel="nofollow">https://en.wikipedia.org/wiki/Objective-C</a></li>
<li><a href="https://beej.us/guide/bgclr/" rel="nofollow">https://beej.us/guide/bgclr/</a></li>
<li><a href="https://en.wikipedia.org/wiki/ANSI_C" rel="nofollow">https://en.wikipedia.org/wiki/ANSI_C</a></li>
<li><a href="https://en.wikipedia.org/wiki/POSIX" rel="nofollow">https://en.wikipedia.org/wiki/POSIX</a></li>
<li><a href="https://visualstudio.microsoft.com/vs/community/" rel="nofollow">https://visualstudio.microsoft.com/vs/community/</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" rel="nofollow">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a></li>
<li><a href="https://developer.apple.com/xcode/" rel="nofollow">https://developer.apple.com/xcode/</a></li>
<li><a href="https://beej.us/guide/bgc/" rel="nofollow">https://beej.us/guide/bgc/</a></li>
<li><a href="https://en.cppreference.com/" rel="nofollow">https://en.cppreference.com/</a></li>
<li><a href="https://groups.google.com/g/comp.lang.c" rel="nofollow">https://groups.google.com/g/comp.lang.c</a></li>
<li><a href="https://www.reddit.com/r/C_Programming/" rel="nofollow">https://www.reddit.com/r/C_Programming/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Assembly_language" rel="nofollow">https://en.wikipedia.org/wiki/Assembly_language</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bare_machine" rel="nofollow">https://en.wikipedia.org/wiki/Bare_machine</a></li>
<li><a href="https://en.wikipedia.org/wiki/Operating_system" rel="nofollow">https://en.wikipedia.org/wiki/Operating_system</a></li>
<li><a href="https://en.wikipedia.org/wiki/Embedded_system" rel="nofollow">https://en.wikipedia.org/wiki/Embedded_system</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rust%5C_(programming_language)" rel="nofollow">https://en.wikipedia.org/wiki/Rust\_(programming_language)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Grok" rel="nofollow">https://en.wikipedia.org/wiki/Grok</a></li>
<li>I know someone will fight me on that, but it’s gotta be at least in the top three, right?</li>
<li>Well, technically there are more than two, but hey, let’s pretend there are two—ignorance is bliss, right?</li>
<li><a href="https://en.wikipedia.org/wiki/Assembly_language" rel="nofollow">https://en.wikipedia.org/wiki/Assembly_language</a></li>
<li><a href="https://en.wikipedia.org/wiki/Machine_code" rel="nofollow">https://en.wikipedia.org/wiki/Machine_code</a></li>
<li>Technically, it contains preprocessor directives and function prototypes (more on that later) for common input and output needs.</li>
<li><a href="https://en.wikipedia.org/wiki/Unix" rel="nofollow">https://en.wikipedia.org/wiki/Unix</a></li>
<li>If you don’t give it an output filename, it will export to a file called <code>a.out</code> by default—this filename has its roots deep in Unix history.</li>
<li><a href="https://formulae.brew.sh/formula/gcc" rel="nofollow">https://formulae.brew.sh/formula/gcc</a></li>
<li>A “byte” is typically an 8-bit binary number. Think of it as an integer that can only hold the values from 0 to 255, inclusive. Technically, C allows bytes to be any number of bits and if you want to unambiguously refer to an 8-bit number, you should use the term <em>octet</em>. But programmers are going assume you mean 8-bits when you say “byte” unless you specify otherwise.</li>
<li>I’m seriously oversimplifying how modern memory works, here. But the mental model works, so please forgive me.</li>
<li>I’m lying here a little. Technically <code>3.14159</code> is of type <code>double</code>, but we’re not there yet and I want you to associate <code>float</code> with “Floating Point”, and C will happily coerce that type into a <code>float</code>. In short, don’t worry about it until later.</li>
<li>Read this as “pointer to a char” or “char pointer”. “Char” for character. Though I can’t find a study, it seems anecdotally most people pronounce this as “char”, a minority say “car”, and a handful say “care”. We’ll talk more about pointers later.</li>
<li>Colloquially, we say they have “random” values, but they aren’t truly—or even pseudo-truly—random numbers.</li>
<li>This isn’t strictly 100% true. When we get to learning about static storage duration, you’ll find the some variables are initialized to zero automatically. But the safe thing to do is always initialize them.</li>
<li>The <code>_t</code> is short for <code>type</code>.</li>
<li>Except for with variable length arrays—but that’s a story for another time.</li>
<li><a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-srand" rel="nofollow">https://beej.us/guide/bgclr/html/split/stdlib.html#man-srand</a></li>
<li>This was considered such a hazard that the designers of the Go Programming Language made <code>break</code> the default; you have to explicitly use Go’s <code>fallthrough</code> statement if you want to fall into the next case.</li>
<li>Never say “never”.</li>
<li>Typically. I’m sure there are exceptions out there in the dark corridors of computing history.</li>
<li>A byte is a number made up of no more than 8 binary digits, or <em>bits</em> for short. This means in decimal digits just like grandma used to use, it can hold an unsigned number between 0 and 255, inclusive.</li>
<li>The order that bytes come in is referred to as the <em>endianness</em> of the number. The usual suspects are <em>big-endian</em> (with the most significant byte first) and <em>little-endian</em> (with the most-significant byte last), or, uncommonly now, <em>mixed-endian</em> (with the most-significant bytes somewhere else).</li>
<li>That is, base 16 with digits 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F.</li>
<li>That’s not all! It’s used in <code>/*comments*/</code> and multiplication and in function prototypes with variable length arrays! It’s all the same <code>*</code>, but the context gives it different meaning.</li>
<li><a href="https://en.wikipedia.org/wiki/Null_pointer#History" rel="nofollow">https://en.wikipedia.org/wiki/Null_pointer#History</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sentinel_value" rel="nofollow">https://en.wikipedia.org/wiki/Sentinel_value</a></li>
<li>The pointer type variables are <code>a</code>, <code>d</code>, <code>f</code>, and <code>i</code>, because those are the ones with <code>*</code> in front of them.</li>
<li>These days, anyway.</li>
<li>Again, not really, but variable-length arrays—of which I’m not really a fan—are a story for another time.</li>
<li>Since arrays are just pointers to the first element of the array under the hood, there’s no additional information recording the length.</li>
<li>Because when you pass an array to a function, you’re actually just passing a pointer to the first element of that array, not the “entire” array.</li>
<li>In the good old MS-DOS days before memory protection was a thing, I was writing some particularly abusive C code that deliberately engaged in all kinds of undefined behavior. But I knew what I was doing, and things were working pretty well. Until I made a misstep that caused a lockup and, as I found upon reboot, nuked all my BIOS settings. That was fun. (Shout-out to @man for those fun times.)</li>
<li>There are a lot of things that cause undefined behavior, not just out-of-bounds array accesses. This is what makes the C language so <em>exciting</em>.</li>
<li><a href="https://en.wikipedia.org/wiki/Row-%5C_and_column-major_order" rel="nofollow">https://en.wikipedia.org/wiki/Row-\_and_column-major_order</a></li>
<li>This is technically incorrect, as a pointer to an array and a pointer to the first element of an array have different types. But we can burn that bridge when we get to it.</li>
<li>C11 §6.7.6.2¶1 requires it be greater than zero. But you might see code out there with arrays declared of zero length at the end of <code>struct</code>s and GCC is particularly lenient about it unless you compile with <code>-pedantic</code>. This zero-length array was a hackish mechanism for making variable-length structures. Unfortunately, it’s technically undefined behavior to access such an array even though it basically worked everywhere. C99 codified a well-defined replacement for it called <em>flexible array members</em>, which we’ll chat about later.</li>
<li>This is also equivalent: <code>void print_2D_array(int (*a)[3])</code>, but that’s more than I want to get into right now.</li>
<li>Though it is true that C doesn’t track the length of strings.</li>
<li>If you’re using the basic character set or an 8-bit character set, you’re used to one character being one byte. This isn’t true in all character encodings, though.</li>
<li>This is different than the <code>NULL</code> pointer, and I’ll abbreviate it <code>NUL</code> when talking about the character versus <code>NULL</code> for the pointer.</li>
<li>Later we’ll learn a neater way to do it with pointer arithmetic.</li>
<li>There’s a safer function called <code>strncpy()</code> that you should probably use instead, but we’ll get to that later.</li>
<li>Although in C individual items in memory like <code>int</code>s are referred to as “objects”, they’re not objects in an object-oriented programming sense.</li>
<li>The Saturn was a popular brand of economy car in the United States until it was put out of business by the 2008 crash, sadly so to us fans.</li>
<li>A pointer is likely 8 bytes on a 64-bit system.</li>
<li>A <em>deep copy</em> follows pointer in the <code>struct</code> and copies the data they point to, as well. A <em>shallow copy</em> just copies the pointers, but not the things they point to. C doesn’t come with any built-in deep copy functionality.</li>
<li><a href="https://beej.us/guide/bgclr/html/split/stringref.html#man-strcmp" rel="nofollow">https://beej.us/guide/bgclr/html/split/stringref.html#man-strcmp</a></li>
<li><a href="https://beej.us/guide/bgclr/html/split/stringref.html#man-memset" rel="nofollow">https://beej.us/guide/bgclr/html/split/stringref.html#man-memset</a></li>
<li><a href="https://stackoverflow.com/questions/141720/how-do-you-compare-structs-for-equality-in-c" rel="nofollow">https://stackoverflow.com/questions/141720/how-do-you-compare-structs-for-equality-in-c</a></li>
<li>We used to have three different newlines in broad effect: Carriage Return (CR, used on old Macs), Linefeed (LF, used on Unix systems), and Carriage Return/Linefeed (CRLF, used on Windows systems). Thankfully the introduction of OS X, being Unix-based, reduced this number to two.</li>
<li>If the buffer’s not big enough to read in an entire line, it’ll just stop reading mid-line, and the next call to <code>fgets()</code> will continue reading the rest of the line.</li>
<li>Normally the second program would read all the bytes at once, and <em>then</em> print them out in a loop. That would be more efficient. But we’re going for demo value, here.</li>
<li><a href="https://en.wikipedia.org/wiki/Hex_dump" rel="nofollow">https://en.wikipedia.org/wiki/Hex_dump</a></li>
<li><a href="https://en.wikipedia.org/wiki/Endianess" rel="nofollow">https://en.wikipedia.org/wiki/Endianess</a></li>
<li>And this is why I used individual bytes in my <code>fwrite()</code> and <code>fread()</code> examples, above, shrewdly.</li>
<li><a href="https://en.wikipedia.org/wiki/Protocol_buffers" rel="nofollow">https://en.wikipedia.org/wiki/Protocol_buffers</a></li>
<li>We’ll talk more about these later.</li>
<li>Recall that the <code>sizeof</code> operator tells you the size in bytes of an object in memory.</li>
<li>Or string, which is really an array of <code>char</code>s. Somewhat peculiarly, you can also have a pointer that references <em>one past</em> the end of the array without a problem and still do math on it. You just can’t dereference it when it’s out there.</li>
<li><a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-qsort" rel="nofollow">https://beej.us/guide/bgclr/html/split/stdlib.html#man-qsort</a></li>
<li><a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-bsearch" rel="nofollow">https://beej.us/guide/bgclr/html/split/stdlib.html#man-bsearch</a></li>
<li>Because remember that array notation is just a dereference and some pointer math, and you can’t dereference a <code>void*</code>!</li>
<li>You can also <em>cast</em> the <code>void*</code> to another type, but we haven’t gotten to casts yet.</li>
<li>Or until the program exits, in which case all the memory allocated by it is freed. Asterisk: some systems allow you to allocate memory that persists after a program exits, but it’s system dependent, out of scope for this guide, and you’ll certainly never do it on accident.</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/summary.htm#dr_460" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg14/www/docs/summary.htm#dr_460</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bit_bucket" rel="nofollow">https://en.wikipedia.org/wiki/Bit_bucket</a></li>
<li>“Bit” is short for <em>binary digit</em>. Binary is just another way of representing numbers. Instead of digits 0-9 like we’re used to, it’s digits 0-1.</li>
<li><a href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="nofollow">https://en.wikipedia.org/wiki/Two%27s_complement</a></li>
<li>The industry term for a sequence of exactly, indisputably 8 bits is an <em>octet</em>.</li>
<li>In general, f you have an \(n\) bit two’s complement number, the signed range is \(-2<sup>{n-1}\)</sup> to \(2<sup>{n-1}-1\).</sup> And the unsigned range is \(0\) to \(2<sup>n-1\).</sup></li>
<li><a href="https://en.wikipedia.org/wiki/ASCII" rel="nofollow">https://en.wikipedia.org/wiki/ASCII</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_information_system_character_sets" rel="nofollow">https://en.wikipedia.org/wiki/List_of_information_system_character_sets</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unicode" rel="nofollow">https://en.wikipedia.org/wiki/Unicode</a></li>
<li>Depends on if a <code>char</code> defaults to <code>signed char</code> or <code>unsigned char</code></li>
<li><a href="https://en.wikipedia.org/wiki/Signed_number_representations#Signed_magnitude_representation" rel="nofollow">https://en.wikipedia.org/wiki/Signed_number_representations#Signed_magnitude_representation</a></li>
<li>My <code>char</code> is signed.</li>
<li><a href="https://en.wikipedia.org/wiki/IEEE_754" rel="nofollow">https://en.wikipedia.org/wiki/IEEE_754</a></li>
<li>This program runs as its comments indicate on a system with <code>FLT_DIG</code> of <code>6</code> that uses IEEE-754 base-2 floating point numbers. Otherwise, you might get different output.</li>
<li>It’s really surprising to me that C doesn’t have this in the spec yet. In the C99 Rationale document, they write, “A proposal to add binary constants was rejected due to lack of precedent and insufficient utility.” Which seems kind of silly in light of some of the other features they kitchen-sinked in there! I’ll bet one of the next releases has it.</li>
<li><a href="https://en.wikipedia.org/wiki/Scientific_notation" rel="nofollow">https://en.wikipedia.org/wiki/Scientific_notation</a></li>
<li>They’re the same except <code>snprintf()</code> allows you to specify a maximum number of bytes to output, preventing the overrunning of the end of your string. So it’s safer.</li>
<li><a href="https://en.wikipedia.org/wiki/ASCII" rel="nofollow">https://en.wikipedia.org/wiki/ASCII</a></li>
<li>We have to pass a pointer to <code>badchar</code> to <code>strtoul()</code> or it won’t be able to modify it in any way we can see, analogous to why you have to pass a pointer to an <code>int</code> to a function if you want that function to be able to change that value of that <code>int</code>.</li>
<li>Each character has a value associated with it for any given character encoding scheme.</li>
<li>In practice, what’s probably happening on your implementation is that the high-order bits are just being dropped from the result, so a 16-bit number <code>0x1234</code> being converted to an 8-bit number ends up as <code>0x0034</code>, or just <code>0x34</code>.</li>
<li>Again, in practice, what will likely happen on your system is that the bit pattern for the original will be truncated and then just used to represent the signed number, two’s complement. For example, my system takes an <code>unsigned char</code> of <code>192</code> and converts it to <code>signed char</code> <code>-64</code>. In two’s complement, the bit pattern for both these numbers is binary <code>11000000</code>.</li>
<li>Not really—it’s just discarded regularly.</li>
<li>Functions with a variable number of arguments.</li>
<li>This is rarely done because the compiler will complain and having a prototype is the <em>Right Thing</em> to do. I think this still works for historic reasons, before prototypes were a thing.</li>
<li><a href="https://beej.us/guide/bgclr/html/split/ctype.html" rel="nofollow">https://beej.us/guide/bgclr/html/split/ctype.html</a></li>
<li><a href="https://gustedt.wordpress.com/2010/08/17/a-common-misconsception-the-register-keyword/" rel="nofollow">https://gustedt.wordpress.com/2010/08/17/a-common-misconsception-the-register-keyword/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Processor_register" rel="nofollow">https://en.wikipedia.org/wiki/Processor_register</a></li>
<li><a href="https://en.wikipedia.org/wiki/Boids" rel="nofollow">https://en.wikipedia.org/wiki/Boids</a></li>
<li>Historially, MS-DOS and Windows programs would do this differently than Unix. In Unix, the shell would <em>expand</em> the wildcard into all matching files before your program saw it, whereas the Microsoft variants would pass the wildcard expression into the program to deal with. In any case, there are arguments that get passed into the program.</li>
<li>Since they’re just regular parameter names, you don’t actually have to call them <code>argc</code> and <code>argv</code>. But it’s so very idiomatic to use those names, if you get creative, other C programmers will look at you with a suspicious eye, indeed!</li>
<li><code>ps</code>, Process Status, is a Unix command to see what processes are running at the moment.</li>
<li><a href="https://en.wikipedia.org/wiki/Inception" rel="nofollow">https://en.wikipedia.org/wiki/Inception</a></li>
<li><a href="https://en.wikipedia.org/wiki/Shell%5C_(computing)" rel="nofollow">https://en.wikipedia.org/wiki/Shell\_(computing)</a></li>
<li>In Windows <code>cmd.exe</code>, type <code>echo %errorlevel%</code>. In PowerShell, type <code>$LastExitCode</code>.</li>
<li>If you need a numeric value, convert the string with something like <code>atoi()</code> or <code>strtol()</code>.</li>
<li>In Windows CMD.EXE, use <code>set FROTZ=value</code>. In PowerShell, use <code>$Env:FROTZ=value</code>.</li>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html" rel="nofollow">https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html</a></li>
<li>You can’t always just wrap the code in <code>/*</code> <code>*/</code> comments because those won’t nest.</li>
<li>This isn’t really a macro—it’s technically an identifier. But it’s the only predefined identifier and it feels very macro-like, so I’m including it here. Like a rebel.</li>
<li>A hosted implementation basically means you’re running the full C standard, probably on an operating system of some kind. Which you probably are. If you’re running on bare metal in some kind of embedded system, you’re probably on a <em>standalone implementation</em>.</li>
<li>OK, I know that was a cop-out answer. Basically there’s an optional extension compilers can implement wherein they agree to limit certain types of undefined behavior so that the C code is more amenable to static code analysis. It is unlikely you’ll need to use this.</li>
<li><em>Breakin’ the law… breakin’ the law…</em></li>
<li><a href="https://www.openmp.org/" rel="nofollow">https://www.openmp.org/</a></li>
<li>Technically we say that it has an <em>incomplete type</em>.</li>
<li>Though some compilers have options to force this to occur—search for <code>__attribute__((packed))</code> to see how to do this with GCC.</li>
<li><code>super</code> isn’t a keyword, incidentally. I’m just stealing some OOP terminology.</li>
<li>Assuming 8-bit <code>char</code>s, i.e. <code>CHAR_BIT == 8</code>.</li>
<li><a href="https://en.wikipedia.org/wiki/Type_punning" rel="nofollow">https://en.wikipedia.org/wiki/Type_punning</a></li>
<li>I just made up that number, but it’s probably not far off</li>
<li>There’s some devil in the details with values that are stored in registers only, but we can safely ignore that for our purposes here. Also the C spec makes no stance on these “register” things beyond the <code>register</code> keyword, the description for which doesn’t mention registers.</li>
<li>You’re very likely to get different numbers on yours.</li>
<li>There is absolutely nothing in the spec that says this will always work this way, but it happens to work this way on my system.</li>
<li>Even if <code>E</code> is <code>NULL</code>, it turns out, weirdly.</li>
<li><a href="https://beej.us/guide/bgclr/html/split/stringref.html#man-memcpy" rel="nofollow">https://beej.us/guide/bgclr/html/split/stringref.html#man-memcpy</a></li>
<li>Your C compiler is not required to add padding bytes, and the values of any padding bytes that are added are indeterminate.</li>
<li>This will vary depending on the architecture, but my system is <em>little endian</em>, which means the least-significant byte of the number is stored first. <em>Big endian</em> systems will have the <code>12</code> first and the <code>78</code> last. But the spec doesn’t dictate anything about this representation.</li>
<li>It’s an optional feature, so it might not be there—but it probably is.</li>
<li>I’m printing out the 16-bit values reversed since I’m on a little-endian machine and it makes it easier to read here.</li>
<li>Assuming they point to the same array object.</li>
<li>The Go Programming Language drew its type declaration syntax inspiration from the opposite of what C does.</li>
<li>Not that other languages don’t do this—they do. It is interesting how many modern languages use the same operators for bitwise that C does.</li>
<li><a href="https://en.wikipedia.org/wiki/Bitwise_operation" rel="nofollow">https://en.wikipedia.org/wiki/Bitwise_operation</a></li>
<li>That is, us lowly developers aren’t supposed to know what’s in there or what it means. The spec doesn’t dictate what it is in detail.</li>
<li>Honestly, it would be possible to remove that limitation from the language, but the idea is that the macros <code>va_start()</code>, <code>va_arg()</code>, and <code>va_end()</code> should be able to be written in C. And to make that happen, we need some way to initialize a pointer to the location of the first parameter. And to do that, we need the <em>name</em> of the first parameter. It would require a language extension to make this possible, and so far the committee hasn’t found a rationale for doing so.</li>
<li>“This planet has—or rather had—a problem, which was this: most of the people living on it were unhappy for pretty much of the time. Many solutions were suggested for this problem, but most of these were largely concerned with the movement of small green pieces of paper, which was odd because on the whole it wasn’t the small green pieces of paper that were unhappy.” —The Hitchhiker’s Guide to the Galaxy, Douglas Adams</li>
<li>Remember that <code>char</code> is just a byte-sized integer.</li>
<li>Except for <code>isdigit()</code> and <code>isxdigit()</code>.</li>
<li>For example, we could store the code point in a big-endian 32-bit integer. Straightforward! We just invented an encoding! Actually not; that’s what UTF-32BE encoding is. Oh well—back to the grind!</li>
<li>Ish. Technically, it’s variable width—there’s a way to represent code points higher than \(2<sup>{16}\)</sup> by putting two UTF-16 characters together.</li>
<li>There’s a special character called the <em>Byte Order Mark</em> (BOM), code point 0xFEFF, that can optionally precede the data stream and indicate the endianess. It is not required, however.</li>
<li>Again, this is only true in UTF-16 for characters that fit in two bytes.</li>
<li><a href="https://en.wikipedia.org/wiki/UTF-8" rel="nofollow">https://en.wikipedia.org/wiki/UTF-8</a></li>
<li><a href="https://www.youtube.com/watch?v=MijmeoH9LT4" rel="nofollow">https://www.youtube.com/watch?v=MijmeoH9LT4</a></li>
<li>Presumably the compiler makes the best effort to translate the code point to whatever the output encoding is, but I can’t find any guarantees in the spec.</li>
<li>With a format specifier like <code>&quot;%.12s&quot;</code>, for example.</li>
<li><code>wcscoll()</code> is the same as <code>wcsxfrm()</code> followed by <code>wcscmp()</code>.</li>
<li>Ish—things get funky with multi-<code>char16_t</code> UTF-16 encodings.</li>
<li><a href="https://en.wikipedia.org/wiki/Iconv" rel="nofollow">https://en.wikipedia.org/wiki/Iconv</a></li>
<li><a href="http://site.icu-project.org/" rel="nofollow">http://site.icu-project.org/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Core_dump" rel="nofollow">https://en.wikipedia.org/wiki/Core_dump</a></li>
<li>Apparently it doesn’t do Unix-style signals at all deep down, and they’re simulated for console apps.</li>
<li>Confusingly, <code>sig_atomic_t</code> predates the lock-free atomics and is not the same thing.</li>
<li>If <code>sig_action_t</code> is signed, the range will be at least <code>-127</code> to <code>127</code>. If unsigned, at least <code>0</code> to <code>255</code>.</li>
<li>This is due to how VLAs are typically allocated on the stack, whereas <code>static</code> variables are on the heap. And the whole idea with VLAs is they’ll be automatically dellocated when the stack frame is popped at the end of the function.</li>
<li><a href="https://en.wikipedia.org/wiki/Goto#Criticism" rel="nofollow">https://en.wikipedia.org/wiki/Goto#Criticism</a></li>
<li>I’d like to point out that using <code>goto</code> in all these cases is avoidable. You can use variables and loops instead. It’s just that some people think <code>goto</code> produces the <em>best</em> code in those circumstances.</li>
<li><a href="https://en.wikipedia.org/wiki/Tail_call" rel="nofollow">https://en.wikipedia.org/wiki/Tail_call</a></li>
<li>Which isn’t quite the same, since it’s an array, not a pointer to an <code>int</code>.</li>
<li>A variable used here <em>is</em> an expression.</li>
<li>Both “stack pointer” and “program counter” are related to the underlying architecture and C implementation, and are not part of the spec.</li>
<li>The rationale here is that the program might store a value temporarily in a <em>CPU register</em> while it’s doing work on it. In that timeframe, the register holds the correct value, and the value on the stack might be out of date. Then later the register values would get overwritten and the changes to the variable lost.</li>
<li>That is, remain allocated until the program ends with no way to free it.</li>
<li>This works because in C, pointers are the same size regardless of the type of data they point to. So the compiler doesn’t need to know the size of the <code>struct node</code> at this point; it just needs to know the size of a pointer.</li>
<li><a href="https://en.wikipedia.org/wiki/Complex_number" rel="nofollow">https://en.wikipedia.org/wiki/Complex_number</a></li>
<li>This was a harder one to research, and I’ll take any more information anyone can give me. <code>I</code> could be defined as <code>_Complex_I</code> or <code>_Imaginary_I</code>, if the latter exists. <code>_Imaginary_I</code> will handle signed zeros, but <code>_Complex_I</code> <em>might</em> not. This has implications with branch cuts and other complex-numbery-mathy things. Maybe. Can you tell I’m really getting out of my element here? In any case, the <code>CMPLX()</code> macros behave as if <code>I</code> were defined as <code>_Imaginary_I</code>, with signed zeros, even if <code>_Imaginary_I</code> doesn’t exist on the system.</li>
<li>The simplicity of this statement doesn’t do justice to the incredible amount of work that goes into simply understanding how floating point actually functions. <a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/" rel="nofollow">https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/</a></li>
<li>This is the only one that doesn’t begin with an extra leading <code>c</code>, strangely.</li>
<li>Some architectures have different sized data that the CPU and RAM can operate with at a faster rate than others. In those cases, if you need the fastest 8-bit number, it might give you have a 16- or 32-bit type instead because that’s just faster. So with this, you won’t know how big the type is, but it will be least as big as you say.</li>
<li>Namely, the system has 8, 16, 32, or 64 bit integers with no padding that use two’s complement representation, in which case the <code>intN_t</code> variant for that particular number of bits <em>must</em> be defined.</li>
<li>On Earth, anyway. Who know what crazy systems they use <em>out there</em>…</li>
<li>OK, don’t murder me! GMT is technically a time zone while UTC is a global time system. Also some countries might adjust GMT for daylight saving time, whereas UTC is never adjusted for daylight saving time.</li>
<li>Admittedly, there are more than two.</li>
<li><a href="https://en.wikipedia.org/wiki/Unix_time" rel="nofollow">https://en.wikipedia.org/wiki/Unix_time</a></li>
<li><a href="https://beej.us/guide/bgclr/html/split/time.html#man-strftime" rel="nofollow">https://beej.us/guide/bgclr/html/split/time.html#man-strftime</a></li>
<li>You will on POSIX, where <code>time_t</code> is definitely an integer. Unfortunately the entire world isn’t POSIX, so there we are.</li>
<li><a href="https://en.wikipedia.org/wiki/POSIX_Threads" rel="nofollow">https://en.wikipedia.org/wiki/POSIX_Threads</a></li>
<li>I’m more a fan of shared-nothing, myself, and my skills with classic multithreading constructs are rusty, to say the least.</li>
<li>Yes, <code>pthreads</code> with a “<code>p</code>”. It’s short for POSIX threads, a library that C11 borrowed liberally from for its threads implementation.</li>
<li>Per §7.1.4¶5.</li>
<li>Unless you <code>thrd_detach()</code>. More on this later.</li>
<li>Though I don’t think they have to be. It’s just that the threads don’t seem to get rescheduled until some system call like might happen with a <code>printf()</code>… which is why I have the <code>printf()</code> in there.</li>
<li>Short for “mutual exclusion”, AKA a “lock” on a section of code that only one thread is permitted to execute.</li>
<li>That is, your process will go to sleep.</li>
<li>You might have expected it to be “time from now”, but you’d just like to think that, wouldn’t you!</li>
<li>And that’s why they’re called <em>condition variables</em>!</li>
<li>I’m not saying it’s aliens… but it’s aliens. OK, really more likely another thread might have been woken up and gotten to the work first.</li>
<li>Survival of the fittest! Right? I admit it’s actually nothing like that.</li>
<li>The <code>__STDC_VERSION__</code> macro didn’t exist in early C89, so if you’re worried about that, check it with <code>#ifdef</code>.</li>
<li>The reason for this is when optimized, my compiler has put the value of <code>x</code> in a register to make the <code>while</code> loop fast. But the register has no way of knowing that the variable was updated in another thread, so it never sees the <code>3490</code>. This isn’t really related to the <em>all-or-nothing</em> part of atomicity, but is more related to the synchronization aspects in the next section.</li>
<li>Until I say otherwise, I’m speaking generally about <em>sequentially consistent</em> operations. More on what that means soon.</li>
<li>Sanest from a programmer perspective.</li>
<li>Apparently C++23 is adding this as a macro.</li>
<li>The spec notes that they might differ in size, representation, and alignment.</li>
<li>I just pulled that example out of nowhere. Maybe it doesn’t matter on Intel/AMD, but it could matter somewhere, dangit!</li>
<li>C++ elaborates that if the signal is the result of a call to <code>raise()</code>, it is sequenced <em>after</em> the <code>raise()</code>.</li>
<li><a href="https://en.wikipedia.org/wiki/Test-and-set" rel="nofollow">https://en.wikipedia.org/wiki/Test-and-set</a></li>
<li>Because consume is all about the operations that are dependent on the value of the acquired atomic variable, and there is no atomic variable with a fence.</li>
<li><a href="https://www.youtube.com/watch?v=A8eCGOqgvH4" rel="nofollow">https://www.youtube.com/watch?v=A8eCGOqgvH4</a></li>
<li><a href="https://www.youtube.com/watch?v=KeLBd2EJLOU" rel="nofollow">https://www.youtube.com/watch?v=KeLBd2EJLOU</a></li>
<li><a href="https://preshing.com/archives/" rel="nofollow">https://preshing.com/archives/</a></li>
<li><a href="https://preshing.com/20120612/an-introduction-to-lock-free-programming/" rel="nofollow">https://preshing.com/20120612/an-introduction-to-lock-free-programming/</a></li>
<li><a href="https://preshing.com/20120913/acquire-and-release-semantics/" rel="nofollow">https://preshing.com/20120913/acquire-and-release-semantics/</a></li>
<li><a href="https://preshing.com/20130702/the-happens-before-relation/" rel="nofollow">https://preshing.com/20130702/the-happens-before-relation/</a></li>
<li><a href="https://preshing.com/20130823/the-synchronizes-with-relation/" rel="nofollow">https://preshing.com/20130823/the-synchronizes-with-relation/</a></li>
<li><a href="https://preshing.com/20140709/the-purpose-of-memory_order_consume-in-cpp11/" rel="nofollow">https://preshing.com/20140709/the-purpose-of-memory_order_consume-in-cpp11/</a></li>
<li><a href="https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/" rel="nofollow">https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/</a></li>
<li><a href="https://en.cppreference.com/w/c/atomic/memory_order" rel="nofollow">https://en.cppreference.com/w/c/atomic/memory_order</a></li>
<li><a href="https://en.cppreference.com/w/c/language/atomic" rel="nofollow">https://en.cppreference.com/w/c/language/atomic</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming" rel="nofollow">https://docs.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming</a></li>
<li><a href="https://www.reddit.com/r/C_Programming/" rel="nofollow">https://www.reddit.com/r/C_Programming/</a></li>
<li>You can do this with <code>-O</code> on the command line.</li>
<li><a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-exit" rel="nofollow">https://beej.us/guide/bgclr/html/split/stdlib.html#man-exit</a></li>
<li><a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-abort" rel="nofollow">https://beej.us/guide/bgclr/html/split/stdlib.html#man-abort</a></li>
<li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment" rel="nofollow">https://en.wikipedia.org/wiki/Data_structure_alignment</a></li>
</ol>

    
    </main>
    <footer id="footer">
      <div class="footer-section"><a href="/license/">CC BY-NC-SA 4.0</a><p>&nbsp;::&nbsp;2019 - 2025 ovelny</p></div>
      <div class="footer-section">「七転び八起き」</div>
    </footer>
  </body>
</html>

