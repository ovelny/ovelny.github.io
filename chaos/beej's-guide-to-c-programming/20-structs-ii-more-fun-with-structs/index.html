<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ovelny - chaos/beej's-guide-to-c-programming/20-structs-ii-more-fun-with-structs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="ovelny - notes on infosec, penetration testing, programming and others"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" type=text/css href="/assets/css/dead-simple.min.css">
    <link rel="stylesheet" type=text/css href="/assets/css/rouge.min.css">
    <link
      href="/atom.xml"
      rel="alternate"
      title="ovelny"
      type="application/atom+xml"
    />
    <script src="/assets/js/scramble-text.min.js" defer></script>
    <script src="/assets/js/zoom-images.min.js" defer></script>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ovelny"/>
    <meta name="twitter:title" content="ovelny - chaos/beej's-guide-to-c-programming/20-structs-ii-more-fun-with-structs"/>
    <meta name="twitter:image" content="https://ovelny.sh/assets/images/ovelny-logo.png"/>
    <meta name="twitter:image:alt" content="ovelny logo: 6 white circles grouped together forming a triangle shape, with a black background."/>
  </head>
  <body>

    <header>
      <section>
        <a href="/">
          <img
            class="logo"
            src="/assets/images/ovelny-pfp.png"
            alt="ovelny profile picture: a glitched picture of a three-eyed girl, staring intensely at the viewer."
          />
        </a>
        <h2><a class="ovelny" href="/">ovelny</a></h2>
      </section>
      <nav>
        <a href="/">home</a>
        <a href="/chaos/">chaos</a>
        <a href="/phasm/">phasm</a>
        <a href="/support/">support</a>
        <a href="/atom.xml" target="_blank" rel="noopener noreferrer">rss</a>
        <a href="/about/">about</a>
      </nav>
    </header>
    <main>

    
    <h1>20 <code>struct</code>s II: More Fun with <code>struct</code>s</h1>

<p>Turns out there’s a lot more you can do with <code>struct</code>s than we’ve talked about, but it’s just a big pile of miscellaneous things. So we’ll throw them in this chapter.</p>

<p>If you’re good with <code>struct</code> basics, you can round out your knowledge here.</p>

<h2>20.1 Initializers of Nested <code>struct</code>s and Arrays</h2>

<p>Remember how you could <a href="structs.html#struct-initializers" rel="nofollow">initialize structure members along these lines</a>?</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">foo</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{.</span><span class="n">a</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">.</span><span class="mi">14</span><span class="p">};</span>
</code></pre></div>

<p>Turns out we have more power in these initializers than we’d originally shared. Exciting!</p>

<p>For one thing, if you have a nested substructure like the following, you can initialize members of that substructure by following the variable names down the line:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">foo</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{.</span><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">c</span><span class="o">=</span><span class="mi">12</span><span class="p">};</span>
</code></pre></div>

<p>Let’s look at an example:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">cabin_information</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">window_count</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">o2level</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">spaceship</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">manufacturer</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">cabin_information</span> <span class="n">ci</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">spaceship</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">manufacturer</span><span class="o">=</span><span class="s">"General Products"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">ci</span><span class="p">.</span><span class="n">window_count</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>   <span class="c1">// &lt;-- NESTED INITIALIZER!</span>
        <span class="p">.</span><span class="n">ci</span><span class="p">.</span><span class="n">o2level</span> <span class="o">=</span> <span class="mi">21</span>
    <span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%s: %d seats, %d%% oxygen</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">s</span><span class="p">.</span><span class="n">manufacturer</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">ci</span><span class="p">.</span><span class="n">window_count</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">ci</span><span class="p">.</span><span class="n">o2level</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Check out lines 16-17! That’s where we’re initializing members of the <code>struct cabin_information</code> in the definition of <code>s</code>, our <code>struct spaceship</code>.</p>

<p>And here is another option for that same initializer—this time we’ll do something more standard-looking, but either approach works:</p>

<div class="highlight"><pre class="highlight c"><code>    <span class="k">struct</span> <span class="n">spaceship</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">manufacturer</span><span class="o">=</span><span class="s">"General Products"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">ci</span><span class="o">=</span><span class="p">{</span>
            <span class="p">.</span><span class="n">window_count</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
            <span class="p">.</span><span class="n">o2level</span> <span class="o">=</span> <span class="mi">21</span>
        <span class="p">}</span>
    <span class="p">};</span>
</code></pre></div>

<p>Now, as if the above information isn’t spectacular enough, we can also mix in array initializers in there, too.</p>

<p>Let’s change this up to get an array of passenger information in there, and we can check out how the initializers work in there, too.</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">passenger</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">covid_vaccinated</span><span class="p">;</span> <span class="c1">// Boolean</span>
<span class="p">};</span>

<span class="cp">#define MAX_PASSENGERS 8
</span>
<span class="k">struct</span> <span class="n">spaceship</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">manufacturer</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">passenger</span> <span class="n">passenger</span><span class="p">[</span><span class="n">MAX_PASSENGERS</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">spaceship</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">manufacturer</span><span class="o">=</span><span class="s">"General Products"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">passenger</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1">// Initialize a field at a time</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">"Gridley, Lewis"</span><span class="p">,</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">covid_vaccinated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

            <span class="c1">// Or all at once</span>
            <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{.</span><span class="n">name</span><span class="o">=</span><span class="s">"Brown, Teela"</span><span class="p">,</span> <span class="p">.</span><span class="n">covid_vaccinated</span><span class="o">=</span><span class="mi">1</span><span class="p">},</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Passengers for %s ship:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">manufacturer</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_PASSENGERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">passenger</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"    %s (%svaccinated)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">s</span><span class="p">.</span><span class="n">passenger</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
                <span class="n">s</span><span class="p">.</span><span class="n">passenger</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">covid_vaccinated</span><span class="o">?</span> <span class="s">""</span><span class="o">:</span> <span class="s">"not "</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h2>20.2 Anonymous <code>struct</code>s</h2>

<p>These are “the <code>struct</code> with no name”. We also mention these in the <a href="typedef-making-new-types.html#typedef-struct" rel="nofollow"><code>typedef</code></a> section, but we’ll refresh here.</p>

<p>Here’s a regular <code>struct</code>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">animal</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">leg_count</span><span class="p">,</span> <span class="n">speed</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>And here’s the anonymous equivalent:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="p">{</span>              <span class="c1">// &lt;-- No name!</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">leg_count</span><span class="p">,</span> <span class="n">speed</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Okaaaaay. So we have a <code>struct</code>, but it has no name, so we have no way of using it later? Seems pretty pointless.</p>

<p>Admittedly, in that example, it is. But we can still make use of it a couple ways.</p>

<p>One is rare, but since the anonymous <code>struct</code> represents a type, we can just put some variable names after it and use them.</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="p">{</span>                   <span class="c1">// &lt;-- No name!</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">leg_count</span><span class="p">,</span> <span class="n">speed</span><span class="p">;</span>
<span class="p">}</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>                 <span class="c1">// 3 variables of this struct type</span>

<span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"antelope"</span><span class="p">;</span>
<span class="n">c</span><span class="p">.</span><span class="n">leg_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>           <span class="c1">// for example</span>
</code></pre></div>

<p>But that’s still not that useful.</p>

<p>Far more common is use of anonymous <code>struct</code>s with a <code>typedef</code> so that we can use it later (e.g. to pass variables to functions).</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>                   <span class="c1">// &lt;-- No name!</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">leg_count</span><span class="p">,</span> <span class="n">speed</span><span class="p">;</span>
<span class="p">}</span> <span class="n">animal</span><span class="p">;</span>                          <span class="c1">// New type: animal</span>

<span class="n">animal</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

<span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"antelope"</span><span class="p">;</span>
<span class="n">c</span><span class="p">.</span><span class="n">leg_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>           <span class="c1">// for example</span>
</code></pre></div>

<p>Personally, I don’t use many anonymous <code>struct</code>s. I think it’s more pleasant to see the entire <code>struct animal</code> before the variable name in a declaration.</p>

<p>But that’s just, like, my opinion, man.</p>

<h2>20.3 Self-Referential <code>struct</code>s</h2>

<p>For any graph-like data structure, it’s useful to be able to have pointers to the connected nodes/vertices. But this means that in the definition of a node, you need to have a pointer to a node. It’s chicken and eggy!</p>

<p>But it turns out you can do this in C with no problem whatsoever.</p>

<p>For example, here’s a linked list node:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>It’s important to note that <code>next</code> is a pointer. This is what allows the whole thing to even build. Even though the compiler doesn’t know what the entire <code>struct node</code> looks like yet, all pointers are the same size.</p>

<p>Here’s a cheesy linked list program to test it out:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

    <span class="c1">// Hackishly set up a linked list (11)-&gt;(22)-&gt;(33)</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="mi">22</span><span class="p">;</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="mi">33</span><span class="p">;</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Traverse it</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Running that prints:</p>

<div class="highlight"><pre class="highlight c"><code><span class="mi">11</span>
<span class="mi">22</span>
<span class="mi">33</span>
</code></pre></div>

<h2>20.4 Flexible Array Members</h2>

<p>Back in the good old days, when people carved C code out of wood, some folks thought would be neat if they could allocate <code>struct</code>s that had variable length arrays at the end of them.</p>

<p>I want to be clear that the first part of the section is the old way of doing things, and we’re going to do things the new way after that.</p>

<p>For example, maybe you could define a <code>struct</code> for holding strings and the length of that string. It would have a length and an array to hold the data. Maybe something like this:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">len_string</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>

<p>But that has <code>8</code> hardcoded as the maximum length of a string, and that’s not much. What if we did something <em>clever</em> and just <code>malloc()</code>d some extra space at the end after the struct, and then let the data overflow into that space?</p>

<p>Let’s do that, and then allocate another 40 bytes on top of it:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">len_string</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">s</span> <span class="o">+</span> <span class="mi">40</span><span class="p">);</span>
</code></pre></div>

<p>Because <code>data</code> is the last field of the <code>struct</code>, if we overflow that field, it runs out into space that we already allocated! For this reason, this trick only works if the short array is the <em>last</em> field in the <code>struct</code>.</p>

<div class="highlight"><pre class="highlight c"><code><span class="c1">// Copy more than 8 bytes!</span>

<span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">);</span>  <span class="c1">// Won't crash. Probably.</span>
</code></pre></div>

<p>In fact, there was a common compiler workaround for doing this, where you’d allocate a zero length array at the end:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">len_string</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>

<p>And then every extra byte you allocated was ready for use in that string.</p>

<p>Because <code>data</code> is the last field of the <code>struct</code>, if we overflow that field, it runs out into space that we already allocated!</p>

<div class="highlight"><pre class="highlight c"><code><span class="c1">// Copy more than 8 bytes!</span>

<span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">);</span>  <span class="c1">// Won't crash. Probably.</span>
</code></pre></div>

<p>But, of course, actually accessing the data beyond the end of that array is undefined behavior! In these modern times, we no longer deign to resort to such savagery.</p>

<p>Luckily for us, we can still get the same effect with C99 and later, but now it’s legal.</p>

<p>Let’s just change our above definition to have no size for the array<a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">¹³³</a>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">len_string</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">};</span>
</code></pre></div>

<p>Again, this only works if the flexible array member is the <em>last</em> field in the <code>struct</code>.</p>

<p>And then we can allocate all the space we want for those strings by <code>malloc()</code>ing larger than the <code>struct len_string</code>, as we do in this example that makes a new <code>struct len_string</code> from a C string:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">len_string</span> <span class="o">*</span><span class="nf">len_string_from_c_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

    <span class="c1">// Allocate "len" more bytes than we'd normally need</span>
    <span class="k">struct</span> <span class="n">len_string</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">ls</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

    <span class="n">ls</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

    <span class="c1">// Copy the string into those extra bytes</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ls</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2>20.5 Padding Bytes</h2>

<p>Beware that C is allowed to add padding bytes within or after a <code>struct</code> as it sees fit. You can’t trust that they will be directly adjacent in memory<a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">¹³⁴</a>.</p>

<p>Let’s take a look at this program. We output two numbers. One is the sum of the <code>sizeof</code>s the individual field types. The other is the <code>sizeof</code> the entire <code>struct</code>.</p>

<p>One would expect them to be the same. The size of the total is the size of the sum of its parts, right?</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p>But on my system, this outputs:</p>

<div class="highlight"><pre class="highlight c"><code><span class="mi">10</span>
<span class="mi">16</span>
</code></pre></div>

<p>They’re not the same! The compiler has added 6 bytes of padding to help it be more performant. Maybe you got different output with your compiler, but unless you’re forcing it, you can’t be sure there’s no padding.</p>

<h2>20.6 <code>offsetof</code></h2>

<p>In the previous section, we saw that the compiler could inject padding bytes at will inside a structure.</p>

<p>What if we needed to know where those were? We can measure it with <code>offsetof</code>, defined in <code>&lt;stddef.h&gt;</code>.</p>

<p>Let’s modify the code from above to print the offsets of the individual fields in the <code>struct</code>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stddef.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo</span><span class="p">,</span> <span class="n">a</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo</span><span class="p">,</span> <span class="n">c</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo</span><span class="p">,</span> <span class="n">d</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p>For me, this outputs:</p>

<div class="highlight"><pre class="highlight c"><code><span class="mi">0</span>
<span class="mi">4</span>
<span class="mi">8</span>
<span class="mi">12</span>
</code></pre></div>

<p>indicating that we’re using 4 bytes for each of the fields. It’s a little weird, because <code>char</code> is only 1 byte, right? The compiler is putting 3 padding bytes after each <code>char</code> so that all the fields are 4 bytes long. Presumably this will run faster on my CPU.</p>

<h2>20.7 Fake OOP</h2>

<p>There’s a slightly abusive thing that’s sort of OOP-like that you can do with <code>struct</code>s.</p>

<p>Since the pointer to the <code>struct</code> is the same as a pointer to the first element of the <code>struct</code>, you can freely cast a pointer to the <code>struct</code> to a pointer to the first element.</p>

<p>What this means is that we can set up a situation like this:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">parent</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">child</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">parent</span> <span class="n">super</span><span class="p">;</span>  <span class="c1">// MUST be first</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Then we are able to pass a pointer to a <code>struct child</code> to a function that expects either that <em>or</em> a pointer to a <code>struct parent</code>!</p>

<p>Because <code>struct parent super</code> is the first item in the <code>struct child</code>, a pointer to any <code>struct child</code> is the same as a pointer to that <code>super</code> field<a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">¹³⁵</a>.</p>

<p>Let’s set up an example here. We’ll make <code>struct</code>s as above, but then we’ll pass a pointer to a <code>struct child</code> to a function that needs a pointer to a <code>struct parent</code>… and it’ll still work.</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">parent</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">child</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">parent</span> <span class="n">super</span><span class="p">;</span>  <span class="c1">// MUST be first</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Making the argument `void*` so we can pass any type into it</span>
<span class="c1">// (namely a struct parent or struct child)</span>
<span class="kt">void</span> <span class="nf">print_parent</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Expects a struct parent--but a struct child will also work</span>
    <span class="c1">// because the pointer points to the struct parent in the first</span>
    <span class="c1">// field:</span>
    <span class="k">struct</span> <span class="n">parent</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Parent: %d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">child</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Child: %d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">child</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{.</span><span class="n">super</span><span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">super</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="p">.</span><span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="p">.</span><span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">};</span>

    <span class="n">print_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
    <span class="n">print_parent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>  <span class="c1">// Also works even though it's a struct child!</span>
<span class="p">}</span>
</code></pre></div>

<p>See what we did on the last line of <code>main()</code>? We called <code>print_parent()</code> but passed a <code>struct child*</code> as the argument! Even though <code>print_parent()</code> needs the argument to point to a <code>struct parent</code>, we’re <em>getting away with it</em> because the first field in the <code>struct child</code> is a <code>struct parent</code>.</p>

<p>Again, this works because a pointer to a <code>struct</code> has the same value as a pointer to the first field in that <code>struct</code>.</p>

<p>This all hinges on this part of the spec:</p>

<blockquote>
<p><strong>§6.7.2.1¶15</strong> […] A pointer to a structure object, suitably converted, points to its initial member […], and vice versa.</p>
</blockquote>

<p>and</p>

<blockquote>
<p><strong>§6.5¶7</strong> An object shall have its stored value accessed only by an lvalue expression that has one of the following types:</p>

<ul>
<li>  a type compatible with the effective type of the object</li>
<li>  […]</li>
</ul>
</blockquote>

<p>and my assumption that “suitably converted” means “cast to the effective type of the initial member”.</p>

<h2>20.8 Bit-Fields</h2>

<p>In my experience, these are rarely used, but you might see them out there from time to time, especially in lower-level applications that pack bits together into larger spaces.</p>

<p>Let’s take a look at some code to demonstrate a use case:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p>For me, this prints <code>16</code>. Which makes sense, since <code>unsigned</code>s are 4 bytes on my system.</p>

<p>But what if we knew that all the values that were going to be stored in <code>a</code> and <code>b</code> could be stored in 5 bits, and the values in <code>c</code>, and <code>d</code> could be stored in 3 bits? That’s only a total 16 bits. Why have 128 bits reserved for them if we’re only going to use 16?</p>

<p>Well, we can tell C to pretty-please try to pack these values in. We can specify the maximum number of bits that values can take (from 1 up the size of the containing type).</p>

<p>We do this by putting a colon after the field name, followed by the field width in bits.</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Now when I ask C how big my <code>struct foo</code> is, it tells me 4! It was 16 bytes, but now it’s only 4. It has “packed” those 4 values down into 4 bytes, which is a four-fold memory savings.</p>

<p>The tradeoff is, of course, that the 5-bit fields can only hold values from 0-31 and the 3-bit fields can only hold values from 0-7. But life’s all about compromise, after all.</p>

<h3>20.8.1 Non-Adjacent Bit-Fields</h3>

<p>A gotcha: C will only combine <strong>adjacent</strong> bit-fields. If they’re interrupted by non-bit-fields, you get no savings:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>            <span class="c1">// sizeof(struct foo) == 16 (for me)</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>   <span class="c1">// since a is not adjacent to c.</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>In that example, since <code>a</code> is not adjacent to <code>c</code>, they are both “packed” in their own <code>int</code>s.</p>

<p>So we have one <code>int</code> each for <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>. Since my <code>int</code>s are 4 bytes, that’s a grand total of 16 bytes.</p>

<p>A quick rearrangement yields some space savings from 16 bytes down to 12 bytes (on my system):</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>            <span class="c1">// sizeof(struct foo) == 12 (for me)</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>And now, since <code>a</code> is next to <code>c</code>, the compiler puts them together into a single <code>int</code>.</p>

<p>So we have one <code>int</code> for a combined <code>a</code> and <code>c</code>, and one <code>int</code> each for <code>b</code> and <code>d</code>. For a grand total of 3 <code>int</code>s, or 12 bytes.</p>

<p>Put all your bitfields together to get the compiler to combine them.</p>

<h3>20.8.2 Signed or Unsigned <code>int</code>s</h3>

<p>If you just declare a bit-field to be <code>int</code>, the different compilers will treat it as <code>signed</code> or <code>unsigned</code>. Just like the situation with <code>char</code>.</p>

<p>Be specific about the signedness when using bit-fields.</p>

<h3>20.8.3 Unnamed Bit-Fields</h3>

<p>In some specific circumstances, you might need to reserve some bits for hardware reasons, but not need to use them in code.</p>

<p>For example, let’s say you have a byte where the top 2 bits have a meaning, the bottom 1 bit has a meaning, but the middle 5 bits do not get used by you<a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">¹³⁶</a>.</p>

<p>We <em>could</em> do something like this:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">a</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dummy</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>And that works—in our code we use <code>a</code> and <code>b</code>, but never <code>dummy</code>. It’s just there to eat up 5 bits to make sure <code>a</code> and <code>b</code> are in the “required” (by this contrived example) positions within the byte.</p>

<p>C allows us a way to clean this up: <em>unnamed bit-fields</em>. You can just leave the name (<code>dummy</code>) out in this case, and C is perfectly happy for the same effect:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">a</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">:</span><span class="mi">5</span><span class="p">;</span>   <span class="c1">// &lt;-- unnamed bit-field!</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<h3>20.8.4 Zero-Width Unnamed Bit-Fields</h3>

<p>Some more esoterica out here… Let’s say you were packing bits into an <code>unsigned int</code>, and you needed some adjacent bit-fields to pack into the <em>next</em> <code>unsigned int</code>.</p>

<p>That is, if you do this:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>the compiler packs all those into a single <code>unsigned int</code>. But what if you needed <code>a</code> and <code>b</code> in one <code>int</code>, and <code>c</code> and <code>d</code> in a different one?</p>

<p>There’s a solution for that: put an unnamed bit-field of width <code>0</code> where you want the compiler to start anew with packing bits in a different <code>int</code>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">:</span><span class="mi">0</span><span class="p">;</span>   <span class="c1">// &lt;--Zero-width unnamed bit-field</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>It’s analogous to an explicit page break in a word processor. You’re telling the compiler, “Stop packing bits in this <code>unsigned</code>, and start packing them in the next one.”</p>

<p>By adding the zero-width unnamed bit field in that spot, the compiler puts <code>a</code> and <code>b</code> in one <code>unsigned int</code>, and <code>c</code> and <code>d</code> in another <code>unsigned int</code>. Two total, for a size of 8 bytes on my system (<code>unsigned int</code>s are 4 bytes each).</p>

<h2>20.9 Unions</h2>

<p>These are basically just like <code>struct</code>s, except the fields overlap in memory. The <code>union</code> will be only large enough for the largest field, and you can only use one field at a time.</p>

<p>It’s a way to reuse the same memory space for different types of data.</p>

<p>You declare them just like <code>struct</code>s, except it’s <code>union</code>. Take a look at this:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">union</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Now, that’s a lot of fields. If this were a <code>struct</code>, my system would tell me it took 36 bytes to hold it all.</p>

<p>But it’s a <code>union</code>, so all those fields overlap in the same stretch of memory. The biggest one is <code>int</code> (or <code>float</code>), taking up 4 bytes on my system. And, indeed, if I ask for the <code>sizeof</code> the <code>union foo</code>, it tells me 4!</p>

<p>The tradeoff is that you can only portably use one of those fields at a time. However…</p>

<h3>20.9.1 Unions and Type Punning</h3>

<p>You can non-portably write to one <code>union</code> field and read from another!</p>

<p>Doing so is called <a href="https://en.wikipedia.org/wiki/Type_punning" rel="nofollow">type punning</a><a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">¹³⁷</a>, and you’d use it if you really knew what you were doing, typically with some kind of low-level programming.</p>

<p>Since the members of a union share the same memory, writing to one member necessarily affects the others. And if you read from one what was written to another, you get some weird effects.</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">union</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">union</span> <span class="n">foo</span> <span class="n">x</span><span class="p">;</span>

    <span class="n">x</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 3.14159, fair enough</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// But what about this?</span>
<span class="p">}</span>
</code></pre></div>

<p>On my system, this prints out:</p>

<div class="highlight"><pre class="highlight plaintext"><code>3.141590
4048
</code></pre></div>

<p>because under the hood, the object representation for the float <code>3.14159</code> was the same as the object representation for the short <code>4048</code>. On my system. Your results may vary.</p>

<h3>20.9.2 Pointers to <code>union</code>s</h3>

<p>If you have a pointer to a <code>union</code>, you can cast that pointer to any of the types of the fields in that <code>union</code> and get the values out that way.</p>

<p>In this example, we see that the <code>union</code> has <code>int</code>s and <code>float</code>s in it. And we get pointers to the <code>union</code>, but we cast them to <code>int*</code> and <code>float*</code> types (the cast silences compiler warnings). And then if we dereference those, we see that they have the values we stored directly in the <code>union</code>.</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">union</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">union</span> <span class="n">foo</span> <span class="n">x</span><span class="p">;</span>

    <span class="kt">int</span> <span class="o">*</span><span class="n">foo_int_p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">foo_float_p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

    <span class="n">x</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>           <span class="c1">// 12</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">foo_int_p</span><span class="p">);</span>    <span class="c1">// 12, again</span>

    <span class="n">x</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">141592</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">g</span><span class="p">);</span>           <span class="c1">// 3.141592</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">foo_float_p</span><span class="p">);</span>  <span class="c1">// 3.141592, again</span>
<span class="p">}</span>
</code></pre></div>

<p>The reverse is also true. If we have a pointer to a type inside the <code>union</code>, we can cast that to a pointer to the <code>union</code> and access its members.</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">union</span> <span class="n">foo</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">foo_int_p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>             <span class="c1">// Pointer to int field</span>
<span class="k">union</span> <span class="n">foo</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">foo</span> <span class="o">*</span><span class="p">)</span><span class="n">foo_int_p</span><span class="p">;</span>  <span class="c1">// Back to pointer to union</span>

<span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>  <span class="c1">// This line the same as...</span>
<span class="n">x</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>   <span class="c1">// this one.</span>
</code></pre></div>

<p>All this just lets you know that, under the hood, all these values in a <code>union</code> start at the same place in memory, and that’s the same as where the entire <code>union</code> is.</p>

<h3>20.9.3 Common Initial Sequences in Unions</h3>

<p>If you have a <code>union</code> of <code>struct</code>s, and all those <code>struct</code>s begin with a <em>common initial sequence</em>, it’s valid to access members of that sequence from any of the <code>union</code> members.</p>

<p>What?</p>

<p>Here are two <code>struct</code>s with a common initial sequence:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">a</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>     <span class="c1">//</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>   <span class="c1">// Common initial sequence</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">b</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>     <span class="c1">//</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>   <span class="c1">// Common initial sequence</span>

    <span class="kt">double</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Do you see it? It’s that they start with <code>int</code> followed by <code>float</code>—that’s the common initial sequence. The members in the sequence of the <code>struct</code>s have to be compatible types. And we see that with <code>x</code> and <code>y</code>, which are <code>int</code> and <code>float</code> respectively.</p>

<p>Now let’s build a union of these:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">union</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">a</span> <span class="n">sa</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">b</span> <span class="n">sb</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>What this rule tells us is that we’re guaranteed that the members of the common initial sequences are interchangeable in code. That is:</p>

<ul>
<li>  <code>f.sa.x</code> is the same as <code>f.sb.x</code>.</li>
</ul>

<p>and</p>

<ul>
<li>  <code>f.sa.y</code> is the same as <code>f.sb.y</code>.</li>
</ul>

<p>Because fields <code>x</code> and <code>y</code> are both in the common initial sequence.</p>

<p>Also, the names of the members in the common initial sequence don’t matter—all that matters is that the types are the same.</p>

<p>All together, this allows us a way to safely add some shared information between <code>struct</code>s in the <code>union</code>. The best example of this is probably using a field to determine the type of <code>struct</code> out of all the <code>struct</code>s in the <code>union</code> that is currently “in use”.</p>

<p>That is, if we weren’t allowed this and we passed the <code>union</code> to some function, how would that function know which member of the <code>union</code> was the one it should look at?</p>

<p>Take a look at these <code>struct</code>s. Note the common initial sequence:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">common</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>   <span class="c1">// common initial sequence</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">antelope</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>   <span class="c1">// common initial sequence</span>

    <span class="kt">int</span> <span class="n">loudness</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">octopus</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>   <span class="c1">// common initial sequence</span>

    <span class="kt">int</span> <span class="n">sea_creature</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">intelligence</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Now let’s throw them into a <code>union</code>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">union</span> <span class="n">animal</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">common</span> <span class="n">common</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">antelope</span> <span class="n">antelope</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">octopus</span> <span class="n">octopus</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Also, please indulge me these two <code>#define</code>s for the demo:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#define ANTELOPE 1
#define OCTOPUS  2
</span></code></pre></div>

<p>So far, nothing special has happened here. It seems like the <code>type</code> field is completely useless.</p>

<p>But now let’s make a generic function that prints a <code>union animal</code>. It has to somehow be able to tell if it’s looking at a <code>struct antelope</code> or a <code>struct octopus</code>.</p>

<p>Because of the magic of common initial sequences, it can look up the animal type in any of these places for a particular <code>union animal x</code>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">common</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>    <span class="err">\\</span> <span class="n">or</span><span class="p">...</span>
<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">antelope</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>  <span class="err">\\</span> <span class="n">or</span><span class="p">...</span>
<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">octopus</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
</code></pre></div>

<p>All those refer to the same value in memory.</p>

<p>And, as you might have guessed, the <code>struct common</code> is there so code can agnostically look at the type without mentioning a particular animal.</p>

<p>Let’s look at the code to print a <code>union animal</code>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">void</span> <span class="nf">print_animal</span><span class="p">(</span><span class="k">union</span> <span class="n">animal</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">ANTELOPE</span><span class="p">:</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Antelope: loudness=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">antelope</span><span class="p">.</span><span class="n">loudness</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="n">OCTOPUS</span><span class="p">:</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Octopus : sea_creature=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">octopus</span><span class="p">.</span><span class="n">sea_creature</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"          intelligence=%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">octopus</span><span class="p">.</span><span class="n">intelligence</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="nl">default:</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Unknown animal type</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">union</span> <span class="n">animal</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{.</span><span class="n">antelope</span><span class="p">.</span><span class="n">type</span><span class="o">=</span><span class="n">ANTELOPE</span><span class="p">,</span> <span class="p">.</span><span class="n">antelope</span><span class="p">.</span><span class="n">loudness</span><span class="o">=</span><span class="mi">12</span><span class="p">};</span>
    <span class="k">union</span> <span class="n">animal</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{.</span><span class="n">octopus</span><span class="p">.</span><span class="n">type</span><span class="o">=</span><span class="n">OCTOPUS</span><span class="p">,</span> <span class="p">.</span><span class="n">octopus</span><span class="p">.</span><span class="n">sea_creature</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                       <span class="p">.</span><span class="n">octopus</span><span class="p">.</span><span class="n">intelligence</span><span class="o">=</span><span class="mi">12</span><span class="p">.</span><span class="mi">8</span><span class="p">};</span>

    <span class="n">print_animal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
    <span class="n">print_animal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>See how on line 29 we’re just passing in the <code>union</code>—we have no idea what type of animal <code>struct</code> is in use within it.</p>

<p>But that’s OK! Because on line 31 we check the type to see if it’s an antelope or an octopus. And then we can look at the proper <code>struct</code> to get the members.</p>

<p>It’s definitely possible to get this same effect using just <code>struct</code>s, but you can do it this way if you want the memory-saving effects of a <code>union</code>.</p>

<h2>20.10 Unions and Unnamed Structs</h2>

<p>You know how you can have an unnamed <code>struct</code>, like this:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
</code></pre></div>

<p>That defines a variable <code>s</code> that is of anonymous <code>struct</code> type (because the <code>struct</code> has no name tag), with members <code>x</code> and <code>y</code>.</p>

<p>So things like this are valid:</p>

<div class="highlight"><pre class="highlight c"><code><span class="n">s</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">34</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</code></pre></div>

<p>Turns out you can drop those unnamed <code>struct</code>s in <code>union</code>s just like you might expect:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">union</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>       <span class="c1">// unnamed!</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">a</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>       <span class="c1">// unnamed!</span>
        <span class="kt">int</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>And then access them as per normal:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">union</span> <span class="n">foo</span> <span class="n">f</span><span class="p">;</span>

<span class="n">f</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">f</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">f</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">f</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div>

<p>No problem!</p>

<h2>20.11 Passing and Returning <code>struct</code>s and <code>union</code>s</h2>

<p>You can pass a <code>struct</code> or <code>union</code> to a function by value (as opposed to a pointer to it)—a copy of that object to the parameter will be made as if by assignment as per usual.</p>

<p>You can also return a <code>struct</code> or <code>union</code> from a function and it is also passed by value back.</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">foo</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">foo</span><span class="p">){.</span><span class="n">x</span><span class="o">=</span><span class="mi">34</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">90</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">foo</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>  <span class="c1">// Copy is made</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Fun fact: if you do this, you can use the <code>.</code> operator right off the function call:</p>

<div class="highlight"><pre class="highlight c"><code>    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">f</span><span class="p">().</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">().</span><span class="n">y</span><span class="p">);</span>
</code></pre></div>

<p>(Of course that example calls the function twice, inefficiently.)</p>

<p>And the same holds true for returning pointers to <code>struct</code>s and <code>union</code>s—just be sure to use the <code>-&gt;</code> arrow operator in that case.</p>

    
    </main>
    <footer id="footer">
      <div class="footer-section"><a href="/license/">CC BY-NC-SA 4.0</a><p>&nbsp;::&nbsp;2019 - 2025 ovelny</p></div>
      <div class="footer-section">「七転び八起き」</div>
    </footer>
  </body>
</html>

