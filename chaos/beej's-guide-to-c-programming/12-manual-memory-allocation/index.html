<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ovelny - chaos/beej's-guide-to-c-programming/12-manual-memory-allocation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="ovelny - notes on infosec, penetration testing, programming and others"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" type=text/css href="/assets/css/dead-simple.min.css">
    <link rel="stylesheet" type=text/css href="/assets/css/rouge.min.css">
    <link
      href="/atom.xml"
      rel="alternate"
      title="ovelny"
      type="application/atom+xml"
    />
    <script src="/assets/js/scramble-text.min.js" defer></script>
    <script src="/assets/js/zoom-images.min.js" defer></script>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ovelny"/>
    <meta name="twitter:title" content="ovelny - chaos/beej's-guide-to-c-programming/12-manual-memory-allocation"/>
    <meta name="twitter:image" content="https://ovelny.sh/assets/images/ovelny-logo.png"/>
    <meta name="twitter:image:alt" content="ovelny logo: 6 white circles grouped together forming a triangle shape, with a black background."/>
  </head>
  <body>

    <header>
      <section>
        <a href="/">
          <img
            class="logo"
            src="/assets/images/ovelny-pfp.png"
            alt="ovelny profile picture: a glitched picture of a three-eyed girl, staring intensely at the viewer."
          />
        </a>
        <h2><a class="ovelny" href="/">ovelny</a></h2>
      </section>
      <nav>
        <a href="/">home</a>
        <a href="/chaos/">chaos</a>
        <a href="/phasm/">phasm</a>
        <a href="/support/">support</a>
        <a href="/atom.xml" target="_blank" rel="noopener noreferrer">rss</a>
        <a href="/about/">about</a>
      </nav>
    </header>
    <main>

    
    <h1>12 Manual Memory Allocation</h1>

<p>This is one of the big areas where C likely diverges from languages you already know: <em>manual memory management</em>.</p>

<p>Other languages uses reference counting, garbage collection, or other means to determine when to allocate new memory for some data—and when to deallocate it when no variables refer to it.</p>

<p>And that’s nice. It’s nice to be able to not worry about it, to just drop all the references to an item and trust that at some point the memory associated with it will be freed.</p>

<p>But C’s not like that, entirely.</p>

<p>Of course, in C, some variables are automatically allocated and deallocated when they come into scope and leave scope. We call these automatic variables. They’re your average run-of-the-mill block scope “local” variables. No problem.</p>

<p>But what if you want something to persist longer than a particular block? This is where manual memory management comes into play.</p>

<p>You can tell C explicitly to allocate for you a certain number of bytes that you can use as you please. And these bytes will remain allocated until you explicitly free that memory<a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">⁸⁸</a>.</p>

<p>It’s important to free the memory you’re done with! If you don’t, we call that a <em>memory leak</em> and your process will continue to reserve that memory until it exits.</p>

<p><em>If you manually allocated it, you have to manually free it when you’re done with it.</em></p>

<p>So how do we do this? We’re going to learn a couple new functions, and make use of the <code>sizeof</code> operator to help us learn how many bytes to allocate.</p>

<p>In common C parlance, devs say that automatic local variables are allocated “on the stack”, and manually-allocated memory is “on the heap”. The spec doesn’t talk about either of those things, but all C devs will know what you’re talking about if you bring them up.</p>

<p>All functions we’re going to learn in this chapter can be found in <code>&lt;stdlib.h&gt;</code>.</p>

<h2>12.1 Allocating and Deallocating, <code>malloc()</code> and <code>free()</code></h2>

<p>The <code>malloc()</code> function accepts a number of bytes to allocate, and returns a void pointer to that block of newly-allocated memory.</p>

<p>Since it’s a <code>void*</code>, you can assign it into whatever pointer type you want… normally this will correspond in some way to the number of bytes you’re allocating.</p>

<p>So… how many bytes should I allocate? We can use <code>sizeof</code> to help with that. If we want to allocate enough room for a single <code>int</code>, we can use <code>sizeof(int)</code> and pass that to <code>malloc()</code>.</p>

<p>After we’re done with some allocated memory, we can call <code>free()</code> to indicate we’re done with that memory and it can be used for something else. As an argument, you pass the same pointer you got from <code>malloc()</code> (or a copy of it). It’s undefined behavior to use a memory region after you <code>free()</code> it.</p>

<p>Let’s try. We’ll allocate enough memory for an <code>int</code>, and then store something there, and the print it.</p>

<div class="highlight"><pre class="highlight c"><code><span class="c1">// Allocate space for a single int (sizeof(int) bytes-worth):</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>  <span class="c1">// Store something there</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// Print it: 12</span>

<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// All done with that memory</span>

<span class="c1">//*p = 3490;  // ERROR: undefined behavior! Use after free()!</span>
</code></pre></div>

<p>Now, in that contrived example, there’s really no benefit to it. We could have just used an automatic <code>int</code> and it would have worked. But we’ll see how the ability to allocate memory this way has its advantages, especially with more complex data structures.</p>

<p>One more thing you’ll commonly see takes advantage of the fact that <code>sizeof</code> can give you the size of the result type of any constant expression. So you could put a variable name in there, too, and use that. Here’s an example of that, just like the previous one:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// *p is an int, so same as sizeof(int)</span>
</code></pre></div>

<h2>12.2 Error Checking</h2>

<p>All the allocation functions return a pointer to the newly-allocated stretch of memory, or <code>NULL</code> if the memory cannot be allocated for some reason.</p>

<p>Some OSes like Linux can be configured in such a way that <code>malloc()</code> never returns <code>NULL</code>, even if you’re out of memory. But despite this, you should always code it up with protections in mind.</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Error allocating 10 ints</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// do something here to handle it</span>
<span class="p">}</span>
</code></pre></div>

<p>Here’s a common pattern that you’ll see, where we do the assignment and the condition on the same line:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>

<span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Error allocating 10 ints</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// do something here to handle it</span>
<span class="err">}</span>
</code></pre></div>

<h2>12.3 Allocating Space for an Array</h2>

<p>We’ve seen how to allocate space for a single thing; now what about for a bunch of them in an array?</p>

<p>In C, an array is a bunch of the same thing back-to-back in a contiguous stretch of memory.</p>

<p>We can allocate a contiguous stretch of memory—we’ve seen how to do that. If we wanted 3490 bytes of memory, we could just ask for it:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">3490</span><span class="p">);</span>  <span class="c1">// Voila</span>
</code></pre></div>

<p>And—indeed!—that’s an array of 3490 <code>char</code>s (AKA a string!) since each <code>char</code> is 1 byte. In other words, <code>sizeof(char)</code> is <code>1</code>.</p>

<p>Note: there’s no initialization done on the newly-allocated memory—it’s full of garbage. Clear it with <code>memset()</code> if you want to, or see <code>calloc()</code>, below.</p>

<p>But we can just multiply the size of the thing we want by the number of elements we want, and then access them using either pointer or array notation. Example!</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Allocate space for 10 ints</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>

    <span class="c1">// Assign them values 0-45:</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>

    <span class="c1">// Print all values 0, 5, 10, 15, ..., 40, 45</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="c1">// Free the space</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>The key’s in that <code>malloc()</code> line. If we know each <code>int</code> takes <code>sizeof(int)</code> bytes to hold it, and we know we want 10 of them, we can just allocate exactly that many bytes with:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
</code></pre></div>

<p>And this trick works for every type. Just pass it to <code>sizeof</code> and multiply by the size of the array.</p>

<h2>12.4 An Alternative: <code>calloc()</code></h2>

<p>This is another allocation function that works similarly to <code>malloc()</code>, with two key differences:</p>

<ul>
<li>  Instead of a single argument, you pass the size of one element, and the number of elements you wish to allocate. It’s like it’s made for allocating arrays.</li>
<li>  It clears the memory to zero.</li>
</ul>

<p>You still use <code>free()</code> to deallocate memory obtained through <code>calloc()</code>.</p>

<p>Here’s a comparison of <code>calloc()</code> and <code>malloc()</code>.</p>

<div class="highlight"><pre class="highlight c"><code><span class="c1">// Allocate space for 10 ints with calloc(), initialized to 0:</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="c1">// Allocate space for 10 ints with malloc(), initialized to 0:</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>   <span class="c1">// set to 0</span>
</code></pre></div>

<p>Again, the result is the same for both except <code>malloc()</code> doesn’t zero the memory by default.</p>

<h2>12.5 Changing Allocated Size with <code>realloc()</code></h2>

<p>If you’ve already allocated 10 <code>int</code>s, but later you decide you need 20, what can you do?</p>

<p>One option is to allocate some new space, and then <code>memcpy()</code> the memory over… but it turns out that sometimes you don’t need to move anything. And there’s one function that’s just smart enough to do the right thing in all the right circumstances: <code>realloc()</code>.</p>

<p>It takes a pointer to some previously-allocted memory (by <code>malloc()</code> or <code>calloc()</code>) and a new size for the memory region to be.</p>

<p>It then grows or shrinks that memory, and returns a pointer to it. Sometimes it might return the same pointer (if the data didn’t have to be copied elsewhere), or it might return a different one (if the data did have to be copied).</p>

<p>Be sure when you call <code>realloc()</code>, you specify the number of <em>bytes</em> to allocate, and not just the number of array elements! That is:</p>

<div class="highlight"><pre class="highlight c"><code><span class="n">num_floats</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>

<span class="n">np</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">num_floats</span><span class="p">);</span>  <span class="c1">// WRONG: need bytes, not number of elements!</span>

<span class="n">np</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">num_floats</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>  <span class="c1">// Better!</span>
</code></pre></div>

<p>Let’s allocate an array of 20 <code>float</code>s, and then change our mind and make it an array of 40.</p>

<p>We’re going to assign the return value of <code>realloc()</code> into another pointer just to make sure it’s not <code>NULL</code>. If it’s not, then we can reassign it into our original pointer. (If we just assigned the return value directly into the original pointer, we’d lose that pointer if the function returned <code>NULL</code> and we’d have no way to get it back.)</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Allocate space for 20 floats</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">p</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>  <span class="c1">// sizeof *p same as sizeof(float)</span>

    <span class="c1">// Assign them fractional values 0.0-1.0:</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">20</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

    <span class="c1">// But wait! Let's actually make this an array of 40 elements</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">new_p</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">p</span> <span class="o">*</span> <span class="mi">40</span><span class="p">);</span>

    <span class="c1">// Check to see if we successfully reallocated</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Error reallocing</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// If we did, we can just reassign p</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">new_p</span><span class="p">;</span>

    <span class="c1">// And assign the new elements values in the range 1.0-2.0</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Print all values 0.0-2.0 in the 40 elements:</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="c1">// Free the space</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Notice in there how we took the return value from <code>realloc()</code> and reassigned it into the same pointer variable <code>p</code> that we passed in. That’s pretty common to do.</p>

<p>Also if line 7 is looking weird, with that <code>sizeof *p</code> in there, remember that <code>sizeof</code> works on the size of the type of the expression. And the type of <code>*p</code> is <code>float</code>, so that line is equivalent to <code>sizeof(float)</code>.</p>

<h3>12.5.1 Reading in Lines of Arbitrary Length</h3>

<p>I want to demonstrate two things with this full-blown example.</p>

<ol>
<li> Use of <code>realloc()</code> to grow a buffer as we read in more data.</li>
<li> Use of <code>realloc()</code> to shrink the buffer down to the perfect size after we’ve completed the read.</li>
</ol>

<p>What we see here is a loop that calls <code>fgetc()</code> over and over to append to a buffer until we see that the last character is a newline.</p>

<p>Once it finds the newline, it shrinks the buffer to just the right size and returns it.</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">// Read a line of arbitrary size from a file</span>
<span class="c1">//</span>
<span class="c1">// Returns a pointer to the line.</span>
<span class="c1">// Returns NULL on EOF or error.</span>
<span class="c1">//</span>
<span class="c1">// It's up to the caller to free() this pointer when done with it.</span>
<span class="c1">//</span>
<span class="c1">// Note that this strips the newline from the result. If you need</span>
<span class="c1">// it in there, probably best to switch this to a do-while.</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">readline</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// Index next char goes in the buffer</span>
    <span class="kt">int</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>  <span class="c1">// Preferably power of 2 initial size</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>        <span class="c1">// The buffer</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>            <span class="c1">// The character we've read in</span>

    <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">bufsize</span><span class="p">);</span>  <span class="c1">// Allocate initial buffer</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>   <span class="c1">// Error check</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Main loop--read until newline or EOF</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">fgetc</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">'\n'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// Check if we're out of room in the buffer accounting</span>
        <span class="c1">// for the extra byte for the NUL terminator</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">bufsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// -1 for the NUL terminator</span>
            <span class="n">bufsize</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 2x the space</span>

            <span class="kt">char</span> <span class="o">*</span><span class="n">new_buf</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">new_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>   <span class="c1">// On error, free and bail</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">buf</span> <span class="o">=</span> <span class="n">new_buf</span><span class="p">;</span>  <span class="c1">// Successful realloc</span>
        <span class="p">}</span>

        <span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">// Add the byte onto the buffer</span>
    <span class="p">}</span>

    <span class="c1">// We hit newline or EOF...</span>

    <span class="c1">// If at EOF and we read no bytes, free the buffer and</span>
    <span class="c1">// return NULL to indicate we're at EOF:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">EOF</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Shrink to fit</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">bufsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// If we're short of the end</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">new_buf</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// +1 for NUL terminator</span>

        <span class="c1">// If successful, point buf to new_buf;</span>
        <span class="c1">// otherwise we'll just leave buf where it is</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">new_buf</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Add the NUL terminator</span>
    <span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">readline</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>When growing memory like this, it’s common (though hardly a law) to double the space needed each step just to minimize the number of <code>realloc()</code>s that occur.</p>

<p>Finally you might note that <code>readline()</code> returns a pointer to a <code>malloc()</code>d buffer. As such, it’s up to the caller to explicitly <code>free()</code> that memory when it’s done with it.</p>

<h3>12.5.2 <code>realloc()</code> with <code>NULL</code></h3>

<p>Trivia time! These two lines are equivalent:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">3490</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">3490</span><span class="p">);</span>
</code></pre></div>

<p>That could be convenient if you have some kind of allocation loop and you don’t want to special-case the first <code>malloc()</code>.</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Allocate 10 more ints:</span>
    <span class="n">length</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">p</span> <span class="o">*</span> <span class="n">length</span><span class="p">);</span>

    <span class="c1">// Do amazing things</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<p>In that example, we didn’t need an initial <code>malloc()</code> since <code>p</code> was <code>NULL</code> to start.</p>

<h2>12.6 Aligned Allocations</h2>

<p>You probably aren’t going to need to use this.</p>

<p>And I don’t want to get too far off in the weeds talking about it right now, but there’s this thing called <em>memory alignment</em>, which has to do with the memory address (pointer value) being a multiple of a certain number.</p>

<p>For example, a system might require that 16-bit values begin on memory addresses that are multiples of 2. Or that 64-bit values begin on memory addresses that are multiples of 2, 4, or 8, for example. It depends on the CPU.</p>

<p>Some systems require this kind of alignment for fast memory access, or some even for memory access at all.</p>

<p>Now, if you use <code>malloc()</code>, <code>calloc()</code>, or <code>realloc()</code>, C will give you a chunk of memory that’s well-aligned for any value at all, even <code>struct</code>s. Works in all cases.</p>

<p>But there might be times that you know that some data can be aligned at a smaller boundary, or must be aligned at a larger one for some reason. I imagine this is more common with embedded systems programming.</p>

<p>In those cases, you can specify an alignment with <code>aligned_alloc()</code>.</p>

<p>The alignment is an integer power of two greater than zero, so <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, etc. and you give that to <code>aligned_alloc()</code> before the number of bytes you’re interested in.</p>

<p>The other restriction is that the number of bytes you allocate needs to be a multiple of the alignment. But this might be changing. See <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/summary.htm#dr_460" rel="nofollow">C Defect Report 460</a><a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">⁸⁹</a></p>

<p>Let’s do an example, allocating on a 64-byte boundary:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Allocate 256 bytes aligned on a 64-byte boundary</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">aligned_alloc</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>  <span class="c1">// 256 == 64 * 4</span>

    <span class="c1">// Copy a string in there and print it</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

    <span class="c1">// Free the space</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>I want to throw a note here about <code>realloc()</code> and <code>aligned_alloc()</code>. <code>realloc()</code> doesn’t have any alignment guarantees, so if you need to get some aligned reallocated space, you’ll have to do it the hard way with <code>memcpy()</code>.</p>

<p>Here’s a non-standard <code>aligned_realloc()</code> function, if you need it:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">aligned_realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">old_size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">alignment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">new_ptr</span> <span class="o">=</span> <span class="n">aligned_alloc</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">new_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">copy_size</span> <span class="o">=</span> <span class="n">old_size</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">?</span> <span class="n">old_size</span><span class="o">:</span> <span class="n">size</span><span class="p">;</span>  <span class="c1">// get min</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">new_ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">new_ptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Note that it <em>always</em> copies data, taking time, while real <code>realloc()</code> will avoid that if it can. So this is hardly efficient. Avoid needing to reallocate custom-aligned data.</p>

    
    </main>
    <footer id="footer">
      <div class="footer-section"><a href="/license/">CC BY-NC-SA 4.0</a><p>&nbsp;::&nbsp;2019 - 2025 ovelny</p></div>
      <div class="footer-section">「七転び八起き」</div>
    </footer>
  </body>
</html>

