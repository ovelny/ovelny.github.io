<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ovelny - chaos/beej's-guide-to-c-programming/11-pointers2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="ovelny - notes on infosec, penetration testing, programming and others"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" type=text/css href="/assets/css/dead-simple.min.css">
    <link rel="stylesheet" type=text/css href="/assets/css/rouge.min.css">
    <link
      href="/atom.xml"
      rel="alternate"
      title="ovelny"
      type="application/atom+xml"
    />
    <script src="/assets/js/scramble-text.min.js" defer></script>
    <script src="/assets/js/zoom-images.min.js" defer></script>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@ovelny"/>
    <meta name="twitter:title" content="ovelny - chaos/beej's-guide-to-c-programming/11-pointers2"/>
    <meta name="twitter:image" content="https://ovelny.sh/assets/images/ovelny-logo.png"/>
    <meta name="twitter:image:alt" content="ovelny logo: 6 white circles grouped together forming a triangle shape, with a black background."/>
  </head>
  <body>

    <header>
      <section>
        <a href="/">
          <img
            class="logo"
            src="/assets/images/ovelny-pfp.png"
            alt="ovelny profile picture: a glitched picture of a three-eyed girl, staring intensely at the viewer."
          />
        </a>
        <h2><a class="ovelny" href="/">ovelny</a></h2>
      </section>
      <nav>
        <a href="/">home</a>
        <a href="/chaos/">chaos</a>
        <a href="/phasm/">phasm</a>
        <a href="/support/">support</a>
        <a href="/atom.xml" target="_blank" rel="noopener noreferrer">rss</a>
        <a href="/about/">about</a>
      </nav>
    </header>
    <main>

    
    <h1>11 Pointers II: Arithmetic</h1>

<p>Time to get more into it with a number of new pointer topics! If you’re not up to speed with pointers, <a href="pointers.html#pointers" rel="nofollow">check out the first section in the guide on the matter</a>.</p>

<h2>11.1 Pointer Arithmetic</h2>

<p>Turns out you can do math on pointers, notably addition and subtraction.</p>

<p>But what does it mean when you do that?</p>

<p>In short, if you have a pointer to a type, adding one to the pointer moves to the next item of that type directly after it in memory.</p>

<p>It’s <strong>important</strong> to remember that as we move pointers around and look at different places in memory, we need to make sure that we’re always pointing to a valid place in memory before we dereference. If we’re off in the weeds and we try to see what’s there, the behavior is undefined and a crash is a common result.</p>

<p>This is a little chicken-and-eggy with <a href="pointers2.html#arraypointerequiv" rel="nofollow">Array/Pointer Equivalence, below</a>, but we’re going to give it a shot, anyway.</p>

<h3>11.1.1 Adding to Pointers</h3>

<p>First, let’s take an array of numbers.</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">};</span>
</code></pre></div>

<p>Then let’s get a pointer to the first element in that array:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">};</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// Or "int *p = a;" works just as well</span>
</code></pre></div>

<p>Then let’s print the value there by dereferencing the pointer:</p>

<div class="highlight"><pre class="highlight c"><code><span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// Prints 11</span>
</code></pre></div>

<p>Now let’s use pointer arithmetic to print the next element in the array, the one at index 1:</p>

<div class="highlight"><pre class="highlight c"><code><span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>  <span class="c1">// Prints 22!!</span>
</code></pre></div>

<p>What happened there? C knows that <code>p</code> is a pointer to an <code>int</code>. So it knows the <code>sizeof</code> an <code>int</code><a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">⁸²</a> and it knows to skip that many bytes to get to the next <code>int</code> after the first one!</p>

<p>In fact, the prior example could be written these two equivalent ways:</p>

<div class="highlight"><pre class="highlight c"><code><span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>        <span class="c1">// Prints 11</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">0</span><span class="p">));</span>  <span class="c1">// Prints 11</span>
</code></pre></div>

<p>because adding <code>0</code> to a pointer results in the same pointer.</p>

<p>Let’s think of the upshot here. We can iterate over elements of an array this way instead of using an array:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">};</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// Or "int *p = a;" works just as well</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>  <span class="c1">// Same as p[i]!</span>
<span class="p">}</span>
</code></pre></div>

<p>And that works the same as if we used array notation! Oooo! Getting closer to that array/pointer equivalence thing! More on this later in this chapter.</p>

<p>But what’s actually happening, here? How does it work?</p>

<p>Remember from early on that memory is like a big array, where a byte is stored at each array index?</p>

<p>And the array index into memory has a few names:</p>

<ul>
<li>  Index into memory</li>
<li>  Location</li>
<li>  Address</li>
<li>  <em>Pointer!</em></li>
</ul>

<p>So a point is an index into memory, somewhere.</p>

<p>For a random example, say that a number 3490 was stored at address (“index”) 23,237,489,202. If we have an <code>int</code> pointer to that 3490, that value of that pointer is 23,237,489,202… because the pointer is the memory address. Different words for the same thing.</p>

<p>And now let’s say we have another number, 4096, stored right after the 3490 at address 23,237,489,210 (8 higher than the 3490 because each <code>int</code> in this example is 8 bytes long).</p>

<p>If we add <code>1</code> to that pointer, it actually jumps ahead <code>sizeof(int)</code> bytes to the next <code>int</code>. It knows to jump that far ahead because it’s an <code>int</code> pointer. If it were a <code>float</code> pointer, it’d jump <code>sizeof(float)</code> bytes ahead to get to the next float!</p>

<p>So you can look at the next <code>int</code>, by adding <code>1</code> to the pointer, the one after that by adding <code>2</code> to the pointer, and so on.</p>

<h3>11.1.2 Changing Pointers</h3>

<p>We saw how we could add an integer to a pointer in the previous section. This time, let’s <em>modify the pointer, itself</em>.</p>

<p>You can just add (or subtract) integer values directly to (or from) any pointer!</p>

<p>Let’s do that example again, except with a couple changes. First, I’m going to add a <code>999</code> to the end of our numbers to act as a sentinel value. This will let us know where the end of the data is.</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">999</span><span class="p">};</span>  <span class="c1">// Add 999 here as a sentinel</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// p points to the 11</span>
</code></pre></div>

<p>And we also have <code>p</code> pointing to the element at index <code>0</code> of <code>a</code>, namely <code>11</code>, just like before.</p>

<p>Now—let’s start <em>incrementing</em> <code>p</code> so that it points at subsequent elements of the array. We’ll do this until <code>p</code> points to the <code>999</code>; that is, we’ll do it until <code>*p == 999</code>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="mi">999</span><span class="p">)</span> <span class="p">{</span>       <span class="c1">// While the thing p points to isn't 999</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>   <span class="c1">// Print it</span>
    <span class="n">p</span><span class="o">++</span><span class="p">;</span>                  <span class="c1">// Move p to point to the next int!</span>
<span class="p">}</span>
</code></pre></div>

<p>Pretty crazy, right?</p>

<p>When we give it a run, first <code>p</code> points to <code>11</code>. Then we increment <code>p</code>, and it points to <code>22</code>, and then again, it points to <code>33</code>. And so on, until it points to <code>999</code> and we quit.</p>

<h3>11.1.3 Subtracting Pointers</h3>

<p>You can subtract a value from a pointer to get to earlier address, as well, just like we were adding to them before.</p>

<p>But we can also subtract two pointers to find the difference between them, e.g. we can calculate how many <code>int</code>s there are between two <code>int*</code>s. The catch is that this only works within a single array<a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">⁸³</a>—if the pointers point to anything else, you get undefined behavior.</p>

<p>Remember how strings are <code>char*</code>s in C? Let’s see if we can use this to write another variant of <code>strlen()</code> to compute the length of a string that utilizes pointer subtraction.</p>

<p>The idea is that if we have a pointer to the beginning of the string, we can find a pointer to the end of the string by scanning ahead for the <code>NUL</code> character.</p>

<p>And if we have a pointer to the beginning of the string, and we computed the pointer to the end of the string, we can just subtract the two pointers to come up with the length!</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">my_strlen</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Start scanning from the beginning of the string</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="c1">// Scan until we find the NUL character</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span>
        <span class="n">p</span><span class="o">++</span><span class="p">;</span>

    <span class="c1">// Return the difference in pointers</span>
    <span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_strlen</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">));</span>  <span class="c1">// Prints "13"</span>
<span class="p">}</span>
</code></pre></div>

<p>Remember that you can only use pointer subtraction between two pointers that point to the same array!</p>

<h2>11.2 Array/Pointer Equivalence</h2>

<p>We’re finally ready to talk about this! We’ve seen plenty of examples of places where we’ve intermixed array notation, but let’s give out the <em>fundamental formula of array/pointer equivalence</em>:</p>

<div class="highlight"><pre class="highlight c"><code><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">*</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div>

<p>Study that! Those are equivalent and can be used interchangeably!</p>

<p>I’ve oversimplified a bit, because in my above example <code>a</code> and <code>b</code> can both be expressions, and we might want a few more parentheses to force order of operations in case the expressions are complex.</p>

<p>The spec is specific, as always, declaring (in C11 §6.5.2.1¶2):</p>

<blockquote>
<p><code>E1[E2]</code> is identical to <code>(*((E1)+(E2)))</code></p>
</blockquote>

<p>but that’s a little harder to grok. Just make sure you include parentheses if the expressions are complicated so all your math happens in the right order.</p>

<p>This means we can <em>decide</em> if we’re going to use array or pointer notation for any array or pointer (assuming it points to an element of an array).</p>

<p>Let’s use an array and pointer with both array and pointer notation:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">};</span>

    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// p points to the first element of a, 11</span>

    <span class="c1">// Print all elements of the array a variety of ways:</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>      <span class="c1">// Array notation with a</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>      <span class="c1">// Array notation with p</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>  <span class="c1">// Pointer notation with a</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>  <span class="c1">// Pointer notation with p</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">));</span>    <span class="c1">// Moving pointer p</span>
        <span class="c1">//printf("%d\n", *(a++));    // Moving array variable a--ERROR!</span>
<span class="p">}</span>
</code></pre></div>

<p>So you can see that in general, if you have an array variable, you can use pointer or array notion to access elements. Same with a pointer variable.</p>

<p>The one big difference is that you can <em>modify</em> a pointer to point to a different address, but you can’t do that with an array variable.</p>

<h3>11.2.1 Array/Pointer Equivalence in Function Calls</h3>

<p>This is where you’ll encounter this concept the most, for sure.</p>

<p>If you have a function that takes a pointer argument, e.g.:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">my_strlen</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
</code></pre></div>

<p>this means you can pass either an array or a pointer to this function and have it work!</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Antelopes"</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="s">"Wombats"</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_strlen</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>  <span class="c1">// Works!</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_strlen</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>  <span class="c1">// Works, too!</span>
</code></pre></div>

<p>And it’s also why these two function signatures are equivalent:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">int</span> <span class="n">my_strlen</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>    <span class="c1">// Works!</span>
<span class="kt">int</span> <span class="n">my_strlen</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span><span class="p">[])</span>   <span class="c1">// Works, too!</span>
</code></pre></div>

<h2>11.3 <code>void</code> Pointers</h2>

<p>You’ve already seen the <code>void</code> keyword used with functions, but this is an entirely separate, unrelated animal.</p>

<p>Sometimes it’s useful to have a pointer to a thing <em>that you don’t know the type of</em>.</p>

<p>I know. Bear with me just a second.</p>

<p>There are basically two use cases for this.</p>

<p>1. A function is going to operate on something byte-by-byte. For example, <code>memcpy()</code> copies bytes of memory from one pointer to another, but those pointers can point to any type. <code>memcpy()</code> takes advantage of the fact that if you iterate through <code>char*</code>s, you’re iterating through the bytes of an object no matter what type the object is. More on this in the <a href="pointers-iii-pointers-to-pointers-and-more.html#multibyte-values" rel="nofollow">Multibyte Values</a> subsection.</p>

<ol>
<li> Another function is calling a function you passed to it (a callback), and it’s passing you data. You know the type of the data, but the function calling you doesn’t. So it passes you <code>void*</code>s—’cause it doesn’t know the type—and you convert those to the type you need. The built-in <a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-qsort" rel="nofollow"><code>qsort()</code></a><a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">⁸⁴</a> and <a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-bsearch" rel="nofollow"><code>bsearch()</code></a><a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">⁸⁵</a> use this technique.</li>
</ol>

<p>Let’s look at an example, the built-in <code>memcpy()</code> function:</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">s2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div>

<p>This function copies <code>n</code> bytes of memory starting from address <code>s1</code> into the memory starting at address <code>s2</code>.</p>

<p>But look! <code>s1</code> and <code>s2</code> are <code>void*</code>s! Why? What does it mean? Let’s run more examples to see.</p>

<p>For instance, we could copy a string with <code>memcpy()</code> (though <code>strcpy()</code> is more appropriate for strings):</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Goats!"</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">t</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>  <span class="c1">// Copy 7 bytes--including the NUL terminator!</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>  <span class="c1">// "Goats!"</span>
<span class="p">}</span>
</code></pre></div>

<p>Or we can copy some <code>int</code>s:</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>  <span class="c1">// Copy 3 ints of data</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">// 22</span>
<span class="p">}</span>
</code></pre></div>

<p>That one’s a little wild—you see what we did there with <code>memcpy()</code>? We copied the data from <code>a</code> to <code>b</code>, but we had to specify how many <em>bytes</em> to copy, and an <code>int</code> is more than one byte.</p>

<p>OK, then—how many bytes does an <code>int</code> take? Answer: depends on the system. But we can tell how many bytes any type takes with the <code>sizeof</code> operator.</p>

<p>So there’s the answer: an <code>int</code> takes <code>sizeof(int)</code> bytes of memory to store.</p>

<p>And if we have 3 of them in our array, like we did in that example, the entire space used for the 3 <code>int</code>s must be <code>3 * sizeof(int)</code>.</p>

<p>(In the string example, earlier, it would have been more technically accurate to copy <code>7 * sizeof(char)</code> bytes. But <code>char</code>s are always one byte large, by definition, so that just devolves into <code>7 * 1</code>.)</p>

<p>We could even copy a <code>float</code> or a <code>struct</code> with <code>memcpy()</code>! (Though this is abusive—we should just use <code>=</code> for that):</p>

<div class="highlight"><pre class="highlight c"><code><span class="k">struct</span> <span class="n">antelope</span> <span class="n">my_antelope</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">antelopy</span> <span class="n">my_clone_antelope</span><span class="p">;</span>

<span class="c1">// ...</span>

<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_clone_antelope</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_antelope</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">my_antelope</span><span class="p">);</span>
</code></pre></div>

<p>Look at how versatile <code>memcpy()</code> is! If you have a pointer to a source and a pointer to a destination, and you have the number of bytes you want to copy, you can copy <em>any type of data</em>.</p>

<p>Imagine if we didn’t have <code>void*</code>. We’d have to write specialized <code>memcpy()</code> functions for each type:</p>

<div class="highlight"><pre class="highlight c"><code><span class="n">memcpy_int</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="n">memcpy_float</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="n">memcpy_double</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="n">memcpy_char</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="n">memcpy_unsigned_char</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="c1">// etc... blech!</span>
</code></pre></div>

<p>Much better to just use <code>void*</code> and have one function that can do it all.</p>

<p>That’s the power of <code>void*</code>. You can write functions that don’t care about the type and is still able to do things with it.</p>

<p>But with great power comes great responsibility. Maybe not <em>that</em> great in this case, but there are some limits.</p>

<p>1. You cannot do pointer arithmetic on a <code>void*</code>. 2. You cannot dereference a <code>void*</code>. 3. You cannot use the arrow operator on a <code>void*</code>, since it’s also a dereference. 4. You cannot use array notation on a <code>void*</code>, since it’s also a dereference, as well<a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">⁸⁶</a>.</p>

<p>And if you think about it, these rules make sense. All those operations rely on knowing the <code>sizeof</code> the type of data pointed to, and with <code>void*</code>, we don’t know the size of the data being pointed to—it could be anything!</p>

<p>But wait—if you can’t dereference a <code>void*</code> what good can it ever do you?</p>

<p>Like with <code>memcpy()</code>, it helps you write generic functions that can handle multiple types of data. But the secret is that, deep down, <em>you convert the `void</em>` to another type before you use it*!</p>

<p>And conversion is easy: you can just assign into a variable of the desired type<a href="https://ovelny.sh/chaos/beej&#x27;s-guide-to-c-programming/99-footnotes/" rel="nofollow">⁸⁷</a>.</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">'X'</span><span class="p">;</span>  <span class="c1">// A single char</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>  <span class="c1">// p points to the 'X'</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>   <span class="c1">// q also points to the 'X'</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// ERROR--cannot dereference void*!</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>  <span class="c1">// Prints "X"</span>
</code></pre></div>

<p>Let’s write our own <code>memcpy()</code> to try this out. We can copy bytes (<code>char</code>s), and we know the number of bytes because it’s passed in.</p>

<div class="highlight"><pre class="highlight c"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">my_memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">byte_count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Convert void*s to char*s</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>

    <span class="c1">// Now that we have char*s, we can dereference and copy them</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">byte_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">d</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Most of these functions return the destination, just in case</span>
    <span class="c1">// that's useful to the caller.</span>
    <span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Right there at the beginning, we copy the <code>void*</code>s into <code>char*</code>s so that we can use them as <code>char*</code>s. It’s as easy as that.</p>

<p>Then some fun in a while loop, where we decrement <code>byte_count</code> until it becomes false (<code>0</code>). Remember that with post-decrement, the value of the expression is computed (for <code>while</code> to use) and <em>then</em> the variable is decremented.</p>

<p>And some fun in the copy, where we assign <code>*d = *s</code> to copy the byte, but we do it with post-increment so that both <code>d</code> and <code>s</code> move to the next byte after the assignment is made.</p>

<p>Lastly, most memory and string functions return a copy of a pointer to the destination string just in case the caller wants to use it.</p>

<p>Now that we’ve done that, I just want to quickly point out that we can use this technique to iterate over the bytes of <em>any</em> object in C, <code>float</code>s, <code>struct</code>s, or anything!</p>

<p>Let’s run one more real-world example with the built-in <code>qsort()</code> routine that can sort <em>anything</em> thanks to the magic of <code>void*</code>s.</p>

<p>(In the following example, you can ignore the word <code>const</code>, which we haven’t covered yet.)</p>

<div class="highlight"><pre class="highlight c"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">// The type of structure we're going to sort</span>
<span class="k">struct</span> <span class="n">animal</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">leg_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// This is a comparison function called by qsort() to help it determine</span>
<span class="c1">// what exactly to sort by. We'll use it to sort an array of struct</span>
<span class="c1">// animals by leg_count.</span>
<span class="kt">int</span> <span class="nf">compar</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">elem1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">elem2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// We know we're sorting struct animals, so let's make both</span>
    <span class="c1">// arguments pointers to struct animals</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">animal</span> <span class="o">*</span><span class="n">animal1</span> <span class="o">=</span> <span class="n">elem1</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">animal</span> <span class="o">*</span><span class="n">animal2</span> <span class="o">=</span> <span class="n">elem2</span><span class="p">;</span>

    <span class="c1">// Return &lt;0 =0 or &gt;0 depending on whatever we want to sort by.</span>

    <span class="c1">// Let's sort ascending by leg_count, so we'll return the difference</span>
    <span class="c1">// in the leg_counts</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">animal1</span><span class="o">-&gt;</span><span class="n">leg_count</span> <span class="o">&gt;</span> <span class="n">animal2</span><span class="o">-&gt;</span><span class="n">leg_count</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">animal1</span><span class="o">-&gt;</span><span class="n">leg_count</span> <span class="o">&lt;</span> <span class="n">animal2</span><span class="o">-&gt;</span><span class="n">leg_count</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Let's build an array of 4 struct animals with different</span>
    <span class="c1">// characteristics. This array is out of order by leg_count, but</span>
    <span class="c1">// we'll sort it in a second.</span>
    <span class="k">struct</span> <span class="n">animal</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{.</span><span class="n">name</span><span class="o">=</span><span class="s">"Dog"</span><span class="p">,</span> <span class="p">.</span><span class="n">leg_count</span><span class="o">=</span><span class="mi">4</span><span class="p">},</span>
        <span class="p">{.</span><span class="n">name</span><span class="o">=</span><span class="s">"Monkey"</span><span class="p">,</span> <span class="p">.</span><span class="n">leg_count</span><span class="o">=</span><span class="mi">2</span><span class="p">},</span>
        <span class="p">{.</span><span class="n">name</span><span class="o">=</span><span class="s">"Antelope"</span><span class="p">,</span> <span class="p">.</span><span class="n">leg_count</span><span class="o">=</span><span class="mi">4</span><span class="p">},</span>
        <span class="p">{.</span><span class="n">name</span><span class="o">=</span><span class="s">"Snake"</span><span class="p">,</span> <span class="p">.</span><span class="n">leg_count</span><span class="o">=</span><span class="mi">0</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// Call qsort() to sort the array. qsort() needs to be told exactly</span>
    <span class="c1">// what to sort this data by, and we'll do that inside the compar()</span>
    <span class="c1">// function.</span>
    <span class="c1">//</span>
    <span class="c1">// This call is saying: qsort array a, which has 4 elements, and</span>
    <span class="c1">// each element is sizeof(struct animal) bytes big, and this is the</span>
    <span class="c1">// function that will compare any two elements.</span>
    <span class="n">qsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">animal</span><span class="p">),</span> <span class="n">compar</span><span class="p">);</span>

    <span class="c1">// Print them all out</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">leg_count</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>As long as you give <code>qsort()</code> a function that can compare two items that you have in your array to be sorted, it can sort anything. And it does this without needing to have the types of the items hardcoded in there anywhere. <code>qsort()</code> just rearranges blocks of bytes based on the results of the <code>compar()</code> function you passed in.</p>

    
    </main>
    <footer id="footer">
      <div class="footer-section"><a href="/license/">CC BY-NC-SA 4.0</a><p>&nbsp;::&nbsp;2019 - 2025 ovelny</p></div>
      <div class="footer-section">「七転び八起き」</div>
    </footer>
  </body>
</html>

